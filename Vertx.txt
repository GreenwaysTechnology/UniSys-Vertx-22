					Vertx
..............................................................................................File Descriptor:

-It is data structure(array) which is available in the kernal- having key -value pairs 
 It stores the information about io devices.

-It is created for every process - Per Process 

File Descriptor maps io devices with The application Progams

lets say i have java program runs on jvm.

When ever jvm starts , file descriptor is created and kept for io interaction.

File Descriptor contains two fields
 ------------------------------------
 File Descriptor Entries           File Pointer Reference
     0                                 STDIN    -KEYBOARD Binding
     1                                 STDOUT   -Monitor Binding
     2                                 STDERROR -Monitor Binding
     3                                  ?
     4                                  ?


The first three enteries are created when process bootstraps.

Lets take an eg : i want to read data from the disk file?.

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class CopyBytes {
    public static void main(String[] args) throws IOException {

        FileInputStream in = null;
        FileOutputStream out = null;

        try {
            in = new FileInputStream("xanadu.txt");
            out = new FileOutputStream("outagain.txt");
            int c;

            while ((c = in.read()) != -1) {
                out.write(c);
            }
        } finally {
            if (in != null) {
                in.close();
            }
            if (out != null) {
                out.close();
            }
        }
    }
}

In this program, when application calls "in.read()"
    ----------------->JVM invokes system call(api written in c language)------|os keneral
                      -->It will add an entry into file descriptor table and binds the disk file location
 
  
File Descriptor contains two fields
 ------------------------------------
 File Descriptor Entries           File Pointer Reference
     0                                 STDIN    -KEYBOARD Binding
     1                                 STDOUT   -Monitor Binding
     2                                 STDERROR -Monitor Binding
     3                                 HD------------->bINDING HARDDRIVE
     4                                 NETWORK -----|NEC BINDING
.............................................................................................
				Multi threading and IO Models
............................................................................................

Every modern process(JVM) is multi threaded.
Each thread can be created and assigned for an io operations : concurrent io /parrell io.
Every thread is blocked/freezed until data is ready from io channels.

Based this idea only web servers were designed : Multi threading and io.

In web , there is programming model request(read)-response(write)(Network IO) model

Client--------------------IO Channel------------------------Server

Server Design:
..............

Every Web server is multi threaded -tomcat.

When ever a new request(io request) is arrived, Tomcat(Server) creates/assigns "a thread"
............................................................................................
C10K Problem:
.............
The C10k problem is the problem of optimizing network sockets to handle a large number of clients at the same time.

 1000 REQ = 1000 Threads - This is Problem

 More Req ==Minimum number of Threads

Why? What is problem of Threading:

if i create thread
 -memory allocation 
 -managing life cycle of threads

if thread is created , requests kernal for data, if the data not ready.

if data is not ready during that time thread is waiting(blocking)/blocked 
lets say , thread has created it is waiting for 1ms for data. this 1ms during that thread is useless, can be used by any one.

The cpu, will pause the unused thread for 1ms, if data is ready again it will activate-This process is called context switch.
.............................................................................................
				How to build efficient network io apps
.............................................................................................

Before 2000, all programming languages used blocking io apis by default,even today all programming langugages blocking io apis.

C10K problem and its solution:

Every os has blocking api only.

After 2000, First,Linux introduced a new api called non blocking io api - "select"

1st Implementation:

 select  + read 

select will add entry , returns control back to process
read will be fired to read data once it is ready in the keneral
............................................................................................

2nd Implementation:

Poll:
.....

Poll is similar to Select -nonblocking,but data is reterived not by calling extra method(read).
Polling is nothing pushing- Data is pushed from the kernal to Application process

select is Pull based - Data is pulled from the kernal.

Even driven Programming , Event driven io. when ever data is ready, poll will start sending signal(event) to application Process, where application process listens for events, once event is given which starts processing that event.

...........................................................................................

3rd Implmentation:

epoll:

->epoll is a framework extended from poll.
->monitoring multiple file descriptors to see if I/O is possible on any of   them. 


Epoll loop:
           for (;;) {
               nfds = epoll_wait(epollfd, events, MAX_EVENTS, -1);
               if (nfds == -1) {
                   perror("epoll_wait");
                   exit(EXIT_FAILURE);
               }

               for (n = 0; n < nfds; ++n) {
                   if (events[n].data.fd == listen_sock) {
                       conn_sock = accept(listen_sock,
                                          (struct sockaddr *) &addr, &addrlen);
                       if (conn_sock == -1) {
                           perror("accept");
                           exit(EXIT_FAILURE);
                       }
                       setnonblocking(conn_sock);
                       ev.events = EPOLLIN | EPOLLET;
                       ev.data.fd = conn_sock;
                       if (epoll_ctl(epollfd, EPOLL_CTL_ADD, conn_sock,
                                   &ev) == -1) {
                           perror("epoll_ctl: conn_sock");
                           exit(EXIT_FAILURE);
                       }
                   } else {
                       do_use_fd(events[n].data.fd);
                   }
               }


Epoll runs a loop indefintly for io operations(network io), when ever data is ready which emits event to the process.

When operating systems supports non blocking infrastructure, language and runtimes should support that
The first non blocking implemention was nginx web server - the first c10k solution

flollwed by nginx "2008" -  Node.js- Non blocking soultion.
..............................................................................................
.............................................................................................
				Vertx Inspired from Node.js
............................................................................................

In node there is only one event loop thread, who process events from kernal.

Vertx added more threads to process events.

Vertx implements c10K problem solution on JVM
   -Limited threads but max concurrency
   -Non blocking io apis 

Vertx by default maintains threads based Number of cup cores

i have 12 core, each core -2 threads
 
 12*2 = 24 threads

                   24 threads now can handle XXXX no  Requests
...........................................................................................
...........................................................................................
			   Vertx Core Concepts
		Vertx helps to build 100% scalable non blocking + reactive applications
..............................................................................................

Reactive - Data Streaming
Nonblocking/Async -  Thread Management and processing events
..............................................................................................

Lets Code:

1.Vertx Instance -Vertx Engine
2.Verticals 
3.Event Bus
..............................................&&&&&&&&&&&&&&&&&.............................

How to setup vertx project

vertx supports

1.maven
2.gradle

project can be simple 

1.normal java project
2.standard mvn project
3.vertx project from https://start.vertx.io/


How to run Vertx Project?

Vertx application will have entry Point , configured in general pom.xml

<main.verticle>com.unisys.MainVerticle</main.verticle>
<launcher.class>io.vertx.core.Launcher</launcher.class>


mvnw clean compile exec:java

=mvnw clean package -  jar file - fat jar /regular
java -jar target/vertxstarter-1.0.0-SNAPSHOT-fat.jar
.............................................................................................
					Vertx Engine/Runtime
.............................................................................................

Vertx Engine is a java class, represented as interface in the vertx.io.core package.

Role of Vertx Engine:

1.To run vertx app
2.To help to access all non blocking infrastructure
  ->HTTP Webserver
  ->TCP Servers
  ->UDP Servers
  ->FS ACCESS
  ->Object interactions via "Event Bus".
  ->CPU Timer access
  ->App deployment and undeployment
  ->Create Shared data.

Vertx Application Components:
............................

In spring Framework apps are collection of objects called "beans".
In Vertx apps are collection of objects called "Verticles".

What is Verticle?

Verticle:
  -It is java object
  -Where we write all non blocking application logics.
  -It can be deployed and undeployed on vertx instance (engine).
  -It is based on design pattern called "Actor-like Model" - based on akka frameworks
  -Verticles are bound to "Event loop " , are processed by event loop threads.

Deployment means "the action of bringing resources into effective action." - allocating resource for use.

Deployment Resources for a Verticle:

1.Assign/bound a event loop thread to a verticle.

..............................................................................................
How to vertx Program?

Ways 

1. via main method
package com.unisys;

import io.vertx.core.Vertx;

public class HelloWorldVertx {
  public static void main(String[] args) {
    //Vertx Engine Creation
    Vertx vertx = Vertx.vertx();
    System.out.println(vertx);
    System.out.println(Thread.currentThread().getName());
    //create simple non blocking web server
    vertx.createHttpServer().requestHandler(req -> {
      System.out.println(Thread.currentThread().getName());
      req.response().end("Hello Vertx");
    }).listen(8080);

  }
}

2.via lanucher
<main.verticle>com.unisys.MainVerticle</main.verticle>
<launcher.class>io.vertx.core.Launcher</launcher.class>

io.vertx.core.Launcher;

A main() class that can be used to create Vert.x instance and deploy a verticle, or run a bare Vert.x instance.

This class is used by the vertx command line utility to deploy verticles from the command line. It is extensible as "commands" can be added using the CommandFactory SPI.

mvn compile exec:java


3.via vertx command line utility.
  -vertx 4 has removed external command line tools.

vertx

4.via java jar model

-fat jar / uber jar :
  -embeded application
 appcode + server code

mvn clean package
 
java -jar target/starter-vertx-1.0.0-SNAPSHOT-fat.jar
........................................................................................................

Vertx-Modules:
core
web
reactive
microservices
data
messaging
.......................................................................................................		vertx-core:

-Verticles
-Event loop Threads
-Callback based programming
		

Verticle:
  -It is java object
  -It can be deployed and undeployed on vertx instance (engine).
  -It is based on design pattern called "Actor-like Model" - based on akka frameworks
  -Verticles are bound to "Event loop" , are processed by event loop threads.

Verticle is interface which provides life cycle methods 
  -init
  -start - called when verticle during deployment
  -stop  - called when verticles during undeployment
..............................................................................................

Vertx Objective is to build non blocking io apps -  networks,filesystem,data base.

Vertx Programming styles:

1.Without Verticle

public class HelloWorldVertx {
  public static void main(String[] args) {
    //Vertx Engine Creation
    Vertx vertx = Vertx.vertx();
    System.out.println(vertx);
    System.out.println(Thread.currentThread().getName());
    //create simple non blocking web server
    vertx.createHttpServer().requestHandler(req -> {
      System.out.println(Thread.currentThread().getName());
      req.response().end("Hello Vertx");
    }).listen(8080);

  }
}


2.With Verticle
  Use of verticles with Vert.x is entirely optional, but if you use them they provide an  "actor-like deployment and concurrency model", out of the box.

verticle is  class , if you want to create your own verticle, you need to inherit.

import io.vertx.core.AbstractVerticle;

public class GreetingVerticle extends AbstractVerticle {
  
}

Verticle is interface which provides life cycle methods 
  -init
  -start - called when verticle during deployment
  -stop  - called when verticles during undeployment


................................................................................

Deploying Verticles

Via main Method:
import io.vertx.core.Vertx;

public class GreeterDeployerMain {
  public static void main(String[] args) {
    Vertx vertx = Vertx.vertx();
   //deploy the verticle on vertx engine
//    vertx.deployVerticle(new GreetingVerticle());
    vertx.deployVerticle(GreetingVerticle.class.getName());
    vertx.deployVerticle("com.unisys.GreetVerticle");
    vertx.close();
  }
}

via Verticle itself:

One Verticle can deploy other Verticle.

inside verticle vertx reference is available by default.

Vertx vert=Vertx.vertx(); you dont need to write this code

package com.unisys;

import io.vertx.core.AbstractVerticle;

public class GreeterDeployer extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new GreetingVerticle());
  }
}
..............................................................................................

Via Runner Class;
.................
package com.unisys;

import io.vertx.core.AbstractVerticle;
import io.vertx.example.util.Runner;

public class GreeterDeployer extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(GreeterDeployer.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new GreetingVerticle());
  }
}
.............................................................................................
				Vertx Core Concepts
............................................................................................

.............................................................................................
				Non Blocking Applications
..............................................................................................

Patterns for writting non blockings apps

1.callback style -  traditional
2.reactive style -  streaming

Non blocking apis
1.timer
2.http
3.fs

Callback Style

1.Future
2.Promise

Future:
io.vertx.core.Future

Vertx uses futures to reprsent "Asynchronous" Results

Future is like transport object to transport data between caller and callee in async manner.

 Caller----Future--------Callee

What type of data Future can carry.

 - Success---- |
		--- >Future
 - Failure---- |

AsyncResult<T> :
   Object which has either success data or failure data.
   Used in caller side to capture data which was sent by Callee
..............................................................................................

Use case : How to create Future,encasulate success,failure , how to listen for data?

package com.unisys.futures;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.example.util.Runner;

class FutureTransferVerticle extends AbstractVerticle {

  //method which returns future -  callee
  public Future<String> sayHello() {
//    return Future.future(new Handler<Promise<String>>() {
//      @Override
//      public void handle(Promise<String> stringPromise) {
//        stringPromise.complete("Hello");
//      }
//    });
    //We are returning
    return Future.future(future -> future.complete("Hello"));
  }

  //method which throws error
  public Future<String> createErrorMessage() {
    return Future.future(f -> f.fail("Something went wrong!!"));
  }

  //biz logic which may send success or failure data
  public Future<String> login(String username, String password) {
    return Future.future(handler -> {
      if (username.equals("admin") && password.equals("admin")) {
        handler.complete("Login success");
      } else {
        handler.fail("Login Failed");
      }
    });
  }


  @Override
  public void start() throws Exception {
    super.start();
    //caller
//    createFuture().onComplete(new Handler<AsyncResult<String>>() {
//      @Override
//      public void handle(AsyncResult<String> asyncResult) {
//             if(async.succ) {

//             } else {}
//      }
//    });
    sayHello().onComplete(asyncResult -> {
      if (asyncResult.succeeded()) {
        //read data
        System.out.println(asyncResult.result());
      } else {
        System.out.println(asyncResult.cause().getMessage());
      }
    });
    //listen for error
    createErrorMessage().onComplete(asyncResult -> {
      if (asyncResult.failed()) {
        System.out.println(asyncResult.cause());
      }
    });
    //listen for success or failer
    login("admin", "admin").onComplete(asyncResult -> {
      if (asyncResult.failed()) {
        System.out.println(asyncResult.cause());
      }
      System.out.println(asyncResult.result());
    });
    login("xxx", "xxx").onComplete(asyncResult -> {
      if (asyncResult.failed()) {
        System.out.println(asyncResult.cause());
      } else {
        System.out.println(asyncResult.result());
      }
    });
  }
}


public class FutureVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    System.out.println("deploying...");
    Runner.runExample(FutureVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("deploying...");

    vertx.deployVerticle(new FutureTransferVerticle());
  }
}
..............................................................................................
				Listener Short cuts
..............................................................................................

login().onComplete() -  1
   here handler<AsyncResult> is parameter
login().onSuccess()
login().onFailure()
   here direct data -Handler<T> is parameter

  login("admin", "admin")
      .onSuccess(res -> System.out.println(res))
      .onFailure(err -> System.out.println(err));
    login("admin", "admin")
      .onSuccess(System.out::println)
      .onFailure(System.out::println);
.............................................................................................
				Future Object creation types
............................................................................................


Pattern - 1:

Future.future() - factoryMethod
 public Future<String> login(String username, String password) {
    return Future.future(handler -> {
      if (username.equals("admin") && password.equals("admin")) {
        handler.complete("Login success");
      } else {
        handler.fail("Login Failed");
      }
    });
  }

Pattern - 2:

Future.succeedFuture()
Future.failedFuture()
 
  public Future<String> loginV1(String username, String password) {
    if (username.equals("admin") && password.equals("admin")) {
      return Future.succeededFuture("Login is Successful");
    } else {
      return Future.failedFuture("Login failed");
    }
  }
loginV1("admin", "admin")
      .onSuccess(System.out::println)
      .onFailure(System.out::println);


Pattern - 3, Instead of Returning Future, Pass function as parameter - Higher Order function Pattern

  public void loginV2(String userName, String password, Handler<AsyncResult<String>> aHandler) {
    if (userName.equals("admin") && password.equals("admin")) {
      //encapsulate data
      aHandler.handle(Future.succeededFuture("Login is Successful"));
    } else {
      aHandler.handle(Future.failedFuture("Login failed"));
    }
  }

loginV2("admin", "admin", handler -> {
      if (handler.succeeded()) {
        System.out.println(handler.result());
      } else {
        System.out.println(handler.cause());
      }
    });
..............................................................................................
				Callback Chaining
			        Nested Callbacks
.............................................................................................

Legacy Application flow : object oriented and sync flow
  
dependent operations  , should happen one by one

Object oriented seq work flow /Sync work flow

 1.connect db - connect()
 2.Query results -queryResult()
 3.Formate results -formateResult()
 4.add results into http response stream - write()
 5.send/flush the results to clients - send()

 Connection con=DriverManager.getConnection("connectionstring");
 QueryResult queryres=con.queryResult()
 List<T> results = formatResult(queryres)
 response.write(results)
 reponse.end();

...........................................................................................
How the above task can be done in functional programming ; vertx?


Functional sequential workflow:

 Nested Callback : Callback chaining: functional style

  Handler function is called as callback function

"The out put of one callback is input to the another callback : nested callbacks

   cb1
     --cb2
         -cb3
            --cbN
              --process the result.
.............................................................................................


Use case :

 getUser ----|if data is available
			|	|
			|
			      	 call login method with  output of getUser
                        |
		     if not
			 -error

Note : output of one function will be input to another function.
..............................................................................................
package com.unisys.callback;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.example.util.Runner;

//model
class User {
  private String userName;
  private String password;

  public User(String userName, String password) {
    this.userName = userName;
    this.password = password;
  }

  public String getUserName() {
    return userName;
  }

  public void setUserName(String userName) {
    this.userName = userName;
  }

  public String getPassword() {
    return password;
  }

  public void setPassword(String password) {
    this.password = password;
  }

}

class PageVerticle extends AbstractVerticle {

  //chanining

  //api - getUser - return user Details
  //login - which takes input from the getUser
  private Future<String> getUser() {
    User user = new User("admin", "admin");
//    User user = null;
    if (user != null) {
      return Future.succeededFuture(user.getUserName());
    } else {
      return Future.failedFuture("User not Found");
    }
  }

  //login method
  private Future<String> login(String userName) {
    if (userName.equals("admin")) {
      return Future.succeededFuture("Login Success");
    } else {
      return Future.failedFuture("Login failed");
    }
  }

  //page
  private Future<String> showPage(String status) {
    if (status.equals("Login Success")) {
      return Future.succeededFuture("Welcome to Dashboard");
    } else {
      return Future.failedFuture("Please Retry!");
    }

  }

  @Override

  public void start() throws Exception {
    super.start();
    getUser().onComplete(e -> {
      if (e.succeeded()) {
        System.out.println(e.result());
        //call login method
        login(e.result()).onComplete(loginEvent -> {
          if (loginEvent.succeeded()) {
            System.out.println(loginEvent.result());
            showPage(loginEvent.result()).onComplete(pageEvent -> {
              if (pageEvent.succeeded()) {
                System.out.println(pageEvent.result());
              } else {
                System.out.println(pageEvent.cause());
              }
            });
          } else {
            System.out.println(loginEvent.cause());
          }
        });
      } else {
        System.out.println(e.cause());
      }
    });
  }
}


public class CallbackVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(CallbackVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new PageVerticle());
  }
}
..............................................................................................
				Callback Hell
.............................................................................................

getUser().onComplete(e -> {
      if (e.succeeded()) {
        System.out.println(e.result());
        //call login method
        login(e.result()).onComplete(loginEvent -> {
          if (loginEvent.succeeded()) {
            System.out.println(loginEvent.result());
            showPage(loginEvent.result()).onComplete(pageEvent -> {
              if (pageEvent.succeeded()) {
                System.out.println(pageEvent.result());
              } else {
                System.out.println(pageEvent.cause());
              }
            });
          } else {
            System.out.println(loginEvent.cause());
          }
        });
      } else {
        System.out.println(e.cause());
      }
    });

Look at the above code , ask your self

1.is it easy to understand?
2.is it easy to scale
3.is it easy to maintain

No!

This is called callback hell; The callback hell is way of writing complex callbacks.

can we escape from callback hell problem, how to write better callback based programming?

Yes! 
.................

Refactoring callback chaining code.
//How to refactor this above code
    getUser().onSuccess(user -> {
      System.out.println(user);
      login(user).onSuccess(status -> {
        System.out.println(status);
        showPage(status).onSuccess(page -> {
          System.out.println(page);
        }).onFailure(err -> {
          System.out.println(err);
        });
      }).onFailure(err -> {
        System.out.println(err);
      });
    }).onFailure(err -> {
      System.out.println(err);
    });
.............................................................................................
				Callback Hell Soultion :Future.compose Method

.............................................................................................

f1.and(f2)

package com.unisys.callback;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.example.util.Runner;

//model
class User {
  private String userName;
  private String password;

  public User(String userName, String password) {
    this.userName = userName;
    this.password = password;
  }

  public String getUserName() {
    return userName;
  }

  public void setUserName(String userName) {
    this.userName = userName;
  }

  public String getPassword() {
    return password;
  }

  public void setPassword(String password) {
    this.password = password;
  }

}

class PageVerticle extends AbstractVerticle {

  //chanining

  //api - getUser - return user Details
  //login - which takes input from the getUser
  private Future<String> getUser() {
    System.out.println("Get User is called");
    User user = new User("admin", "admin");
//    User user = null;
    if (user != null) {
      return Future.succeededFuture(user.getUserName());
    } else {
      return Future.failedFuture("User not Found");
    }
  }

  //login method
  private Future<String> login(String userName) {
    System.out.println("login is called");

    if (userName.equals("admin")) {
      return Future.succeededFuture("Login Success");
    } else {
      return Future.failedFuture("Login failed");
    }
  }

  //page
  private Future<String> showPage(String status) {
    System.out.println("ShowPage is called");

    if (status.equals("Login Success")) {
      return Future.succeededFuture("Welcome to Dashboard");
    } else {
      return Future.failedFuture("Please Retry!");
    }

  }

  @Override

  public void start() throws Exception {
    super.start();
//    getUser().onComplete(e -> {
//      if (e.succeeded()) {
//        System.out.println(e.result());
//        //call login method
//        login(e.result()).onComplete(loginEvent -> {
//          if (loginEvent.succeeded()) {
//            System.out.println(loginEvent.result());
//            showPage(loginEvent.result()).onComplete(pageEvent -> {
//              if (pageEvent.succeeded()) {
//                System.out.println(pageEvent.result());
//              } else {
//                System.out.println(pageEvent.cause());
//              }
//            });
//          } else {
//            System.out.println(loginEvent.cause());
//          }
//        });
//      } else {
//        System.out.println(e.cause());
//      }
//    });
//    //How to refactor this above code
//    getUser().onSuccess(user -> {
//      System.out.println(user);
//      login(user).onSuccess(status -> {
//        System.out.println(status);
//        showPage(status).onSuccess(page -> {
//          System.out.println(page);
//        }).onFailure(err -> {
//          System.out.println(err);
//        });
//      }).onFailure(err -> {
//        System.out.println(err);
//      });
//    }).onFailure(err -> {
//      System.out.println(err);
//    });

    //compose method
    System.out.println("Using compose Method");
//    getUser().compose(user -> {
//        System.out.println("Get user is called");
//        return login(user); //Return Future
//      }).compose(status -> {
//        System.out.println("Login is called");
//        return showPage(status);
//      })
//      .onSuccess(s -> {
//        System.out.println("Show page is called");
//        System.out.println(s);
//      }).onFailure(err -> {
//        System.out.println(err);
//      });
    getUser()
      .compose(user -> login(user))
      .compose(status -> showPage(status))
      .onSuccess(s -> {
        System.out.println(s);
      }).onFailure(err -> {
        System.out.println(err);
      });
    getUser()
      .compose(this::login)
      .compose(this::showPage)
      .onSuccess(System.out::println)
      .onFailure(System.out::println);
  }
}


public class CallbackVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(CallbackVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new PageVerticle());
  }
}

..........................................................................................
				Compose Eg
package com.unisys.callback;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.example.util.Runner;

//model
class User {
  private String userName;
  private String password;

  public User(String userName, String password) {
    this.userName = userName;
    this.password = password;
  }

  public String getUserName() {
    return userName;
  }

  public void setUserName(String userName) {
    this.userName = userName;
  }

  public String getPassword() {
    return password;
  }

  public void setPassword(String password) {
    this.password = password;
  }

}

class PageVerticle extends AbstractVerticle {

  //chanining

  //api - getUser - return user Details
  //login - which takes input from the getUser
  private Future<String> getUser() {
    System.out.println("Get User is called");
    User user = new User("admin", "admin");
//    User user = null;
    if (user != null) {
      return Future.succeededFuture(user.getUserName());
    } else {
      return Future.failedFuture("User not Found");
    }
  }

  //login method
  private Future<String> login(String userName) {
    System.out.println("login is called");

    if (userName.equals("admin")) {
      return Future.succeededFuture("Login Success");
    } else {
      return Future.failedFuture("Login failed");
    }
  }

  //page
  private Future<String> showPage(String status) {
    System.out.println("ShowPage is called");

    if (status.equals("Login Success")) {
      return Future.succeededFuture("Welcome to Dashboard");
    } else {
      return Future.failedFuture("Please Retry!");
    }

  }

  @Override

  public void start() throws Exception {
    super.start();
//    getUser().onComplete(e -> {
//      if (e.succeeded()) {
//        System.out.println(e.result());
//        //call login method
//        login(e.result()).onComplete(loginEvent -> {
//          if (loginEvent.succeeded()) {
//            System.out.println(loginEvent.result());
//            showPage(loginEvent.result()).onComplete(pageEvent -> {
//              if (pageEvent.succeeded()) {
//                System.out.println(pageEvent.result());
//              } else {
//                System.out.println(pageEvent.cause());
//              }
//            });
//          } else {
//            System.out.println(loginEvent.cause());
//          }
//        });
//      } else {
//        System.out.println(e.cause());
//      }
//    });
//    //How to refactor this above code
//    getUser().onSuccess(user -> {
//      System.out.println(user);
//      login(user).onSuccess(status -> {
//        System.out.println(status);
//        showPage(status).onSuccess(page -> {
//          System.out.println(page);
//        }).onFailure(err -> {
//          System.out.println(err);
//        });
//      }).onFailure(err -> {
//        System.out.println(err);
//      });
//    }).onFailure(err -> {
//      System.out.println(err);
//    });

    //compose method
    System.out.println("Using compose Method");
//    getUser().compose(user -> {
//        System.out.println("Get user is called");
//        return login(user); //Return Future
//      }).compose(status -> {
//        System.out.println("Login is called");
//        return showPage(status);
//      })
//      .onSuccess(s -> {
//        System.out.println("Show page is called");
//        System.out.println(s);
//      }).onFailure(err -> {
//        System.out.println(err);
//      });
    // "hello".trim().toUpperCase()
    //Future.compose().compose().onSuccess().OnFailure
    getUser()
      .compose(user -> login(user))
      .compose(status -> showPage(status))
      .onSuccess(s -> {
        System.out.println(s);
      }).onFailure(err -> {
        System.out.println(err);
      });
    getUser()
      .compose(this::login)
      .compose(this::showPage)
      .onSuccess(System.out::println)
      .onFailure(System.out::println);
  }
}


public class CallbackVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(CallbackVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new PageVerticle());
  }
}
..............................................................................................
			   .............................................................................................
				Advanced Composition :CompositFuture
.............................................................................................
		
i have three methods

-startDbServer
-startHttpServer
-startConfigServer

After success of all methods only i have to initalize my app, if any one of the server failed
i have to throw error and stop .

Future Coordination:
 Coordination of mutliple futures can be achieved with Vertx futures.

Supports concurrent composition(run serveral async operations in paralle) and sequential composition -chain async operations.

CompositeFuture.all(f1,f2,f3,f4,f5,f6)

-all composition waits until all futures are successful or any one fails.

CompositeFuture.any(f1,f2,f3,f4,f5,f6)
    any composition waits for the succeeded future.

package com.cts.vertx.future;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.CompositeFuture;
import io.vertx.core.Future;
import io.vertx.example.util.Runner;

public class CompositFutureVerticle extends AbstractVerticle {

  public static void main(String[] args) {
    Runner.runExample(CompositFutureVerticle.class);
  }

  public Future<String> startDbServer() {
    System.out.println("Db Server Started");
    return Future.succeededFuture("Db server is up");
  }

  public Future<String> startWebServer() {
    System.out.println("WebServer Server Started");
    //  return Future.succeededFuture("Web server is up");
    return Future.failedFuture("Port is already In Use");
  }

  public Future<String> startConfigServer() {
    System.out.println("Config Server Started");
    return Future.succeededFuture("Config Server is up");
  }

  @Override
  public void start() throws Exception {
    super.start();

    Future<String> dbServer = startDbServer();
    Future<String> webServer = startWebServer();
    Future<String> configServer = startConfigServer();
    //coordinate all servers; make sure every server is ready.
    CompositeFuture.all(dbServer, webServer, configServer).onComplete(ar -> {
      if (ar.succeeded()) {
        System.out.println("All Server is Up");
      } else {
        System.out.println(ar.cause());
      }
    });

  }
}
..............................................................................................
Promises:

Async Wrapper Object : Promise:
...............................

Promise is async abstraction largly promoted by javascript community.

Dont Compare  javascript Promises with Vertx Promises , because both are different.

Promise is "semantically meaningfull abstraction" for handling async results.

Many times developers confuse with java Future and Vertx Future.

Promises can't be processed directly with onComplete/setHandler/OnSuccecc/onFailure apis.

Promises must be converted into Future before processing.


Promise:

package com.unisys.promises;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.example.util.Runner;

class LoginVerticle extends AbstractVerticle {

  //Return Promise, later convert into Future if you want, or any api dirctly uses promises
  public Promise<String> auth(String userName, String password) {
    //create Promise object
    Promise<String> promise = Promise.promise();
    if (userName.equals("admin") && password.equals("admin")) {
      promise.complete("Login success");
    } else {
      promise.fail("Login failed");
    }
    return promise;
  }

  public Future<String> authV1(String userName, String password) {
    //create Promise object
    Promise<String> promise = Promise.promise();
    if (userName.equals("admin") && password.equals("admin")) {
      promise.complete("Login success");
    } else {
      promise.fail("Login failed");
    }
    return promise.future();
  }

  @Override
  public void start() throws Exception {
    super.start();
    //future method will convert promise into Future
    auth("admin", "admin").future()
      .onSuccess(System.out::println)
      .onFailure(System.out::println);

    authV1("admin", "admin")
      .onSuccess(System.out::println)
      .onFailure(System.out::println);
  }
}

public class PromiseVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(PromiseVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new LoginVerticle());
  }
}
............................................................................................
				Verticle Start Method
...........................................................................................


Async Verticle Start and Stop:

Sometimes you want to do something in your verticle start-up which takes some time and you don’t want the verticle to be considered deployed until that happens. For example you might want to start an HTTP server in the start method and propagate the asynchronous result of the server listen method

The way to do it is to implement the asynchronous start method(start method with Promise Arg)
.This version of the method takes a Future(Promise) as a parameter. When the method returns the verticle will not be considered deployed.

Every Verticle will have unique deploymentId, which can be used to unDeploy the verticles

package com.unisys.promises;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.example.util.Runner;

public class DeployHttpVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(DeployHttpVerticle.class);
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);

//        vertx.deployVerticle(new HttpVerticle(), ar -> {
//      if (ar.succeeded()) {
//        System.out.println("Verticle deloyed  : " + ar.result());
//      }
//    });
    vertx.deployVerticle(HttpVerticle.class.getName(), ar -> {
      if (ar.succeeded()) {
        System.out.println(HttpVerticle.class.getName() + " Deployment ID " +  ar.result());
      }
    });
    vertx.deployVerticle(HttpVerticle.class.getName(), ar -> {
      if (ar.succeeded()) {
        System.out.println(HttpVerticle.class.getName() + " Deployment ID " +  ar.result());
      }
    });
  }
}
..............................................................................................
				 Vertx Non Blocking Programming(IO)
..............................................................................................

Vertx provides lot of non blocking apis

1.Timer
2.File System
3.HTTP API


package com.unisys.nonblocking.timers;

import io.vertx.core.*;
import io.vertx.example.util.Runner;

public class TimersVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(TimersVerticle.class);
  }

  private void blockMe(String str) {
    System.out.println(str);
  }

  //  public void delay(long delayTime) {
//    vertx.setTimer(delayTime, handler -> {
//      System.out.println("I am delayed output" + "Timeout is " + delayTime);
//    });
//  }
//  public Future<String> delay(long delayTime) {
//    Future<String> future = Future.future(ar -> {
//      vertx.setTimer(delayTime, handler -> {
//        //System.out.println("I am delayed output" + "Timeout is " + delayTime);
//        String response = "I am delayed output" + "Timeout is " + delayTime;
//      });
//    });
//    //return future;
//
//  }

  public void delay(long delayTime, Handler<AsyncResult<String>> aHandler) {
    vertx.setTimer(delayTime, handler -> {
      String response = "I am delayed output" + "Timeout is " + delayTime;
      aHandler.handle(Future.succeededFuture(response));
    });
  }

  //tick
  public void tick(Handler<AsyncResult<String>> aHandler) {
    long timerId = vertx.setPeriodic(1000, handler -> {
      aHandler.handle(Future.succeededFuture(Math.random() + ""));
    });
    //stop ticking
    vertx.setTimer(10000, stopHandler -> {
      System.out.println("Stop Polling");
      vertx.cancelTimer(timerId);
    });
  }


  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    blockMe("start");
//    delay(5000);
//    delay(3000);
    delay(500, asyncResult -> {
      System.out.println(asyncResult.result());
    });
    tick(res -> {
      System.out.println(res.result());
    });

    blockMe("end");
  }
}
..............................................................................................
				   Data Interchange Formats
..............................................................................................

JSON :
package com.unisys.datainterchange;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;

public class JSONVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(JSONVerticle.class);
  }

  public Future<JsonObject> getUser() {
    JsonObject user = new JsonObject();
    user.put("id", 1);
    user.put("firstName", "Subramanian");
    user.put("lastName", "Murugan");
    return Future.succeededFuture(user);
  }


  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    getUser().onSuccess(user -> {
      System.out.println(user.encodePrettily());
    });
  }
}
.............................................................................................
					Fluent Api /Fluent Patterns
...........................................................................................
Instead of writing multiple lines of code and storing them into mutliple variables. we can chain the apis, finally we can get output, This is sometimes called as builder pattern.
Vertx apis are fully fulent.


package com.unisys.datainterchange;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;

public class JSONVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(JSONVerticle.class);
  }

  public Future<JsonArray> getUser() {
//    JsonObject user = new JsonObject();
//    user.put("id", 1);
//    user.put("firstName", "Subramanian");
//    user.put("lastName", "Murugan");
    //Vertx Flutent Pattern
    JsonObject user = new JsonObject()
      .put("id", 1)
      .put("firstName", "Subramanian")
      .put("lastName", "Murugan")
      .put("address", new JsonObject()
        .put("city", "Coimbatore")
        .put("state", "Tamil Nadu"));

    JsonArray users = new JsonArray()
      .add(user)
      .add(user)
      .add(new JsonObject()
        .put("id", 1)
        .put("firstName", "Subramanian")
        .put("lastName", "Murugan")
        .put("address", new JsonObject()
          .put("city", "Coimbatore")
          .put("state", "Tamil Nadu")));


    return Future.succeededFuture(users);
  }


  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    getUser().onSuccess(user -> {
      System.out.println(user.encodePrettily());
    });
  }
}
..............................................................................................
Merging:
package com.unisys.datainterchange;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;

public class JSONVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(JSONVerticle.class);
  }

  public Future<JsonArray> getUser() {
//    JsonObject user = new JsonObject();
//    user.put("id", 1);
//    user.put("firstName", "Subramanian");
//    user.put("lastName", "Murugan");
    //Vertx Flutent Pattern
    JsonObject skill = new JsonObject().put("skillId", 100).put("skill", "Vertx");

    JsonObject user = new JsonObject()
      .put("id", 1)
      .put("firstName", "Subramanian")
      .put("lastName", "Murugan")
      .mergeIn(skill)
      .put("address", new JsonObject()
        .put("city", "Coimbatore")
        .put("state", "Tamil Nadu"));

    JsonArray users = new JsonArray()
      .add(user)
      .add(user)
      .add(new JsonObject()
        .put("id", 1)
        .put("firstName", "Subramanian")
        .put("lastName", "Murugan")
        .put("address", new JsonObject()
          .put("city", "Coimbatore")
          .put("state", "Tamil Nadu")));


    return Future.succeededFuture(users);
  }


  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    getUser().onSuccess(user -> {
      System.out.println(user.encodePrettily());

    });
  }
}
.............................................................................................
				Non Blocking Network IO Application
.............................................................................................

HTTP Server Application:

=>Vertx provides webserver, you dont need to deploy vertx apps on Tomcat like container.
=>Vertx Webserver is fully non blocking, powered with event loop threads.


vertx.createHttpServer();

package com.unisys.nonblocking.http;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerResponse;
import io.vertx.example.util.Runner;

public class SimpleHTTPVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(SimpleHTTPVerticle.class);
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    //writing http apps
    HttpServer httpServer = vertx.createHttpServer();

    //Your app code : Request and Response Handlers
    httpServer.requestHandler(request -> {
      HttpServerResponse response = request.response();
      response.end("Hello Vertx");
    });
    //start the server
    httpServer.listen(3000, httpServerAsyncResult -> {
      if (httpServerAsyncResult.succeeded()) {
        System.out.println("Server is Up @ " + httpServerAsyncResult.result().actualPort());
      } else {
        System.out.println(httpServerAsyncResult.cause());
      }
    });

  }
}
..............................................................................................

Fluent WebServer:
package com.unisys.nonblocking.http;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.AsyncResult;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerRequest;
import io.vertx.example.util.Runner;

public class FluentHTTPServer extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(FluentHTTPServer.class);
  }

  private static void handle(HttpServerRequest request) {
    request.response().end("Hello Http Server");
  }

  private static void startServer(AsyncResult<HttpServer> httpServerAsyncResult) {
    if (httpServerAsyncResult.succeeded()) {
      System.out.println("Server is Up @ " + httpServerAsyncResult.result().actualPort());
    } else {
      System.out.println(httpServerAsyncResult.cause());
    }
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    //writing http apps
//    vertx.createHttpServer()
//      .requestHandler(request -> request.response().end("Hello Http Server"))
//      .listen(3000, httpServerAsyncResult -> {
//        if (httpServerAsyncResult.succeeded()) {
//          System.out.println("Server is Up @ " + httpServerAsyncResult.result().actualPort());
//        } else {
//          System.out.println(httpServerAsyncResult.cause());
//        }
//      });

    vertx.createHttpServer()
      .requestHandler(FluentHTTPServer::handle)
      .listen(3000, FluentHTTPServer::startServer);

  }
}
.............................................................................................
				  How to write Restfull webservices
..............................................................................................

Web:
  Distributed Information system 

In 1981/82 , Internet was open sourced...

British scientist Tim Berners-Lee invented the World Wide Web while working at CERN in 1989,based on internet.

Internet - network system
Web -software system , helps to transfer information over internet.

1991 - Web started for other biz systems.

1989 -1995 - Static Web- only transfering html.
1995-- till date - dynamic content generation tech -  cgi,j2ee,asp,php..

1998- Ecommerce - How to transfer data/information among biz 

Birth of Web Services:
......................

The Program which sends data /information via internet to other systems not inthe form of html.

2000 -  The data interchange conference held. where many people proposed various data formats
There were more than 30 formates proposed - xml,json,dat,txt,csv.........
At the end "XML" Was choosen. 

Web based on XML format - WebServices using XML - SOAP(protocal designed to transport xml docs over http) Web Service

2005 -  SOAP based webservices started failing due to XML documents.

REST Got introduced -  
  REST Can transport data over http only.
  REST can transport data in different formats -  JSON
  REST modeled based on HTTP verb semantics -  GET,UPDATE,DELETE,PUT.

2008 - SPA  How to build  Userfaces in the client side.
..............................................................................................
				Today Web Technology

API : Application Programming Interface
 entry and exit point of data transmission.
 Unit of Computation.
 API is implemented in many ways

1.REST APIS
2.GraphQL API
3.RPC/RPI api
4.MOM  api 

Client Side - SPAS/Mobile Apps


REST APIS Using Vertx:
......................

Resource:
  The data which need to be returned.

Resource identifier -  URI - "/api/customers/list" - GET 

API Verbs
 GET -  read
 PUT  - update
 DELETE - remove
 POST -  Send data


package com.unisys.nonblocking.http;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpMethod;
import io.vertx.example.util.Runner;

public class SimpleHTTPAPI extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(SimpleHTTPAPI.class);
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    vertx.createHttpServer()
      .requestHandler(request -> {
        //build rest api
        if (request.uri().equals("/api/users") && request.method() == HttpMethod.GET) {
          request.response().setStatusCode(200).end("users-GET");
        }
        if (request.uri().equals("/api/users") && request.method() == HttpMethod.POST) {
          request.response().setStatusCode(200).end("users-POST");
        }
        if (request.uri().equals("/api/users") && request.method() == HttpMethod.PUT) {
          request.response().setStatusCode(200).end("users-PUT");
        }
      })
      .listen(3000,server -> {
        if (server.succeeded()) {
          System.out.println(server.result().actualPort() + " Server is running");
        } else {
          System.out.println(server.cause());
        }
      });


  }
}
I WANT TO build REST End point :


URL - resource mapping
 /api/resource
 
METHOD -  GET ,POST,PUT,DELETE....


  public void buildREST() {
    vertx.createHttpServer().requestHandler(request -> {
      //URL MAPPING AND METHOD MAPPING
      if (request.uri().equals("/api/users") && request.method() == HttpMethod.GET) {
        request.response().setStatusCode(200).end("users-GET");
      }
      if (request.uri().equals("/api/users") && request.method() == HttpMethod.POST) {
        request.response().setStatusCode(200).end("users-POST");
      }
      if (request.uri().equals("/api/users") && request.method() == HttpMethod.PUT) {
        request.response().setStatusCode(200).end("users-PUT");
      }
    }).listen(3000, httpServerAsyncResult -> {
      if (httpServerAsyncResult.succeeded()) {
        System.out.println("server is running at " + httpServerAsyncResult.result().actualPort());
      } else {
        System.out.println("Server has failed to start");
      }
    });
  }

Have a look at the above, notice the drawbacks.

-The developer write all method and resource mapping logic
-There is no proper modularity in build ing apps.

Soultion:

Vertx provides a small framework for abstracting these things
vertx-web

Concepts:

Router:
........
 Router is one the core concepts of vertx-web.
 Its object which maintains zero or more Routes("url mappers")
 Router takes an http request and finds the matching routing for that request.
 Every route has handler which process requests and send responses.


RoutingContext:
   It is container object , from which you can get request and response object.


Use case : Basic routing:

package com.unisys.nonblocking.http.web;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerOptions;
import io.vertx.core.http.HttpServerResponse;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;
import io.vertx.ext.web.Router;

public class SimpleWebAPI extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(SimpleWebAPI.class);
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);

    HttpServerOptions options;
    HttpServer server = vertx.createHttpServer();
//    server.requestHandler(request -> {
//      HttpServerResponse serverResponse = request.response();
//      serverResponse.setStatusCode(200);
//      serverResponse.putHeader("content-type", "application/json");
//      JsonObject greet = new JsonObject().put("message", "Hello");
//      serverResponse.end(greet.encodePrettily());
//    });

    //Router creation
    Router router = Router.router(vertx);
    //route
    router.route().handler(ctx -> {
      HttpServerResponse serverResponse = ctx.response();
      serverResponse.setStatusCode(200);
      serverResponse.putHeader("content-type", "application/json");
      JsonObject greet = new JsonObject().put("message", "Hello Vertx Web");
      serverResponse.end(greet.encodePrettily());
    });

    server.requestHandler(router);
    server.listen(8080);

  }
}
...........................................................................................
					Routers using route method

package com.unisys.nonblocking.http.web;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpMethod;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerOptions;
import io.vertx.core.http.HttpServerResponse;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;
import io.vertx.ext.web.Router;

public class SimpleWebAPI extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(SimpleWebAPI.class);
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);

    HttpServerOptions options;
    HttpServer server = vertx.createHttpServer();
//    server.requestHandler(request -> {
//      HttpServerResponse serverResponse = request.response();
//      serverResponse.setStatusCode(200);
//      serverResponse.putHeader("content-type", "application/json");
//      JsonObject greet = new JsonObject().put("message", "Hello");
//      serverResponse.end(greet.encodePrettily());
//    });

    //Router creation
    Router router = Router.router(vertx);

    //new Route
    router.route(HttpMethod.GET, "/api/hello").handler(ctx -> {
      System.out.println("hello");
      HttpServerResponse serverResponse = ctx.response();
      serverResponse.setStatusCode(200);
      serverResponse.putHeader("content-type", "application/json");
      JsonObject greet = new JsonObject().put("message", "Hello");
      serverResponse.end(greet.encodePrettily());
    });
    router.route(HttpMethod.GET, "/api/hai").handler(ctx -> {
      System.out.println("hai");
      HttpServerResponse serverResponse = ctx.response();
      serverResponse.setStatusCode(200);
      serverResponse.putHeader("content-type", "application/json");
      JsonObject greet = new JsonObject().put("message", "Hai");
      serverResponse.end(greet.encodePrettily());
    });
    //route : wild card pattern  , any route
    router.route().handler(ctx -> {
      HttpServerResponse serverResponse = ctx.response();
      serverResponse.setStatusCode(200);
      serverResponse.putHeader("content-type", "application/json");
      JsonObject greet = new JsonObject().put("message", "Home");
      serverResponse.end(greet.encodePrettily());
    });
    server.requestHandler(router);
    server.listen(8080);

  }
}
............................................................................................
				Path Parameters
............................................................................................
package com.unisys.nonblocking.http.web;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerResponse;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;
import io.vertx.ext.web.Router;

public class RouterVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(RouterVerticle.class);
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    HttpServer server = vertx.createHttpServer();
    //Router creation
    Router router = Router.router(vertx);


    //new Route
    router.get("/api/hello").handler(ctx -> {
      System.out.println("hello");
      HttpServerResponse serverResponse = ctx.response();
      serverResponse.setStatusCode(200);
      serverResponse.putHeader("content-type", "application/json");
      JsonObject greet = new JsonObject().put("message", "Hello");
      serverResponse.end(greet.encodePrettily());
    });
    router.get("/api/hai").handler(ctx -> {
      System.out.println("hai");
      HttpServerResponse serverResponse = ctx.response();
      serverResponse.setStatusCode(200);
      serverResponse.putHeader("content-type", "application/json");
      JsonObject greet = new JsonObject().put("message", "Hai");
      serverResponse.end(greet.encodePrettily());
    });
    router.post("/api/hai").handler(ctx -> {
      System.out.println("hai");
      HttpServerResponse serverResponse = ctx.response();
      serverResponse.setStatusCode(200);
      serverResponse.putHeader("content-type", "application/json");
      JsonObject greet = new JsonObject().put("message", "Hai -POST");
      serverResponse.end(greet.encodePrettily());
    });
//path Parameters: dynamic url  /api/hello/subramanian | Ram | John
    router.get("/api/hello/:whom").handler(ctx -> {
      HttpServerResponse serverResponse = ctx.response();
      //using request object extract path parameters
      String whom = ctx.pathParam("whom");
      serverResponse.setStatusCode(200);
      serverResponse.putHeader("content-type", "application/json");
      JsonObject greet = new JsonObject().put("message", "greet " + whom);
      serverResponse.end(greet.encodePrettily());
    });

    //route : wild card pattern  , any route
    router.route().handler(ctx -> {
      HttpServerResponse serverResponse = ctx.response();
      serverResponse.setStatusCode(200);
      serverResponse.putHeader("content-type", "application/json");
      JsonObject greet = new JsonObject().put("message", "Home");
      serverResponse.end(greet.encodePrettily());
    });
    server.requestHandler(router);
    server.listen(8080);

  }
}
.............................................................................................
				How to read Payload
.............................................................................................


How to read payload?

 router.post("/api/greet").handler(ctx -> {
      HttpServerResponse serverResponse = ctx.response();
      //reading data:
      JsonObject payload = ctx.getBodyAsJson();
      System.out.println(payload.encodePrettily());

      serverResponse.setStatusCode(200);
      serverResponse.putHeader("content-type", "application/json");
      JsonObject greet = new JsonObject().put("message", "Hai -POST");
      serverResponse.end(greet.encodePrettily());
    });

when you run, you will get error like below?

Feb 02, 2022 4:23:37 PM io.vertx.ext.web.RoutingContext
WARNING: BodyHandler in not enabled on this route: RoutingContext.getBodyAsJson() in always be NULL
Feb 02, 2022 4:23:37 PM io.vertx.ext.web.RoutingContext
SEVERE: Unhandled exception in router
java.lang.NullPointerException
	at com.unisys.nonblocking.http.web.RouterVerticle.lambda$start$2(RouterVerticle.java:45)

From the client side we send "json" , json is simple text format, but vertx deals Object

POST /api/greet
{
  "message" : "How are you?"

}

Solution:
    //which enables parsers -  json-  JsonObject

router.route().handler(BodyHandler.create());


router.post("/api/greet").handler(ctx -> {
      HttpServerResponse serverResponse = ctx.response();
      //reading data:
      JsonObject payload = ctx.getBodyAsJson();
      System.out.println(payload.encodePrettily());

      serverResponse.setStatusCode(200);
      serverResponse.putHeader("content-type", "application/json");
      JsonObject greet = new JsonObject().put("message", "Hai -POST");
      serverResponse.end(greet.encodePrettily());
    });
..............................................................................................
package com.unisys.nonblocking.http.web;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerResponse;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.handler.BodyHandler;

public class RouterVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(RouterVerticle.class);
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    HttpServer server = vertx.createHttpServer();
    //Router creation
    Router router = Router.router(vertx);
    //which enables parsers -  json-  JsonObject
    router.route().handler(BodyHandler.create());

    //new Route
    router.get("/api/hello").handler(ctx -> {
      System.out.println("hello");
      HttpServerResponse serverResponse = ctx.response();
      serverResponse.setStatusCode(200);
      serverResponse.putHeader("content-type", "application/json");
      JsonObject greet = new JsonObject().put("message", "Hello");
      serverResponse.end(greet.encodePrettily());
    });
    router.get("/api/hai").handler(ctx -> {
      System.out.println("hai");
      HttpServerResponse serverResponse = ctx.response();
      serverResponse.setStatusCode(200);
      serverResponse.putHeader("content-type", "application/json");
      JsonObject greet = new JsonObject().put("message", "Hai");
      serverResponse.end(greet.encodePrettily());
    });
    router.post("/api/greet").handler(ctx -> {
      HttpServerResponse serverResponse = ctx.response();
      //reading data:
      JsonObject payload = ctx.getBodyAsJson();
      System.out.println(payload.encodePrettily());

      serverResponse.setStatusCode(200);
      serverResponse.putHeader("content-type", "application/json");
      JsonObject greet = new JsonObject().put("message", "Hai -POST");
      serverResponse.end(greet.encodePrettily());
    });
//path Parameters: dynamic url  /api/hello/subramanian | Ram | John
    router.get("/api/hello/:whom").handler(ctx -> {
      HttpServerResponse serverResponse = ctx.response();
      //using request object extract path parameters
      String whom = ctx.pathParam("whom");
      serverResponse.setStatusCode(200);
      serverResponse.putHeader("content-type", "application/json");
      JsonObject greet = new JsonObject().put("message", "greet " + whom);
      serverResponse.end(greet.encodePrettily());
    });


    server.requestHandler(router);
    server.listen(8080);

  }
}
.............................................................................................
				 Query Parameters

.............................................................................................

URL :
http://localhost:8080/api/good?message=eve

   router.get("/api/good").handler(ctx -> {
      List<String> message = ctx.queryParam("message");
      System.out.println(message.size());
      ctx.response().end("good " + message.get(0));
    });

..............................................................................................
				Resource Oriented Routers


Domain Models:

/api/users
   list
   save
   update
   remove

/api/products
  list
  save
  update
  

What if i have more resources and more routes?

ProductRouter - /api/products
UserRouter -  /api/users
Payment Router - /api/payment

server.requestHandler(?);

SubRouters and Main routers

- you can have more subrouters - prodct,user,payment..
-  you can have only one main /app router -  approuter
- that app router only can passed to requestHandler(appRouter).

How to bind /connect app router with subrouter

Router has method called "mountSubRouter"

package com.unisys.nonblocking.http.web;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.RoutingContext;
import io.vertx.ext.web.handler.BodyHandler;

public class ResourceRouters extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(ResourceRouters.class);
  }

  private static void list(RoutingContext ctx) {
    ctx.response().end("Users");
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    //SubRouters
    Router userRouter = Router.router(vertx);
    Router productsRouter = Router.router(vertx);
    Router customerRouter = Router.router(vertx);
    //Main/app router
    Router appRouter = Router.router(vertx);
    //initialize global Parser
    appRouter.route().handler(BodyHandler.create());
    userRouter.get("/list").handler(UserRouter::list);
    userRouter.post("/create").handler(UserRouter::create);
    productsRouter.get("/list").handler(ProductsRouter::list);
    customerRouter.get("/list").handler(CustomersRouter::list);

    //Mount/Bind appRouter with subRouters
    appRouter.mountSubRouter("/api/users", userRouter);
    appRouter.mountSubRouter("/api/products", productsRouter);
    appRouter.mountSubRouter("/api/customers", customerRouter);

    vertx.createHttpServer().requestHandler(appRouter).listen(8080, handler -> {
      if (handler.succeeded()) {
        System.out.println("Webserver is running at " + handler.result().actualPort());
      }
    });


  }

  //inner class
  private static class UserRouter {
    public static void create(RoutingContext ctx) {
      JsonObject user = ctx.getBodyAsJson();
      System.out.println(user.encodePrettily());
      ctx.response().setStatusCode(201).end("User saved");
    }

    public static void list(RoutingContext ctx) {
      ctx.response().setStatusCode(200).end("User list");
    }
  }

  private static class ProductsRouter {
    public static void create(RoutingContext ctx) {
      JsonObject user = ctx.getBodyAsJson();
      System.out.println(user.encodePrettily());
      ctx.response().setStatusCode(201).end("Product saved");
    }

    public static void list(RoutingContext ctx) {
      ctx.response().setStatusCode(200).end("Product list");
    }
  }

  private static class CustomersRouter {
    public static void create(RoutingContext ctx) {
      JsonObject user = ctx.getBodyAsJson();
      System.out.println(user.encodePrettily());
      ctx.response().setStatusCode(201).end("Customers saved");
    }

    public static void list(RoutingContext ctx) {
      ctx.response().setStatusCode(200).end("Customers list");
    }
  }
}
............................................................................................
				Exception Handling
.............................................................................................

If something went wrong how to handle exception and how to send error messages to clients.

router.failureHandler(fRctx->{
  //extract error information
  send error data to client
})

package com.unisys.nonblocking.http.web;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;
import io.vertx.ext.web.Router;

public class WebExceptionVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(WebExceptionVerticle.class);
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    Router userRouter = Router.router(vertx);
    Router appRouter = Router.router(vertx);
    appRouter.mountSubRouter("/api/users", userRouter);

    userRouter.get("/list/:name").handler(ctx -> {
      String name = ctx.pathParam("name");
      if (name.equals("admin")) {
        ctx.response().setStatusCode(200).end("You are valid User");
      } else {
        throw new RuntimeException("You are Invalid User!!!!");
      }
    }).failureHandler(fctx -> {
      int statuCode = fctx.statusCode();
      String message = fctx.failure().getMessage();
      JsonObject jsonObject = new JsonObject().put("code", 100).put("message", message);
      fctx.response().setStatusCode(statuCode).end(jsonObject.encodePrettily());
    });

    vertx.createHttpServer().requestHandler(appRouter).listen(8080, handler -> {
      if (handler.succeeded()) {
        System.out.println("Webserver is running at " + handler.result().actualPort());
      }
    });
  }
}

.............................................................................................

Handlers Type:

router.handler() -  async request handler
router.failureHandler() - async exception/error handler.

Global Handlers:
BodyHandler - converts "json string" into JsonObject
TimeoutHandler - to set Request timeout for given url or global
blockingHandler - For writing blocking code.

.............................................................................................
				Content Negoation
............................................................................................
Rest api can accept and return multiple data formats based on Request from the client.

One Single Rest api can serve data in multiple formats such as  xml,html,pdf,json,text...

package com.unisys.nonblocking.http.web;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.handler.ResponseContentTypeHandler;

public class ContentNegoation extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(ContentNegoation.class);
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    Router userRouter = Router.router(vertx);
    Router appRouter = Router.router(vertx);

    //adding header automatically into response
    appRouter.route().handler(ResponseContentTypeHandler.create());

    appRouter.mountSubRouter("/api/users", userRouter);

    userRouter.get("/")
      .produces("application/json")
      .handler(ctx -> {
        System.out.println(ctx.getAcceptableContentType());
//        if (ctx.getAcceptableContentType().equals("text/plain")) {
//          ctx.response().end("Text content");
//        } else {
//          ctx.response().end(new JsonObject().put("content", "json").encodePrettily());
//        }
        ctx.response().end(new JsonObject().put("content", "json").encodePrettily());
      });

    vertx.createHttpServer().requestHandler(appRouter).listen(8080, handler -> {
      if (handler.succeeded()) {
        System.out.println("Webserver is running at " + handler.result().actualPort());
      }
    });
  }
}
..............................................................................................
				 Verticle(Object) Communications
.............................................................................................

Object Communication Patterns:
=>With in Process(Within JVM) (WithIn Vertx Engine)
=>Across process(Across JVM) (Across Vertx Engine)

With in Process(Within JVM) (WithIn Vertx Engine):

In General java objects talk each other by calling methods on each other.

class OrderController {
   OrderService service
   
  placeOrder(){
    this.service.processOrder()
  }
}

class OrderService{

  processOrder(){
   return 'order data'
 }
}

Vertx:
class OrderPlacerVerticle extends AbstractVerticle {
       
}
               ||
class OrderProviderVerticle extends AbstractVerticle {

}

In Vertx verticles communicate by default "Async /in non blocking".

Verticles Communication Styles:

1.Actor Model Communication Style
  https://doc.akka.io/docs/akka/current/typed/guide/actors-intro.html
2.HTTP communication Style.

Vertx uses loosly coupled communcation style using "Event Bus"  - which is implemenation  of actor like model.


1.message oriented style :Event Bus

Event Bus:

-Event Bus is nerve of vertx systems.

-Vertx By default is distributed

-Vertx carries distributed architecture by default

-In Vertx Verticles can communicate via Centraized Broker which is built in called event Bus.
-Event Bus uses tcp transport layer by default
-EventBus can send and recive data in the form of json and buffer


Event Bus:

1.Event Bus can allow verticles sends data from one place to another place
2.Event Bus forms a distributed peer-to-peer messaging system spannining multiple server nodes   and multiple browers.
3.Event bus allows sending messages in three ways
  1.pub/sub : one to many
  2.point-to-point : one to one
  3.request-reply(reponse) - one to one with acknowlegement.

4.Event bus identifies clients via "addressing"
   Messages are sent on the event bus to an "address"
   Address schemes can be any naming convention, recommendation is dns model "in.news.covid"
   
5.Handlers
   Since vertx is non blocking, messages are processed by handlers.
   You have to register a handler at an address

6.Type of Data
   Data type of message could be any primitive-int,char,boolean,String, Buffer,JSON

   Per Vertx Engine only One Event Bus-singleTon
............................................................................................


How to get Event Bus Object?

EventBus mybus =  vertx.eventBus();

starting send message

mybus.send
mybus.publish
mybus.request
..............................................................................................
				   PUB - SUB
..............................................................................................
package com.unisys.verticle.communication;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.eventbus.EventBus;
import io.vertx.core.eventbus.MessageConsumer;
import io.vertx.example.util.Runner;
import io.vertx.ext.web.Router;

class Address {
  public final static String PUB_SUB_ADDRESS = "news.in.covid";
  public final static String POINT_TO_POINT = "covid.fin.request";
  public final static String REQUEST_REPLY = "covid.lab.report";
}

//http verticle
class CovidCommunicatorVerticle extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    Router appRouter = Router.router(vertx);
    Router broadcastRouter = Router.router(vertx);
    appRouter.mountSubRouter("/api/brodcast", broadcastRouter);
    broadcastRouter.get("/:message").handler(ctx -> {
      //Event Bus to send message to other Verticles
      String message = ctx.pathParam("message");
      EventBus eventBus = vertx.eventBus();
      eventBus.publish(Address.PUB_SUB_ADDRESS, message);
      ctx.response().end("Message has Broad casted");
    });
    vertx.createHttpServer().requestHandler(appRouter).listen(8080, handler -> {
      if (handler.succeeded()) {
        System.out.println("Event Bus Web Server is running at " + handler.result().actualPort());
      }
    });

  }
}

//PUB - SUB Listener
class NewsSevenVerticle extends AbstractVerticle {
  public void consume() {
    //Get the Reference of Event Bus
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> consumer = eventBus.consumer(Address.PUB_SUB_ADDRESS);
    //process the message
    consumer.handler(msg -> {
      System.out.println(this.getClass().getSimpleName() + " => " + msg.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}

class BBCVerticle extends AbstractVerticle {
  public void consume() {
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.PUB_SUB_ADDRESS);
    messageConsumer.handler(message -> {
      System.out.println(this.getClass().getSimpleName() + " => " + message.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}

class NDTVVerticle extends AbstractVerticle {
  public void consume() {
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.PUB_SUB_ADDRESS);
    messageConsumer.handler(message -> {
      System.out.println(this.getClass().getSimpleName() + " => " + message.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}

public class EventBusMainVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(EventBusMainVerticle.class);
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    vertx.deployVerticle(new CovidCommunicatorVerticle());
    vertx.deployVerticle(new NewsSevenVerticle());
    vertx.deployVerticle(new BBCVerticle());
    vertx.deployVerticle(new NDTVVerticle());
  }
}
.............................................................................................
			Point to Point : one to one Communication
............................................................................................
package com.unisys.verticle.communication;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.eventbus.EventBus;
import io.vertx.core.eventbus.MessageConsumer;
import io.vertx.example.util.Runner;
import io.vertx.ext.web.Router;

class Address {
  public final static String PUB_SUB_ADDRESS = "news.in.covid";
  public final static String POINT_TO_POINT = "covid.fin.request";
  public final static String REQUEST_REPLY = "covid.lab.report";
}

///////////////////////////////////////PUB-SUB//////////////////////////////////////////////////////////
class CovidCommunicatorVerticle extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    Router appRouter = Router.router(vertx);
    //pub-sub
    Router broadcastRouter = Router.router(vertx);
    //point to point
    Router pointToPointRouter = Router.router(vertx);

    //Request-Reply
    Router requestReplyRouter = Router.router(vertx);


    appRouter.mountSubRouter("/api/brodcast", broadcastRouter);
    appRouter.mountSubRouter("/api/requestfin", pointToPointRouter);
    appRouter.mountSubRouter("/api/status", requestReplyRouter);


    broadcastRouter.get("/:message").handler(ctx -> {
      //Event Bus to send message to other Verticles
      String message = ctx.pathParam("message");
      EventBus eventBus = vertx.eventBus();
      //publish - one to many
      eventBus.publish(Address.PUB_SUB_ADDRESS, message);
      ctx.response().end("Message has Broad casted");
    });

    pointToPointRouter.get("/:howmuch").handler(ctx -> {
      //Event Bus to send message to other Verticles
      String message = ctx.pathParam("howmuch");
      EventBus eventBus = vertx.eventBus();
      //send - one to one
      eventBus.send(Address.POINT_TO_POINT, message);
      ctx.response().end("Message has been sent");
    });

    requestReplyRouter.get("/:name").handler(ctx -> {
      //Event Bus to send message to other Verticles
      String name = ctx.pathParam("name");
      String messageToSend = "Report of " + name;
      //send message and get reply : request-reply with ack
      vertx.eventBus().request(Address.REQUEST_REPLY, messageToSend, asyncResult -> {
        if (asyncResult.succeeded()) {
          System.out.println(asyncResult.result().body());
          ctx.response().end(asyncResult.result().body().toString());
        } else {
          System.out.println(asyncResult.cause());
        }
      });

    });
    vertx.createHttpServer().requestHandler(appRouter).listen(8080, handler -> {
      if (handler.succeeded()) {
        System.out.println("Event Bus Web Server is running at " + handler.result().actualPort());
      }
    });

  }
}

//PUB - SUB Listener
class NewsSevenVerticle extends AbstractVerticle {
  public void consume() {
    //Get the Reference of Event Bus
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> consumer = eventBus.consumer(Address.PUB_SUB_ADDRESS);
    //process the message
    consumer.handler(msg -> {
      System.out.println(this.getClass().getSimpleName() + " => " + msg.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}

class BBCVerticle extends AbstractVerticle {
  public void consume() {
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.PUB_SUB_ADDRESS);
    messageConsumer.handler(message -> {
      System.out.println(this.getClass().getSimpleName() + " => " + message.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}

class NDTVVerticle extends AbstractVerticle {
  public void consume() {
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.PUB_SUB_ADDRESS);
    messageConsumer.handler(message -> {
      System.out.println(this.getClass().getSimpleName() + " => " + message.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}
///////////////////////////////////////PUB-SUB//////////////////////////////////////////////////////////

///////////////////////////////////////POINT TO POINT//////////////////////////////////////////////////////////

class CenertalFinanceVerticle extends AbstractVerticle {

  public void consume() {
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.POINT_TO_POINT);
    //handle /process the message/news
    messageConsumer.handler(news -> {
      System.out.println("Request 1 -  : " + news.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}

///////////Request-Reply///////////////////////////////////////////////////////////////////////
class LabVerticle extends AbstractVerticle {
  public void consume() {
    EventBus eventBus = vertx.eventBus();
    //pub-sub
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.REQUEST_REPLY);
    //handle /process the message/news
    messageConsumer.handler(news -> {
      System.out.println("Request -  : " + news.body());
      //sending reply /ack
      news.reply(news.body() + " who  is Critical , Need More attention");
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}


public class EventBusMainVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(EventBusMainVerticle.class);
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    vertx.deployVerticle(new CovidCommunicatorVerticle());
    /////pub-sub
    vertx.deployVerticle(new NewsSevenVerticle());
    vertx.deployVerticle(new BBCVerticle());
    vertx.deployVerticle(new NDTVVerticle());
    //point to point
    vertx.deployVerticle(new CenertalFinanceVerticle());
    //request-reply
    vertx.deployVerticle(new LabVerticle());

  }
}
..............................................................................................					Request---Reply
package com.unisys.verticle.communication;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.eventbus.EventBus;
import io.vertx.core.eventbus.MessageConsumer;
import io.vertx.example.util.Runner;
import io.vertx.ext.web.Router;

class Address {
  public final static String PUB_SUB_ADDRESS = "news.in.covid";
  public final static String POINT_TO_POINT = "covid.fin.request";
  public final static String REQUEST_REPLY = "covid.lab.report";
}

///////////////////////////////////////PUB-SUB//////////////////////////////////////////////////////////
class CovidCommunicatorVerticle extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    Router appRouter = Router.router(vertx);
    //pub-sub
    Router broadcastRouter = Router.router(vertx);
    //point to point
    Router pointToPointRouter = Router.router(vertx);

    //Request-Reply
    Router requestReplyRouter = Router.router(vertx);


    appRouter.mountSubRouter("/api/brodcast", broadcastRouter);
    appRouter.mountSubRouter("/api/requestfin", pointToPointRouter);
    appRouter.mountSubRouter("/api/status", requestReplyRouter);


    broadcastRouter.get("/:message").handler(ctx -> {
      //Event Bus to send message to other Verticles
      String message = ctx.pathParam("message");
      EventBus eventBus = vertx.eventBus();
      //publish - one to many
      eventBus.publish(Address.PUB_SUB_ADDRESS, message);
      ctx.response().end("Message has Broad casted");
    });

    pointToPointRouter.get("/:howmuch").handler(ctx -> {
      //Event Bus to send message to other Verticles
      String message = ctx.pathParam("howmuch");
      EventBus eventBus = vertx.eventBus();
      //send - one to one
      eventBus.send(Address.POINT_TO_POINT, message);
      ctx.response().end("Message has been sent");
    });

    requestReplyRouter.get("/:name").handler(ctx -> {
      //Event Bus to send message to other Verticles
      String name = ctx.pathParam("name");
      String messageToSend = "Report of " + name;
      //send message and get reply : request-reply with ack
      vertx.eventBus().request(Address.REQUEST_REPLY, messageToSend, asyncResult -> {
        if (asyncResult.succeeded()) {
          System.out.println(asyncResult.result().body());
          ctx.response().end(asyncResult.result().body().toString());
        } else {
          System.out.println(asyncResult.cause());
        }
      });

    });
    vertx.createHttpServer().requestHandler(appRouter).listen(8080, handler -> {
      if (handler.succeeded()) {
        System.out.println("Event Bus Web Server is running at " + handler.result().actualPort());
      }
    });

  }
}

//PUB - SUB Listener
class NewsSevenVerticle extends AbstractVerticle {
  public void consume() {
    //Get the Reference of Event Bus
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> consumer = eventBus.consumer(Address.PUB_SUB_ADDRESS);
    //process the message
    consumer.handler(msg -> {
      System.out.println(this.getClass().getSimpleName() + " => " + msg.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}

class BBCVerticle extends AbstractVerticle {
  public void consume() {
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.PUB_SUB_ADDRESS);
    messageConsumer.handler(message -> {
      System.out.println(this.getClass().getSimpleName() + " => " + message.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}

class NDTVVerticle extends AbstractVerticle {
  public void consume() {
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.PUB_SUB_ADDRESS);
    messageConsumer.handler(message -> {
      System.out.println(this.getClass().getSimpleName() + " => " + message.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}
///////////////////////////////////////PUB-SUB//////////////////////////////////////////////////////////

///////////////////////////////////////POINT TO POINT//////////////////////////////////////////////////////////

class CenertalFinanceVerticle extends AbstractVerticle {

  public void consume() {
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.POINT_TO_POINT);
    //handle /process the message/news
    messageConsumer.handler(news -> {
      System.out.println("Request 1 -  : " + news.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}

///////////Request-Reply///////////////////////////////////////////////////////////////////////
class LabVerticle extends AbstractVerticle {
  public void consume() {
    EventBus eventBus = vertx.eventBus();
    //pub-sub
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.REQUEST_REPLY);
    //handle /process the message/news
    messageConsumer.handler(news -> {
      System.out.println("Request -  : " + news.body());
      //sending reply /ack
      news.reply(news.body() + " who  is Critical , Need More attention");
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}


public class EventBusMainVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(EventBusMainVerticle.class);
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    vertx.deployVerticle(new CovidCommunicatorVerticle());
    /////pub-sub
    vertx.deployVerticle(new NewsSevenVerticle());
    vertx.deployVerticle(new BBCVerticle());
    vertx.deployVerticle(new NDTVVerticle());
    //point to point
    vertx.deployVerticle(new CenertalFinanceVerticle());
    //request-reply
    vertx.deployVerticle(new LabVerticle());

  }
}
............................................................................................
	HTTP communication - Web Clients-Sending and receving messages via http protocal
............................................................................................





























































































