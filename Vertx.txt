					Vertx
..............................................................................................File Descriptor:

-It is data structure(array) which is available in the kernal- having key -value pairs 
 It stores the information about io devices.

-It is created for every process - Per Process 

File Descriptor maps io devices with The application Progams

lets say i have java program runs on jvm.

When ever jvm starts , file descriptor is created and kept for io interaction.

File Descriptor contains two fields
 ------------------------------------
 File Descriptor Entries           File Pointer Reference
     0                                 STDIN    -KEYBOARD Binding
     1                                 STDOUT   -Monitor Binding
     2                                 STDERROR -Monitor Binding
     3                                  ?
     4                                  ?


The first three enteries are created when process bootstraps.

Lets take an eg : i want to read data from the disk file?.

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class CopyBytes {
    public static void main(String[] args) throws IOException {

        FileInputStream in = null;
        FileOutputStream out = null;

        try {
            in = new FileInputStream("xanadu.txt");
            out = new FileOutputStream("outagain.txt");
            int c;

            while ((c = in.read()) != -1) {
                out.write(c);
            }
        } finally {
            if (in != null) {
                in.close();
            }
            if (out != null) {
                out.close();
            }
        }
    }
}

In this program, when application calls "in.read()"
    ----------------->JVM invokes system call(api written in c language)------|os keneral
                      -->It will add an entry into file descriptor table and binds the disk file location
 
  
File Descriptor contains two fields
 ------------------------------------
 File Descriptor Entries           File Pointer Reference
     0                                 STDIN    -KEYBOARD Binding
     1                                 STDOUT   -Monitor Binding
     2                                 STDERROR -Monitor Binding
     3                                 HD------------->bINDING HARDDRIVE
     4                                 NETWORK -----|NEC BINDING
.............................................................................................
				Multi threading and IO Models
............................................................................................

Every modern process(JVM) is multi threaded.
Each thread can be created and assigned for an io operations : concurrent io /parrell io.
Every thread is blocked/freezed until data is ready from io channels.

Based this idea only web servers were designed : Multi threading and io.

In web , there is programming model request(read)-response(write)(Network IO) model

Client--------------------IO Channel------------------------Server

Server Design:
..............

Every Web server is multi threaded -tomcat.

When ever a new request(io request) is arrived, Tomcat(Server) creates/assigns "a thread"
............................................................................................
C10K Problem:
.............
The C10k problem is the problem of optimizing network sockets to handle a large number of clients at the same time.

 1000 REQ = 1000 Threads - This is Problem

 More Req ==Minimum number of Threads

Why? What is problem of Threading:

if i create thread
 -memory allocation 
 -managing life cycle of threads

if thread is created , requests kernal for data, if the data not ready.

if data is not ready during that time thread is waiting(blocking)/blocked 
lets say , thread has created it is waiting for 1ms for data. this 1ms during that thread is useless, can be used by any one.

The cpu, will pause the unused thread for 1ms, if data is ready again it will activate-This process is called context switch.
.............................................................................................
				How to build efficient network io apps
.............................................................................................

Before 2000, all programming languages used blocking io apis by default,even today all programming langugages blocking io apis.

C10K problem and its solution:

Every os has blocking api only.

After 2000, First,Linux introduced a new api called non blocking io api - "select"

1st Implementation:

 select  + read 

select will add entry , returns control back to process
read will be fired to read data once it is ready in the keneral
............................................................................................

2nd Implementation:

Poll:
.....

Poll is similar to Select -nonblocking,but data is reterived not by calling extra method(read).
Polling is nothing pushing- Data is pushed from the kernal to Application process

select is Pull based - Data is pulled from the kernal.

Even driven Programming , Event driven io. when ever data is ready, poll will start sending signal(event) to application Process, where application process listens for events, once event is given which starts processing that event.

...........................................................................................

3rd Implmentation:

epoll:

->epoll is a framework extended from poll.
->monitoring multiple file descriptors to see if I/O is possible on any of   them. 


Epoll loop:
           for (;;) {
               nfds = epoll_wait(epollfd, events, MAX_EVENTS, -1);
               if (nfds == -1) {
                   perror("epoll_wait");
                   exit(EXIT_FAILURE);
               }

               for (n = 0; n < nfds; ++n) {
                   if (events[n].data.fd == listen_sock) {
                       conn_sock = accept(listen_sock,
                                          (struct sockaddr *) &addr, &addrlen);
                       if (conn_sock == -1) {
                           perror("accept");
                           exit(EXIT_FAILURE);
                       }
                       setnonblocking(conn_sock);
                       ev.events = EPOLLIN | EPOLLET;
                       ev.data.fd = conn_sock;
                       if (epoll_ctl(epollfd, EPOLL_CTL_ADD, conn_sock,
                                   &ev) == -1) {
                           perror("epoll_ctl: conn_sock");
                           exit(EXIT_FAILURE);
                       }
                   } else {
                       do_use_fd(events[n].data.fd);
                   }
               }


Epoll runs a loop indefintly for io operations(network io), when ever data is ready which emits event to the process.

When operating systems supports non blocking infrastructure, language and runtimes should support that
The first non blocking implemention was nginx web server - the first c10k solution

flollwed by nginx "2008" -  Node.js- Non blocking soultion.
..............................................................................................
.............................................................................................
				Vertx Inspired from Node.js
............................................................................................

In node there is only one event loop thread, who process events from kernal.

Vertx added more threads to process events.

Vertx implements c10K problem solution on JVM
   -Limited threads but max concurrency
   -Non blocking io apis 

Vertx by default maintains threads based Number of cup cores

i have 12 core, each core -2 threads
 
 12*2 = 24 threads

                   24 threads now can handle XXXX no  Requests
...........................................................................................
...........................................................................................
			   Vertx Core Concepts
		Vertx helps to build 100% scalable non blocking + reactive applications
..............................................................................................

Reactive - Data Streaming
Nonblocking/Async -  Thread Management and processing events
..............................................................................................

Lets Code:

1.Vertx Instance -Vertx Engine
2.Verticals 
3.Event Bus
..............................................&&&&&&&&&&&&&&&&&.............................

How to setup vertx project

vertx supports

1.maven
2.gradle

project can be simple 

1.normal java project
2.standard mvn project
3.vertx project from https://start.vertx.io/


How to run Vertx Project?

Vertx application will have entry Point , configured in general pom.xml

<main.verticle>com.unisys.MainVerticle</main.verticle>
<launcher.class>io.vertx.core.Launcher</launcher.class>


mvnw clean compile exec:java

=mvnw clean package -  jar file - fat jar /regular
java -jar target/vertxstarter-1.0.0-SNAPSHOT-fat.jar
.............................................................................................
					Vertx Engine/Runtime
.............................................................................................

Vertx Engine is a java class, represented as interface in the vertx.io.core package.

Role of Vertx Engine:

1.To run vertx app
2.To help to access all non blocking infrastructure
  ->HTTP Webserver
  ->TCP Servers
  ->UDP Servers
  ->FS ACCESS
  ->Object interactions via "Event Bus".
  ->CPU Timer access
  ->App deployment and undeployment
  ->Create Shared data.

Vertx Application Components:
............................

In spring Framework apps are collection of objects called "beans".
In Vertx apps are collection of objects called "Verticles".

What is Verticle?

Verticle:
  -It is java object
  -Where we write all non blocking application logics.
  -It can be deployed and undeployed on vertx instance (engine).
  -It is based on design pattern called "Actor-like Model" - based on akka frameworks
  -Verticles are bound to "Event loop " , are processed by event loop threads.

Deployment means "the action of bringing resources into effective action." - allocating resource for use.

Deployment Resources for a Verticle:

1.Assign/bound a event loop thread to a verticle.

..............................................................................................
How to vertx Program?

Ways 

1. via main method
package com.unisys;

import io.vertx.core.Vertx;

public class HelloWorldVertx {
  public static void main(String[] args) {
    //Vertx Engine Creation
    Vertx vertx = Vertx.vertx();
    System.out.println(vertx);
    System.out.println(Thread.currentThread().getName());
    //create simple non blocking web server
    vertx.createHttpServer().requestHandler(req -> {
      System.out.println(Thread.currentThread().getName());
      req.response().end("Hello Vertx");
    }).listen(8080);

  }
}

2.via lanucher
<main.verticle>com.unisys.MainVerticle</main.verticle>
<launcher.class>io.vertx.core.Launcher</launcher.class>

io.vertx.core.Launcher;

A main() class that can be used to create Vert.x instance and deploy a verticle, or run a bare Vert.x instance.

This class is used by the vertx command line utility to deploy verticles from the command line. It is extensible as "commands" can be added using the CommandFactory SPI.

mvn compile exec:java


3.via vertx command line utility.
  -vertx 4 has removed external command line tools.

vertx

4.via java jar model

-fat jar / uber jar :
  -embeded application
 appcode + server code

mvn clean package
 
java -jar target/starter-vertx-1.0.0-SNAPSHOT-fat.jar
........................................................................................................

Vertx-Modules:
core
web
reactive
microservices
data
messaging
.......................................................................................................		vertx-core:

-Verticles
-Event loop Threads
-Callback based programming
		

Verticle:
  -It is java object
  -It can be deployed and undeployed on vertx instance (engine).
  -It is based on design pattern called "Actor-like Model" - based on akka frameworks
  -Verticles are bound to "Event loop" , are processed by event loop threads.

Verticle is interface which provides life cycle methods 
  -init
  -start - called when verticle during deployment
  -stop  - called when verticles during undeployment
..............................................................................................

Vertx Objective is to build non blocking io apps -  networks,filesystem,data base.

Vertx Programming styles:

1.Without Verticle

public class HelloWorldVertx {
  public static void main(String[] args) {
    //Vertx Engine Creation
    Vertx vertx = Vertx.vertx();
    System.out.println(vertx);
    System.out.println(Thread.currentThread().getName());
    //create simple non blocking web server
    vertx.createHttpServer().requestHandler(req -> {
      System.out.println(Thread.currentThread().getName());
      req.response().end("Hello Vertx");
    }).listen(8080);

  }
}


2.With Verticle
  Use of verticles with Vert.x is entirely optional, but if you use them they provide an  "actor-like deployment and concurrency model", out of the box.

verticle is  class , if you want to create your own verticle, you need to inherit.

import io.vertx.core.AbstractVerticle;

public class GreetingVerticle extends AbstractVerticle {
  
}

Verticle is interface which provides life cycle methods 
  -init
  -start - called when verticle during deployment
  -stop  - called when verticles during undeployment


................................................................................

Deploying Verticles

Via main Method:
import io.vertx.core.Vertx;

public class GreeterDeployerMain {
  public static void main(String[] args) {
    Vertx vertx = Vertx.vertx();
   //deploy the verticle on vertx engine
//    vertx.deployVerticle(new GreetingVerticle());
    vertx.deployVerticle(GreetingVerticle.class.getName());
    vertx.deployVerticle("com.unisys.GreetVerticle");
    vertx.close();
  }
}

via Verticle itself:

One Verticle can deploy other Verticle.

inside verticle vertx reference is available by default.

Vertx vert=Vertx.vertx(); you dont need to write this code

package com.unisys;

import io.vertx.core.AbstractVerticle;

public class GreeterDeployer extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new GreetingVerticle());
  }
}
..............................................................................................

Via Runner Class;
.................
package com.unisys;

import io.vertx.core.AbstractVerticle;
import io.vertx.example.util.Runner;

public class GreeterDeployer extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(GreeterDeployer.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new GreetingVerticle());
  }
}
.............................................................................................
				Vertx Core Concepts
............................................................................................

.............................................................................................
				Non Blocking Applications
..............................................................................................

Patterns for writting non blockings apps

1.callback style -  traditional
2.reactive style -  streaming

Non blocking apis
1.timer
2.http
3.fs

Callback Style

1.Future
2.Promise

Future:
io.vertx.core.Future

Vertx uses futures to reprsent "Asynchronous" Results

Future is like transport object to transport data between caller and callee in async manner.

 Caller----Future--------Callee

What type of data Future can carry.

 - Success---- |
		--- >Future
 - Failure---- |

AsyncResult<T> :
   Object which has either success data or failure data.
   Used in caller side to capture data which was sent by Callee
..............................................................................................

Use case : How to create Future,encasulate success,failure , how to listen for data?

package com.unisys.futures;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.example.util.Runner;

class FutureTransferVerticle extends AbstractVerticle {

  //method which returns future -  callee
  public Future<String> sayHello() {
//    return Future.future(new Handler<Promise<String>>() {
//      @Override
//      public void handle(Promise<String> stringPromise) {
//        stringPromise.complete("Hello");
//      }
//    });
    //We are returning
    return Future.future(future -> future.complete("Hello"));
  }

  //method which throws error
  public Future<String> createErrorMessage() {
    return Future.future(f -> f.fail("Something went wrong!!"));
  }

  //biz logic which may send success or failure data
  public Future<String> login(String username, String password) {
    return Future.future(handler -> {
      if (username.equals("admin") && password.equals("admin")) {
        handler.complete("Login success");
      } else {
        handler.fail("Login Failed");
      }
    });
  }


  @Override
  public void start() throws Exception {
    super.start();
    //caller
//    createFuture().onComplete(new Handler<AsyncResult<String>>() {
//      @Override
//      public void handle(AsyncResult<String> asyncResult) {
//             if(async.succ) {

//             } else {}
//      }
//    });
    sayHello().onComplete(asyncResult -> {
      if (asyncResult.succeeded()) {
        //read data
        System.out.println(asyncResult.result());
      } else {
        System.out.println(asyncResult.cause().getMessage());
      }
    });
    //listen for error
    createErrorMessage().onComplete(asyncResult -> {
      if (asyncResult.failed()) {
        System.out.println(asyncResult.cause());
      }
    });
    //listen for success or failer
    login("admin", "admin").onComplete(asyncResult -> {
      if (asyncResult.failed()) {
        System.out.println(asyncResult.cause());
      }
      System.out.println(asyncResult.result());
    });
    login("xxx", "xxx").onComplete(asyncResult -> {
      if (asyncResult.failed()) {
        System.out.println(asyncResult.cause());
      } else {
        System.out.println(asyncResult.result());
      }
    });
  }
}


public class FutureVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    System.out.println("deploying...");
    Runner.runExample(FutureVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("deploying...");

    vertx.deployVerticle(new FutureTransferVerticle());
  }
}
..............................................................................................
				Listener Short cuts
..............................................................................................

login().onComplete() -  1
   here handler<AsyncResult> is parameter
login().onSuccess()
login().onFailure()
   here direct data -Handler<T> is parameter

  login("admin", "admin")
      .onSuccess(res -> System.out.println(res))
      .onFailure(err -> System.out.println(err));
    login("admin", "admin")
      .onSuccess(System.out::println)
      .onFailure(System.out::println);
.............................................................................................
				Future Object creation types
............................................................................................


Pattern - 1:

Future.future() - factoryMethod
 public Future<String> login(String username, String password) {
    return Future.future(handler -> {
      if (username.equals("admin") && password.equals("admin")) {
        handler.complete("Login success");
      } else {
        handler.fail("Login Failed");
      }
    });
  }

Pattern - 2:

Future.succeedFuture()
Future.failedFuture()
 
  public Future<String> loginV1(String username, String password) {
    if (username.equals("admin") && password.equals("admin")) {
      return Future.succeededFuture("Login is Successful");
    } else {
      return Future.failedFuture("Login failed");
    }
  }
loginV1("admin", "admin")
      .onSuccess(System.out::println)
      .onFailure(System.out::println);


Pattern - 3, Instead of Returning Future, Pass function as parameter - Higher Order function Pattern

  public void loginV2(String userName, String password, Handler<AsyncResult<String>> aHandler) {
    if (userName.equals("admin") && password.equals("admin")) {
      //encapsulate data
      aHandler.handle(Future.succeededFuture("Login is Successful"));
    } else {
      aHandler.handle(Future.failedFuture("Login failed"));
    }
  }

loginV2("admin", "admin", handler -> {
      if (handler.succeeded()) {
        System.out.println(handler.result());
      } else {
        System.out.println(handler.cause());
      }
    });
..............................................................................................
				Callback Chaining
			        Nested Callbacks
.............................................................................................

Legacy Application flow : object oriented and sync flow
  
dependent operations  , should happen one by one

Object oriented seq work flow /Sync work flow

 1.connect db - connect()
 2.Query results -queryResult()
 3.Formate results -formateResult()
 4.add results into http response stream - write()
 5.send/flush the results to clients - send()

 Connection con=DriverManager.getConnection("connectionstring");
 QueryResult queryres=con.queryResult()
 List<T> results = formatResult(queryres)
 response.write(results)
 reponse.end();

...........................................................................................
How the above task can be done in functional programming ; vertx?


Functional sequential workflow:

 Nested Callback : Callback chaining: functional style

  Handler function is called as callback function

"The out put of one callback is input to the another callback : nested callbacks

   cb1
     --cb2
         -cb3
            --cbN
              --process the result.
.............................................................................................


Use case :

 getUser ----|if data is available
			|	|
			|
			      	 call login method with  output of getUser
                        |
		     if not
			 -error

Note : output of one function will be input to another function.
..............................................................................................
package com.unisys.callback;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.example.util.Runner;

//model
class User {
  private String userName;
  private String password;

  public User(String userName, String password) {
    this.userName = userName;
    this.password = password;
  }

  public String getUserName() {
    return userName;
  }

  public void setUserName(String userName) {
    this.userName = userName;
  }

  public String getPassword() {
    return password;
  }

  public void setPassword(String password) {
    this.password = password;
  }

}

class PageVerticle extends AbstractVerticle {

  //chanining

  //api - getUser - return user Details
  //login - which takes input from the getUser
  private Future<String> getUser() {
    User user = new User("admin", "admin");
//    User user = null;
    if (user != null) {
      return Future.succeededFuture(user.getUserName());
    } else {
      return Future.failedFuture("User not Found");
    }
  }

  //login method
  private Future<String> login(String userName) {
    if (userName.equals("admin")) {
      return Future.succeededFuture("Login Success");
    } else {
      return Future.failedFuture("Login failed");
    }
  }

  //page
  private Future<String> showPage(String status) {
    if (status.equals("Login Success")) {
      return Future.succeededFuture("Welcome to Dashboard");
    } else {
      return Future.failedFuture("Please Retry!");
    }

  }

  @Override

  public void start() throws Exception {
    super.start();
    getUser().onComplete(e -> {
      if (e.succeeded()) {
        System.out.println(e.result());
        //call login method
        login(e.result()).onComplete(loginEvent -> {
          if (loginEvent.succeeded()) {
            System.out.println(loginEvent.result());
            showPage(loginEvent.result()).onComplete(pageEvent -> {
              if (pageEvent.succeeded()) {
                System.out.println(pageEvent.result());
              } else {
                System.out.println(pageEvent.cause());
              }
            });
          } else {
            System.out.println(loginEvent.cause());
          }
        });
      } else {
        System.out.println(e.cause());
      }
    });
  }
}


public class CallbackVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(CallbackVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new PageVerticle());
  }
}
..............................................................................................
				Callback Hell
.............................................................................................

getUser().onComplete(e -> {
      if (e.succeeded()) {
        System.out.println(e.result());
        //call login method
        login(e.result()).onComplete(loginEvent -> {
          if (loginEvent.succeeded()) {
            System.out.println(loginEvent.result());
            showPage(loginEvent.result()).onComplete(pageEvent -> {
              if (pageEvent.succeeded()) {
                System.out.println(pageEvent.result());
              } else {
                System.out.println(pageEvent.cause());
              }
            });
          } else {
            System.out.println(loginEvent.cause());
          }
        });
      } else {
        System.out.println(e.cause());
      }
    });

Look at the above code , ask your self

1.is it easy to understand?
2.is it easy to scale
3.is it easy to maintain

No!

This is called callback hell; The callback hell is way of writing complex callbacks.

can we escape from callback hell problem, how to write better callback based programming?

Yes! 
.................

Refactoring callback chaining code.
//How to refactor this above code
    getUser().onSuccess(user -> {
      System.out.println(user);
      login(user).onSuccess(status -> {
        System.out.println(status);
        showPage(status).onSuccess(page -> {
          System.out.println(page);
        }).onFailure(err -> {
          System.out.println(err);
        });
      }).onFailure(err -> {
        System.out.println(err);
      });
    }).onFailure(err -> {
      System.out.println(err);
    });
.............................................................................................
				Callback Hell Soultion :Future.compose Method

.............................................................................................

f1.and(f2)

package com.unisys.callback;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.example.util.Runner;

//model
class User {
  private String userName;
  private String password;

  public User(String userName, String password) {
    this.userName = userName;
    this.password = password;
  }

  public String getUserName() {
    return userName;
  }

  public void setUserName(String userName) {
    this.userName = userName;
  }

  public String getPassword() {
    return password;
  }

  public void setPassword(String password) {
    this.password = password;
  }

}

class PageVerticle extends AbstractVerticle {

  //chanining

  //api - getUser - return user Details
  //login - which takes input from the getUser
  private Future<String> getUser() {
    System.out.println("Get User is called");
    User user = new User("admin", "admin");
//    User user = null;
    if (user != null) {
      return Future.succeededFuture(user.getUserName());
    } else {
      return Future.failedFuture("User not Found");
    }
  }

  //login method
  private Future<String> login(String userName) {
    System.out.println("login is called");

    if (userName.equals("admin")) {
      return Future.succeededFuture("Login Success");
    } else {
      return Future.failedFuture("Login failed");
    }
  }

  //page
  private Future<String> showPage(String status) {
    System.out.println("ShowPage is called");

    if (status.equals("Login Success")) {
      return Future.succeededFuture("Welcome to Dashboard");
    } else {
      return Future.failedFuture("Please Retry!");
    }

  }

  @Override

  public void start() throws Exception {
    super.start();
//    getUser().onComplete(e -> {
//      if (e.succeeded()) {
//        System.out.println(e.result());
//        //call login method
//        login(e.result()).onComplete(loginEvent -> {
//          if (loginEvent.succeeded()) {
//            System.out.println(loginEvent.result());
//            showPage(loginEvent.result()).onComplete(pageEvent -> {
//              if (pageEvent.succeeded()) {
//                System.out.println(pageEvent.result());
//              } else {
//                System.out.println(pageEvent.cause());
//              }
//            });
//          } else {
//            System.out.println(loginEvent.cause());
//          }
//        });
//      } else {
//        System.out.println(e.cause());
//      }
//    });
//    //How to refactor this above code
//    getUser().onSuccess(user -> {
//      System.out.println(user);
//      login(user).onSuccess(status -> {
//        System.out.println(status);
//        showPage(status).onSuccess(page -> {
//          System.out.println(page);
//        }).onFailure(err -> {
//          System.out.println(err);
//        });
//      }).onFailure(err -> {
//        System.out.println(err);
//      });
//    }).onFailure(err -> {
//      System.out.println(err);
//    });

    //compose method
    System.out.println("Using compose Method");
//    getUser().compose(user -> {
//        System.out.println("Get user is called");
//        return login(user); //Return Future
//      }).compose(status -> {
//        System.out.println("Login is called");
//        return showPage(status);
//      })
//      .onSuccess(s -> {
//        System.out.println("Show page is called");
//        System.out.println(s);
//      }).onFailure(err -> {
//        System.out.println(err);
//      });
    getUser()
      .compose(user -> login(user))
      .compose(status -> showPage(status))
      .onSuccess(s -> {
        System.out.println(s);
      }).onFailure(err -> {
        System.out.println(err);
      });
    getUser()
      .compose(this::login)
      .compose(this::showPage)
      .onSuccess(System.out::println)
      .onFailure(System.out::println);
  }
}


public class CallbackVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(CallbackVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new PageVerticle());
  }
}

..........................................................................................
				Compose Eg
package com.unisys.callback;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.example.util.Runner;

//model
class User {
  private String userName;
  private String password;

  public User(String userName, String password) {
    this.userName = userName;
    this.password = password;
  }

  public String getUserName() {
    return userName;
  }

  public void setUserName(String userName) {
    this.userName = userName;
  }

  public String getPassword() {
    return password;
  }

  public void setPassword(String password) {
    this.password = password;
  }

}

class PageVerticle extends AbstractVerticle {

  //chanining

  //api - getUser - return user Details
  //login - which takes input from the getUser
  private Future<String> getUser() {
    System.out.println("Get User is called");
    User user = new User("admin", "admin");
//    User user = null;
    if (user != null) {
      return Future.succeededFuture(user.getUserName());
    } else {
      return Future.failedFuture("User not Found");
    }
  }

  //login method
  private Future<String> login(String userName) {
    System.out.println("login is called");

    if (userName.equals("admin")) {
      return Future.succeededFuture("Login Success");
    } else {
      return Future.failedFuture("Login failed");
    }
  }

  //page
  private Future<String> showPage(String status) {
    System.out.println("ShowPage is called");

    if (status.equals("Login Success")) {
      return Future.succeededFuture("Welcome to Dashboard");
    } else {
      return Future.failedFuture("Please Retry!");
    }

  }

  @Override

  public void start() throws Exception {
    super.start();
//    getUser().onComplete(e -> {
//      if (e.succeeded()) {
//        System.out.println(e.result());
//        //call login method
//        login(e.result()).onComplete(loginEvent -> {
//          if (loginEvent.succeeded()) {
//            System.out.println(loginEvent.result());
//            showPage(loginEvent.result()).onComplete(pageEvent -> {
//              if (pageEvent.succeeded()) {
//                System.out.println(pageEvent.result());
//              } else {
//                System.out.println(pageEvent.cause());
//              }
//            });
//          } else {
//            System.out.println(loginEvent.cause());
//          }
//        });
//      } else {
//        System.out.println(e.cause());
//      }
//    });
//    //How to refactor this above code
//    getUser().onSuccess(user -> {
//      System.out.println(user);
//      login(user).onSuccess(status -> {
//        System.out.println(status);
//        showPage(status).onSuccess(page -> {
//          System.out.println(page);
//        }).onFailure(err -> {
//          System.out.println(err);
//        });
//      }).onFailure(err -> {
//        System.out.println(err);
//      });
//    }).onFailure(err -> {
//      System.out.println(err);
//    });

    //compose method
    System.out.println("Using compose Method");
//    getUser().compose(user -> {
//        System.out.println("Get user is called");
//        return login(user); //Return Future
//      }).compose(status -> {
//        System.out.println("Login is called");
//        return showPage(status);
//      })
//      .onSuccess(s -> {
//        System.out.println("Show page is called");
//        System.out.println(s);
//      }).onFailure(err -> {
//        System.out.println(err);
//      });
    // "hello".trim().toUpperCase()
    //Future.compose().compose().onSuccess().OnFailure
    getUser()
      .compose(user -> login(user))
      .compose(status -> showPage(status))
      .onSuccess(s -> {
        System.out.println(s);
      }).onFailure(err -> {
        System.out.println(err);
      });
    getUser()
      .compose(this::login)
      .compose(this::showPage)
      .onSuccess(System.out::println)
      .onFailure(System.out::println);
  }
}


public class CallbackVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(CallbackVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new PageVerticle());
  }
}
..............................................................................................
			   .............................................................................................
				Advanced Composition :CompositFuture
.............................................................................................
		
i have three methods

-startDbServer
-startHttpServer
-startConfigServer

After success of all methods only i have to initalize my app, if any one of the server failed
i have to throw error and stop .

Future Coordination:
 Coordination of mutliple futures can be achieved with Vertx futures.

Supports concurrent composition(run serveral async operations in paralle) and sequential composition -chain async operations.

CompositeFuture.all(f1,f2,f3,f4,f5,f6)

-all composition waits until all futures are successful or any one fails.

CompositeFuture.any(f1,f2,f3,f4,f5,f6)
    any composition waits for the succeeded future.

package com.cts.vertx.future;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.CompositeFuture;
import io.vertx.core.Future;
import io.vertx.example.util.Runner;

public class CompositFutureVerticle extends AbstractVerticle {

  public static void main(String[] args) {
    Runner.runExample(CompositFutureVerticle.class);
  }

  public Future<String> startDbServer() {
    System.out.println("Db Server Started");
    return Future.succeededFuture("Db server is up");
  }

  public Future<String> startWebServer() {
    System.out.println("WebServer Server Started");
    //  return Future.succeededFuture("Web server is up");
    return Future.failedFuture("Port is already In Use");
  }

  public Future<String> startConfigServer() {
    System.out.println("Config Server Started");
    return Future.succeededFuture("Config Server is up");
  }

  @Override
  public void start() throws Exception {
    super.start();

    Future<String> dbServer = startDbServer();
    Future<String> webServer = startWebServer();
    Future<String> configServer = startConfigServer();
    //coordinate all servers; make sure every server is ready.
    CompositeFuture.all(dbServer, webServer, configServer).onComplete(ar -> {
      if (ar.succeeded()) {
        System.out.println("All Server is Up");
      } else {
        System.out.println(ar.cause());
      }
    });

  }
}
..............................................................................................
Promises:

Async Wrapper Object : Promise:
...............................

Promise is async abstraction largly promoted by javascript community.

Dont Compare  javascript Promises with Vertx Promises , because both are different.

Promise is "semantically meaningfull abstraction" for handling async results.

Many times developers confuse with java Future and Vertx Future.

Promises can't be processed directly with onComplete/setHandler/OnSuccecc/onFailure apis.

Promises must be converted into Future before processing.


Promise:

package com.unisys.promises;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.example.util.Runner;

class LoginVerticle extends AbstractVerticle {

  //Return Promise, later convert into Future if you want, or any api dirctly uses promises
  public Promise<String> auth(String userName, String password) {
    //create Promise object
    Promise<String> promise = Promise.promise();
    if (userName.equals("admin") && password.equals("admin")) {
      promise.complete("Login success");
    } else {
      promise.fail("Login failed");
    }
    return promise;
  }

  public Future<String> authV1(String userName, String password) {
    //create Promise object
    Promise<String> promise = Promise.promise();
    if (userName.equals("admin") && password.equals("admin")) {
      promise.complete("Login success");
    } else {
      promise.fail("Login failed");
    }
    return promise.future();
  }

  @Override
  public void start() throws Exception {
    super.start();
    //future method will convert promise into Future
    auth("admin", "admin").future()
      .onSuccess(System.out::println)
      .onFailure(System.out::println);

    authV1("admin", "admin")
      .onSuccess(System.out::println)
      .onFailure(System.out::println);
  }
}

public class PromiseVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(PromiseVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new LoginVerticle());
  }
}
............................................................................................
				Verticle Start Method
...........................................................................................


Async Verticle Start and Stop:

Sometimes you want to do something in your verticle start-up which takes some time and you don’t want the verticle to be considered deployed until that happens. For example you might want to start an HTTP server in the start method and propagate the asynchronous result of the server listen method

The way to do it is to implement the asynchronous start method(start method with Promise Arg)
.This version of the method takes a Future(Promise) as a parameter. When the method returns the verticle will not be considered deployed.

Every Verticle will have unique deploymentId, which can be used to unDeploy the verticles

package com.unisys.promises;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.example.util.Runner;

public class DeployHttpVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(DeployHttpVerticle.class);
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);

//        vertx.deployVerticle(new HttpVerticle(), ar -> {
//      if (ar.succeeded()) {
//        System.out.println("Verticle deloyed  : " + ar.result());
//      }
//    });
    vertx.deployVerticle(HttpVerticle.class.getName(), ar -> {
      if (ar.succeeded()) {
        System.out.println(HttpVerticle.class.getName() + " Deployment ID " +  ar.result());
      }
    });
    vertx.deployVerticle(HttpVerticle.class.getName(), ar -> {
      if (ar.succeeded()) {
        System.out.println(HttpVerticle.class.getName() + " Deployment ID " +  ar.result());
      }
    });
  }
}
..............................................................................................
				 Vertx Non Blocking Programming(IO)
..............................................................................................

Vertx provides lot of non blocking apis

1.Timer
2.File System
3.HTTP API


package com.unisys.nonblocking.timers;

import io.vertx.core.*;
import io.vertx.example.util.Runner;

public class TimersVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(TimersVerticle.class);
  }

  private void blockMe(String str) {
    System.out.println(str);
  }

  //  public void delay(long delayTime) {
//    vertx.setTimer(delayTime, handler -> {
//      System.out.println("I am delayed output" + "Timeout is " + delayTime);
//    });
//  }
//  public Future<String> delay(long delayTime) {
//    Future<String> future = Future.future(ar -> {
//      vertx.setTimer(delayTime, handler -> {
//        //System.out.println("I am delayed output" + "Timeout is " + delayTime);
//        String response = "I am delayed output" + "Timeout is " + delayTime;
//      });
//    });
//    //return future;
//
//  }

  public void delay(long delayTime, Handler<AsyncResult<String>> aHandler) {
    vertx.setTimer(delayTime, handler -> {
      String response = "I am delayed output" + "Timeout is " + delayTime;
      aHandler.handle(Future.succeededFuture(response));
    });
  }

  //tick
  public void tick(Handler<AsyncResult<String>> aHandler) {
    long timerId = vertx.setPeriodic(1000, handler -> {
      aHandler.handle(Future.succeededFuture(Math.random() + ""));
    });
    //stop ticking
    vertx.setTimer(10000, stopHandler -> {
      System.out.println("Stop Polling");
      vertx.cancelTimer(timerId);
    });
  }


  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    blockMe("start");
//    delay(5000);
//    delay(3000);
    delay(500, asyncResult -> {
      System.out.println(asyncResult.result());
    });
    tick(res -> {
      System.out.println(res.result());
    });

    blockMe("end");
  }
}
..............................................................................................
				   Data Interchange Formats
..............................................................................................

JSON :
package com.unisys.datainterchange;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;

public class JSONVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(JSONVerticle.class);
  }

  public Future<JsonObject> getUser() {
    JsonObject user = new JsonObject();
    user.put("id", 1);
    user.put("firstName", "Subramanian");
    user.put("lastName", "Murugan");
    return Future.succeededFuture(user);
  }


  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    getUser().onSuccess(user -> {
      System.out.println(user.encodePrettily());
    });
  }
}
.............................................................................................
					Fluent Api /Fluent Patterns
...........................................................................................
Instead of writing multiple lines of code and storing them into mutliple variables. we can chain the apis, finally we can get output, This is sometimes called as builder pattern.
Vertx apis are fully fulent.


package com.unisys.datainterchange;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;

public class JSONVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(JSONVerticle.class);
  }

  public Future<JsonArray> getUser() {
//    JsonObject user = new JsonObject();
//    user.put("id", 1);
//    user.put("firstName", "Subramanian");
//    user.put("lastName", "Murugan");
    //Vertx Flutent Pattern
    JsonObject user = new JsonObject()
      .put("id", 1)
      .put("firstName", "Subramanian")
      .put("lastName", "Murugan")
      .put("address", new JsonObject()
        .put("city", "Coimbatore")
        .put("state", "Tamil Nadu"));

    JsonArray users = new JsonArray()
      .add(user)
      .add(user)
      .add(new JsonObject()
        .put("id", 1)
        .put("firstName", "Subramanian")
        .put("lastName", "Murugan")
        .put("address", new JsonObject()
          .put("city", "Coimbatore")
          .put("state", "Tamil Nadu")));


    return Future.succeededFuture(users);
  }


  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    getUser().onSuccess(user -> {
      System.out.println(user.encodePrettily());
    });
  }
}
..............................................................................................
Merging:
package com.unisys.datainterchange;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;

public class JSONVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(JSONVerticle.class);
  }

  public Future<JsonArray> getUser() {
//    JsonObject user = new JsonObject();
//    user.put("id", 1);
//    user.put("firstName", "Subramanian");
//    user.put("lastName", "Murugan");
    //Vertx Flutent Pattern
    JsonObject skill = new JsonObject().put("skillId", 100).put("skill", "Vertx");

    JsonObject user = new JsonObject()
      .put("id", 1)
      .put("firstName", "Subramanian")
      .put("lastName", "Murugan")
      .mergeIn(skill)
      .put("address", new JsonObject()
        .put("city", "Coimbatore")
        .put("state", "Tamil Nadu"));

    JsonArray users = new JsonArray()
      .add(user)
      .add(user)
      .add(new JsonObject()
        .put("id", 1)
        .put("firstName", "Subramanian")
        .put("lastName", "Murugan")
        .put("address", new JsonObject()
          .put("city", "Coimbatore")
          .put("state", "Tamil Nadu")));


    return Future.succeededFuture(users);
  }


  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    getUser().onSuccess(user -> {
      System.out.println(user.encodePrettily());

    });
  }
}
.............................................................................................
				Non Blocking Network IO Application
.............................................................................................

HTTP Server Application:

=>Vertx provides webserver, you dont need to deploy vertx apps on Tomcat like container.
=>Vertx Webserver is fully non blocking, powered with event loop threads.


vertx.createHttpServer();

package com.unisys.nonblocking.http;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerResponse;
import io.vertx.example.util.Runner;

public class SimpleHTTPVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(SimpleHTTPVerticle.class);
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    //writing http apps
    HttpServer httpServer = vertx.createHttpServer();

    //Your app code : Request and Response Handlers
    httpServer.requestHandler(request -> {
      HttpServerResponse response = request.response();
      response.end("Hello Vertx");
    });
    //start the server
    httpServer.listen(3000, httpServerAsyncResult -> {
      if (httpServerAsyncResult.succeeded()) {
        System.out.println("Server is Up @ " + httpServerAsyncResult.result().actualPort());
      } else {
        System.out.println(httpServerAsyncResult.cause());
      }
    });

  }
}
..............................................................................................

Fluent WebServer:
package com.unisys.nonblocking.http;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.AsyncResult;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerRequest;
import io.vertx.example.util.Runner;

public class FluentHTTPServer extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(FluentHTTPServer.class);
  }

  private static void handle(HttpServerRequest request) {
    request.response().end("Hello Http Server");
  }

  private static void startServer(AsyncResult<HttpServer> httpServerAsyncResult) {
    if (httpServerAsyncResult.succeeded()) {
      System.out.println("Server is Up @ " + httpServerAsyncResult.result().actualPort());
    } else {
      System.out.println(httpServerAsyncResult.cause());
    }
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    //writing http apps
//    vertx.createHttpServer()
//      .requestHandler(request -> request.response().end("Hello Http Server"))
//      .listen(3000, httpServerAsyncResult -> {
//        if (httpServerAsyncResult.succeeded()) {
//          System.out.println("Server is Up @ " + httpServerAsyncResult.result().actualPort());
//        } else {
//          System.out.println(httpServerAsyncResult.cause());
//        }
//      });

    vertx.createHttpServer()
      .requestHandler(FluentHTTPServer::handle)
      .listen(3000, FluentHTTPServer::startServer);

  }
}
.............................................................................................
				  How to write Restfull webservices
..............................................................................................

Web:
  Distributed Information system 

In 1981/82 , Internet was open sourced...

British scientist Tim Berners-Lee invented the World Wide Web while working at CERN in 1989,based on internet.

Internet - network system
Web -software system , helps to transfer information over internet.

1991 - Web started for other biz systems.

1989 -1995 - Static Web- only transfering html.
1995-- till date - dynamic content generation tech -  cgi,j2ee,asp,php..

1998- Ecommerce - How to transfer data/information among biz 

Birth of Web Services:
......................

The Program which sends data /information via internet to other systems not inthe form of html.

2000 -  The data interchange conference held. where many people proposed various data formats
There were more than 30 formates proposed - xml,json,dat,txt,csv.........
At the end "XML" Was choosen. 

Web based on XML format - WebServices using XML - SOAP(protocal designed to transport xml docs over http) Web Service

2005 -  SOAP based webservices started failing due to XML documents.

REST Got introduced -  
  REST Can transport data over http only.
  REST can transport data in different formats -  JSON
  REST modeled based on HTTP verb semantics -  GET,UPDATE,DELETE,PUT.

2008 - SPA  How to build  Userfaces in the client side.
..............................................................................................
				Today Web Technology

API : Application Programming Interface
 entry and exit point of data transmission.
 Unit of Computation.
 API is implemented in many ways

1.REST APIS
2.GraphQL API
3.RPC/RPI api
4.MOM  api 

Client Side - SPAS/Mobile Apps


REST APIS Using Vertx:
......................

Resource:
  The data which need to be returned.

Resource identifier -  URI - "/api/customers/list" - GET 

API Verbs
 GET -  read
 PUT  - update
 DELETE - remove
 POST -  Send data


package com.unisys.nonblocking.http;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpMethod;
import io.vertx.example.util.Runner;

public class SimpleHTTPAPI extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(SimpleHTTPAPI.class);
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    vertx.createHttpServer()
      .requestHandler(request -> {
        //build rest api
        if (request.uri().equals("/api/users") && request.method() == HttpMethod.GET) {
          request.response().setStatusCode(200).end("users-GET");
        }
        if (request.uri().equals("/api/users") && request.method() == HttpMethod.POST) {
          request.response().setStatusCode(200).end("users-POST");
        }
        if (request.uri().equals("/api/users") && request.method() == HttpMethod.PUT) {
          request.response().setStatusCode(200).end("users-PUT");
        }
      })
      .listen(3000,server -> {
        if (server.succeeded()) {
          System.out.println(server.result().actualPort() + " Server is running");
        } else {
          System.out.println(server.cause());
        }
      });


  }
}
I WANT TO build REST End point :


URL - resource mapping
 /api/resource
 
METHOD -  GET ,POST,PUT,DELETE....


  public void buildREST() {
    vertx.createHttpServer().requestHandler(request -> {
      //URL MAPPING AND METHOD MAPPING
      if (request.uri().equals("/api/users") && request.method() == HttpMethod.GET) {
        request.response().setStatusCode(200).end("users-GET");
      }
      if (request.uri().equals("/api/users") && request.method() == HttpMethod.POST) {
        request.response().setStatusCode(200).end("users-POST");
      }
      if (request.uri().equals("/api/users") && request.method() == HttpMethod.PUT) {
        request.response().setStatusCode(200).end("users-PUT");
      }
    }).listen(3000, httpServerAsyncResult -> {
      if (httpServerAsyncResult.succeeded()) {
        System.out.println("server is running at " + httpServerAsyncResult.result().actualPort());
      } else {
        System.out.println("Server has failed to start");
      }
    });
  }

Have a look at the above, notice the drawbacks.

-The developer write all method and resource mapping logic
-There is no proper modularity in build ing apps.

Soultion:

Vertx provides a small framework for abstracting these things
vertx-web

Concepts:

Router:
........
 Router is one the core concepts of vertx-web.
 Its object which maintains zero or more Routes("url mappers")
 Router takes an http request and finds the matching routing for that request.
 Every route has handler which process requests and send responses.


RoutingContext:
   It is container object , from which you can get request and response object.


Use case : Basic routing:

package com.unisys.nonblocking.http.web;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerOptions;
import io.vertx.core.http.HttpServerResponse;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;
import io.vertx.ext.web.Router;

public class SimpleWebAPI extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(SimpleWebAPI.class);
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);

    HttpServerOptions options;
    HttpServer server = vertx.createHttpServer();
//    server.requestHandler(request -> {
//      HttpServerResponse serverResponse = request.response();
//      serverResponse.setStatusCode(200);
//      serverResponse.putHeader("content-type", "application/json");
//      JsonObject greet = new JsonObject().put("message", "Hello");
//      serverResponse.end(greet.encodePrettily());
//    });

    //Router creation
    Router router = Router.router(vertx);
    //route
    router.route().handler(ctx -> {
      HttpServerResponse serverResponse = ctx.response();
      serverResponse.setStatusCode(200);
      serverResponse.putHeader("content-type", "application/json");
      JsonObject greet = new JsonObject().put("message", "Hello Vertx Web");
      serverResponse.end(greet.encodePrettily());
    });

    server.requestHandler(router);
    server.listen(8080);

  }
}
...........................................................................................
					Routers using route method

package com.unisys.nonblocking.http.web;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpMethod;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerOptions;
import io.vertx.core.http.HttpServerResponse;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;
import io.vertx.ext.web.Router;

public class SimpleWebAPI extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(SimpleWebAPI.class);
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);

    HttpServerOptions options;
    HttpServer server = vertx.createHttpServer();
//    server.requestHandler(request -> {
//      HttpServerResponse serverResponse = request.response();
//      serverResponse.setStatusCode(200);
//      serverResponse.putHeader("content-type", "application/json");
//      JsonObject greet = new JsonObject().put("message", "Hello");
//      serverResponse.end(greet.encodePrettily());
//    });

    //Router creation
    Router router = Router.router(vertx);

    //new Route
    router.route(HttpMethod.GET, "/api/hello").handler(ctx -> {
      System.out.println("hello");
      HttpServerResponse serverResponse = ctx.response();
      serverResponse.setStatusCode(200);
      serverResponse.putHeader("content-type", "application/json");
      JsonObject greet = new JsonObject().put("message", "Hello");
      serverResponse.end(greet.encodePrettily());
    });
    router.route(HttpMethod.GET, "/api/hai").handler(ctx -> {
      System.out.println("hai");
      HttpServerResponse serverResponse = ctx.response();
      serverResponse.setStatusCode(200);
      serverResponse.putHeader("content-type", "application/json");
      JsonObject greet = new JsonObject().put("message", "Hai");
      serverResponse.end(greet.encodePrettily());
    });
    //route : wild card pattern  , any route
    router.route().handler(ctx -> {
      HttpServerResponse serverResponse = ctx.response();
      serverResponse.setStatusCode(200);
      serverResponse.putHeader("content-type", "application/json");
      JsonObject greet = new JsonObject().put("message", "Home");
      serverResponse.end(greet.encodePrettily());
    });
    server.requestHandler(router);
    server.listen(8080);

  }
}
............................................................................................
				Path Parameters
............................................................................................
package com.unisys.nonblocking.http.web;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerResponse;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;
import io.vertx.ext.web.Router;

public class RouterVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(RouterVerticle.class);
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    HttpServer server = vertx.createHttpServer();
    //Router creation
    Router router = Router.router(vertx);


    //new Route
    router.get("/api/hello").handler(ctx -> {
      System.out.println("hello");
      HttpServerResponse serverResponse = ctx.response();
      serverResponse.setStatusCode(200);
      serverResponse.putHeader("content-type", "application/json");
      JsonObject greet = new JsonObject().put("message", "Hello");
      serverResponse.end(greet.encodePrettily());
    });
    router.get("/api/hai").handler(ctx -> {
      System.out.println("hai");
      HttpServerResponse serverResponse = ctx.response();
      serverResponse.setStatusCode(200);
      serverResponse.putHeader("content-type", "application/json");
      JsonObject greet = new JsonObject().put("message", "Hai");
      serverResponse.end(greet.encodePrettily());
    });
    router.post("/api/hai").handler(ctx -> {
      System.out.println("hai");
      HttpServerResponse serverResponse = ctx.response();
      serverResponse.setStatusCode(200);
      serverResponse.putHeader("content-type", "application/json");
      JsonObject greet = new JsonObject().put("message", "Hai -POST");
      serverResponse.end(greet.encodePrettily());
    });
//path Parameters: dynamic url  /api/hello/subramanian | Ram | John
    router.get("/api/hello/:whom").handler(ctx -> {
      HttpServerResponse serverResponse = ctx.response();
      //using request object extract path parameters
      String whom = ctx.pathParam("whom");
      serverResponse.setStatusCode(200);
      serverResponse.putHeader("content-type", "application/json");
      JsonObject greet = new JsonObject().put("message", "greet " + whom);
      serverResponse.end(greet.encodePrettily());
    });

    //route : wild card pattern  , any route
    router.route().handler(ctx -> {
      HttpServerResponse serverResponse = ctx.response();
      serverResponse.setStatusCode(200);
      serverResponse.putHeader("content-type", "application/json");
      JsonObject greet = new JsonObject().put("message", "Home");
      serverResponse.end(greet.encodePrettily());
    });
    server.requestHandler(router);
    server.listen(8080);

  }
}
.............................................................................................
				How to read Payload
.............................................................................................


How to read payload?

 router.post("/api/greet").handler(ctx -> {
      HttpServerResponse serverResponse = ctx.response();
      //reading data:
      JsonObject payload = ctx.getBodyAsJson();
      System.out.println(payload.encodePrettily());

      serverResponse.setStatusCode(200);
      serverResponse.putHeader("content-type", "application/json");
      JsonObject greet = new JsonObject().put("message", "Hai -POST");
      serverResponse.end(greet.encodePrettily());
    });

when you run, you will get error like below?

Feb 02, 2022 4:23:37 PM io.vertx.ext.web.RoutingContext
WARNING: BodyHandler in not enabled on this route: RoutingContext.getBodyAsJson() in always be NULL
Feb 02, 2022 4:23:37 PM io.vertx.ext.web.RoutingContext
SEVERE: Unhandled exception in router
java.lang.NullPointerException
	at com.unisys.nonblocking.http.web.RouterVerticle.lambda$start$2(RouterVerticle.java:45)

From the client side we send "json" , json is simple text format, but vertx deals Object

POST /api/greet
{
  "message" : "How are you?"

}

Solution:
    //which enables parsers -  json-  JsonObject

router.route().handler(BodyHandler.create());


router.post("/api/greet").handler(ctx -> {
      HttpServerResponse serverResponse = ctx.response();
      //reading data:
      JsonObject payload = ctx.getBodyAsJson();
      System.out.println(payload.encodePrettily());

      serverResponse.setStatusCode(200);
      serverResponse.putHeader("content-type", "application/json");
      JsonObject greet = new JsonObject().put("message", "Hai -POST");
      serverResponse.end(greet.encodePrettily());
    });
..............................................................................................
package com.unisys.nonblocking.http.web;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerResponse;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.handler.BodyHandler;

public class RouterVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(RouterVerticle.class);
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    HttpServer server = vertx.createHttpServer();
    //Router creation
    Router router = Router.router(vertx);
    //which enables parsers -  json-  JsonObject
    router.route().handler(BodyHandler.create());

    //new Route
    router.get("/api/hello").handler(ctx -> {
      System.out.println("hello");
      HttpServerResponse serverResponse = ctx.response();
      serverResponse.setStatusCode(200);
      serverResponse.putHeader("content-type", "application/json");
      JsonObject greet = new JsonObject().put("message", "Hello");
      serverResponse.end(greet.encodePrettily());
    });
    router.get("/api/hai").handler(ctx -> {
      System.out.println("hai");
      HttpServerResponse serverResponse = ctx.response();
      serverResponse.setStatusCode(200);
      serverResponse.putHeader("content-type", "application/json");
      JsonObject greet = new JsonObject().put("message", "Hai");
      serverResponse.end(greet.encodePrettily());
    });
    router.post("/api/greet").handler(ctx -> {
      HttpServerResponse serverResponse = ctx.response();
      //reading data:
      JsonObject payload = ctx.getBodyAsJson();
      System.out.println(payload.encodePrettily());

      serverResponse.setStatusCode(200);
      serverResponse.putHeader("content-type", "application/json");
      JsonObject greet = new JsonObject().put("message", "Hai -POST");
      serverResponse.end(greet.encodePrettily());
    });
//path Parameters: dynamic url  /api/hello/subramanian | Ram | John
    router.get("/api/hello/:whom").handler(ctx -> {
      HttpServerResponse serverResponse = ctx.response();
      //using request object extract path parameters
      String whom = ctx.pathParam("whom");
      serverResponse.setStatusCode(200);
      serverResponse.putHeader("content-type", "application/json");
      JsonObject greet = new JsonObject().put("message", "greet " + whom);
      serverResponse.end(greet.encodePrettily());
    });


    server.requestHandler(router);
    server.listen(8080);

  }
}
.............................................................................................
				 Query Parameters

.............................................................................................

URL :
http://localhost:8080/api/good?message=eve

   router.get("/api/good").handler(ctx -> {
      List<String> message = ctx.queryParam("message");
      System.out.println(message.size());
      ctx.response().end("good " + message.get(0));
    });

..............................................................................................
				Resource Oriented Routers


Domain Models:

/api/users
   list
   save
   update
   remove

/api/products
  list
  save
  update
  

What if i have more resources and more routes?

ProductRouter - /api/products
UserRouter -  /api/users
Payment Router - /api/payment

server.requestHandler(?);

SubRouters and Main routers

- you can have more subrouters - prodct,user,payment..
-  you can have only one main /app router -  approuter
- that app router only can passed to requestHandler(appRouter).

How to bind /connect app router with subrouter

Router has method called "mountSubRouter"

package com.unisys.nonblocking.http.web;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.RoutingContext;
import io.vertx.ext.web.handler.BodyHandler;

public class ResourceRouters extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(ResourceRouters.class);
  }

  private static void list(RoutingContext ctx) {
    ctx.response().end("Users");
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    //SubRouters
    Router userRouter = Router.router(vertx);
    Router productsRouter = Router.router(vertx);
    Router customerRouter = Router.router(vertx);
    //Main/app router
    Router appRouter = Router.router(vertx);
    //initialize global Parser
    appRouter.route().handler(BodyHandler.create());
    userRouter.get("/list").handler(UserRouter::list);
    userRouter.post("/create").handler(UserRouter::create);
    productsRouter.get("/list").handler(ProductsRouter::list);
    customerRouter.get("/list").handler(CustomersRouter::list);

    //Mount/Bind appRouter with subRouters
    appRouter.mountSubRouter("/api/users", userRouter);
    appRouter.mountSubRouter("/api/products", productsRouter);
    appRouter.mountSubRouter("/api/customers", customerRouter);

    vertx.createHttpServer().requestHandler(appRouter).listen(8080, handler -> {
      if (handler.succeeded()) {
        System.out.println("Webserver is running at " + handler.result().actualPort());
      }
    });


  }

  //inner class
  private static class UserRouter {
    public static void create(RoutingContext ctx) {
      JsonObject user = ctx.getBodyAsJson();
      System.out.println(user.encodePrettily());
      ctx.response().setStatusCode(201).end("User saved");
    }

    public static void list(RoutingContext ctx) {
      ctx.response().setStatusCode(200).end("User list");
    }
  }

  private static class ProductsRouter {
    public static void create(RoutingContext ctx) {
      JsonObject user = ctx.getBodyAsJson();
      System.out.println(user.encodePrettily());
      ctx.response().setStatusCode(201).end("Product saved");
    }

    public static void list(RoutingContext ctx) {
      ctx.response().setStatusCode(200).end("Product list");
    }
  }

  private static class CustomersRouter {
    public static void create(RoutingContext ctx) {
      JsonObject user = ctx.getBodyAsJson();
      System.out.println(user.encodePrettily());
      ctx.response().setStatusCode(201).end("Customers saved");
    }

    public static void list(RoutingContext ctx) {
      ctx.response().setStatusCode(200).end("Customers list");
    }
  }
}
............................................................................................
				Exception Handling
.............................................................................................

If something went wrong how to handle exception and how to send error messages to clients.

router.failureHandler(fRctx->{
  //extract error information
  send error data to client
})

package com.unisys.nonblocking.http.web;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;
import io.vertx.ext.web.Router;

public class WebExceptionVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(WebExceptionVerticle.class);
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    Router userRouter = Router.router(vertx);
    Router appRouter = Router.router(vertx);
    appRouter.mountSubRouter("/api/users", userRouter);

    userRouter.get("/list/:name").handler(ctx -> {
      String name = ctx.pathParam("name");
      if (name.equals("admin")) {
        ctx.response().setStatusCode(200).end("You are valid User");
      } else {
        throw new RuntimeException("You are Invalid User!!!!");
      }
    }).failureHandler(fctx -> {
      int statuCode = fctx.statusCode();
      String message = fctx.failure().getMessage();
      JsonObject jsonObject = new JsonObject().put("code", 100).put("message", message);
      fctx.response().setStatusCode(statuCode).end(jsonObject.encodePrettily());
    });

    vertx.createHttpServer().requestHandler(appRouter).listen(8080, handler -> {
      if (handler.succeeded()) {
        System.out.println("Webserver is running at " + handler.result().actualPort());
      }
    });
  }
}

.............................................................................................

Handlers Type:

router.handler() -  async request handler
router.failureHandler() - async exception/error handler.

Global Handlers:
BodyHandler - converts "json string" into JsonObject
TimeoutHandler - to set Request timeout for given url or global
blockingHandler - For writing blocking code.

.............................................................................................
				Content Negoation
............................................................................................
Rest api can accept and return multiple data formats based on Request from the client.

One Single Rest api can serve data in multiple formats such as  xml,html,pdf,json,text...

package com.unisys.nonblocking.http.web;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.handler.ResponseContentTypeHandler;

public class ContentNegoation extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(ContentNegoation.class);
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    Router userRouter = Router.router(vertx);
    Router appRouter = Router.router(vertx);

    //adding header automatically into response
    appRouter.route().handler(ResponseContentTypeHandler.create());

    appRouter.mountSubRouter("/api/users", userRouter);

    userRouter.get("/")
      .produces("application/json")
      .handler(ctx -> {
        System.out.println(ctx.getAcceptableContentType());
//        if (ctx.getAcceptableContentType().equals("text/plain")) {
//          ctx.response().end("Text content");
//        } else {
//          ctx.response().end(new JsonObject().put("content", "json").encodePrettily());
//        }
        ctx.response().end(new JsonObject().put("content", "json").encodePrettily());
      });

    vertx.createHttpServer().requestHandler(appRouter).listen(8080, handler -> {
      if (handler.succeeded()) {
        System.out.println("Webserver is running at " + handler.result().actualPort());
      }
    });
  }
}
..............................................................................................
				 Verticle(Object) Communications
.............................................................................................

Object Communication Patterns:
=>With in Process(Within JVM) (WithIn Vertx Engine)
=>Across process(Across JVM) (Across Vertx Engine)

With in Process(Within JVM) (WithIn Vertx Engine):

In General java objects talk each other by calling methods on each other.

class OrderController {
   OrderService service
   
  placeOrder(){
    this.service.processOrder()
  }
}

class OrderService{

  processOrder(){
   return 'order data'
 }
}

Vertx:
class OrderPlacerVerticle extends AbstractVerticle {
       
}
               ||
class OrderProviderVerticle extends AbstractVerticle {

}

In Vertx verticles communicate by default "Async /in non blocking".

Verticles Communication Styles:

1.Actor Model Communication Style
  https://doc.akka.io/docs/akka/current/typed/guide/actors-intro.html
2.HTTP communication Style.

Vertx uses loosly coupled communcation style using "Event Bus"  - which is implemenation  of actor like model.


1.message oriented style :Event Bus

Event Bus:

-Event Bus is nerve of vertx systems.

-Vertx By default is distributed

-Vertx carries distributed architecture by default

-In Vertx Verticles can communicate via Centraized Broker which is built in called event Bus.
-Event Bus uses tcp transport layer by default
-EventBus can send and recive data in the form of json and buffer


Event Bus:

1.Event Bus can allow verticles sends data from one place to another place
2.Event Bus forms a distributed peer-to-peer messaging system spannining multiple server nodes   and multiple browers.
3.Event bus allows sending messages in three ways
  1.pub/sub : one to many
  2.point-to-point : one to one
  3.request-reply(reponse) - one to one with acknowlegement.

4.Event bus identifies clients via "addressing"
   Messages are sent on the event bus to an "address"
   Address schemes can be any naming convention, recommendation is dns model "in.news.covid"
   
5.Handlers
   Since vertx is non blocking, messages are processed by handlers.
   You have to register a handler at an address

6.Type of Data
   Data type of message could be any primitive-int,char,boolean,String, Buffer,JSON

   Per Vertx Engine only One Event Bus-singleTon
............................................................................................


How to get Event Bus Object?

EventBus mybus =  vertx.eventBus();

starting send message

mybus.send
mybus.publish
mybus.request
..............................................................................................
				   PUB - SUB
..............................................................................................
package com.unisys.verticle.communication;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.eventbus.EventBus;
import io.vertx.core.eventbus.MessageConsumer;
import io.vertx.example.util.Runner;
import io.vertx.ext.web.Router;

class Address {
  public final static String PUB_SUB_ADDRESS = "news.in.covid";
  public final static String POINT_TO_POINT = "covid.fin.request";
  public final static String REQUEST_REPLY = "covid.lab.report";
}

//http verticle
class CovidCommunicatorVerticle extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    Router appRouter = Router.router(vertx);
    Router broadcastRouter = Router.router(vertx);
    appRouter.mountSubRouter("/api/brodcast", broadcastRouter);
    broadcastRouter.get("/:message").handler(ctx -> {
      //Event Bus to send message to other Verticles
      String message = ctx.pathParam("message");
      EventBus eventBus = vertx.eventBus();
      eventBus.publish(Address.PUB_SUB_ADDRESS, message);
      ctx.response().end("Message has Broad casted");
    });
    vertx.createHttpServer().requestHandler(appRouter).listen(8080, handler -> {
      if (handler.succeeded()) {
        System.out.println("Event Bus Web Server is running at " + handler.result().actualPort());
      }
    });

  }
}

//PUB - SUB Listener
class NewsSevenVerticle extends AbstractVerticle {
  public void consume() {
    //Get the Reference of Event Bus
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> consumer = eventBus.consumer(Address.PUB_SUB_ADDRESS);
    //process the message
    consumer.handler(msg -> {
      System.out.println(this.getClass().getSimpleName() + " => " + msg.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}

class BBCVerticle extends AbstractVerticle {
  public void consume() {
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.PUB_SUB_ADDRESS);
    messageConsumer.handler(message -> {
      System.out.println(this.getClass().getSimpleName() + " => " + message.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}

class NDTVVerticle extends AbstractVerticle {
  public void consume() {
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.PUB_SUB_ADDRESS);
    messageConsumer.handler(message -> {
      System.out.println(this.getClass().getSimpleName() + " => " + message.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}

public class EventBusMainVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(EventBusMainVerticle.class);
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    vertx.deployVerticle(new CovidCommunicatorVerticle());
    vertx.deployVerticle(new NewsSevenVerticle());
    vertx.deployVerticle(new BBCVerticle());
    vertx.deployVerticle(new NDTVVerticle());
  }
}
.............................................................................................
			Point to Point : one to one Communication
............................................................................................
package com.unisys.verticle.communication;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.eventbus.EventBus;
import io.vertx.core.eventbus.MessageConsumer;
import io.vertx.example.util.Runner;
import io.vertx.ext.web.Router;

class Address {
  public final static String PUB_SUB_ADDRESS = "news.in.covid";
  public final static String POINT_TO_POINT = "covid.fin.request";
  public final static String REQUEST_REPLY = "covid.lab.report";
}

///////////////////////////////////////PUB-SUB//////////////////////////////////////////////////////////
class CovidCommunicatorVerticle extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    Router appRouter = Router.router(vertx);
    //pub-sub
    Router broadcastRouter = Router.router(vertx);
    //point to point
    Router pointToPointRouter = Router.router(vertx);

    //Request-Reply
    Router requestReplyRouter = Router.router(vertx);


    appRouter.mountSubRouter("/api/brodcast", broadcastRouter);
    appRouter.mountSubRouter("/api/requestfin", pointToPointRouter);
    appRouter.mountSubRouter("/api/status", requestReplyRouter);


    broadcastRouter.get("/:message").handler(ctx -> {
      //Event Bus to send message to other Verticles
      String message = ctx.pathParam("message");
      EventBus eventBus = vertx.eventBus();
      //publish - one to many
      eventBus.publish(Address.PUB_SUB_ADDRESS, message);
      ctx.response().end("Message has Broad casted");
    });

    pointToPointRouter.get("/:howmuch").handler(ctx -> {
      //Event Bus to send message to other Verticles
      String message = ctx.pathParam("howmuch");
      EventBus eventBus = vertx.eventBus();
      //send - one to one
      eventBus.send(Address.POINT_TO_POINT, message);
      ctx.response().end("Message has been sent");
    });

    requestReplyRouter.get("/:name").handler(ctx -> {
      //Event Bus to send message to other Verticles
      String name = ctx.pathParam("name");
      String messageToSend = "Report of " + name;
      //send message and get reply : request-reply with ack
      vertx.eventBus().request(Address.REQUEST_REPLY, messageToSend, asyncResult -> {
        if (asyncResult.succeeded()) {
          System.out.println(asyncResult.result().body());
          ctx.response().end(asyncResult.result().body().toString());
        } else {
          System.out.println(asyncResult.cause());
        }
      });

    });
    vertx.createHttpServer().requestHandler(appRouter).listen(8080, handler -> {
      if (handler.succeeded()) {
        System.out.println("Event Bus Web Server is running at " + handler.result().actualPort());
      }
    });

  }
}

//PUB - SUB Listener
class NewsSevenVerticle extends AbstractVerticle {
  public void consume() {
    //Get the Reference of Event Bus
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> consumer = eventBus.consumer(Address.PUB_SUB_ADDRESS);
    //process the message
    consumer.handler(msg -> {
      System.out.println(this.getClass().getSimpleName() + " => " + msg.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}

class BBCVerticle extends AbstractVerticle {
  public void consume() {
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.PUB_SUB_ADDRESS);
    messageConsumer.handler(message -> {
      System.out.println(this.getClass().getSimpleName() + " => " + message.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}

class NDTVVerticle extends AbstractVerticle {
  public void consume() {
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.PUB_SUB_ADDRESS);
    messageConsumer.handler(message -> {
      System.out.println(this.getClass().getSimpleName() + " => " + message.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}
///////////////////////////////////////PUB-SUB//////////////////////////////////////////////////////////

///////////////////////////////////////POINT TO POINT//////////////////////////////////////////////////////////

class CenertalFinanceVerticle extends AbstractVerticle {

  public void consume() {
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.POINT_TO_POINT);
    //handle /process the message/news
    messageConsumer.handler(news -> {
      System.out.println("Request 1 -  : " + news.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}

///////////Request-Reply///////////////////////////////////////////////////////////////////////
class LabVerticle extends AbstractVerticle {
  public void consume() {
    EventBus eventBus = vertx.eventBus();
    //pub-sub
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.REQUEST_REPLY);
    //handle /process the message/news
    messageConsumer.handler(news -> {
      System.out.println("Request -  : " + news.body());
      //sending reply /ack
      news.reply(news.body() + " who  is Critical , Need More attention");
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}


public class EventBusMainVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(EventBusMainVerticle.class);
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    vertx.deployVerticle(new CovidCommunicatorVerticle());
    /////pub-sub
    vertx.deployVerticle(new NewsSevenVerticle());
    vertx.deployVerticle(new BBCVerticle());
    vertx.deployVerticle(new NDTVVerticle());
    //point to point
    vertx.deployVerticle(new CenertalFinanceVerticle());
    //request-reply
    vertx.deployVerticle(new LabVerticle());

  }
}
..............................................................................................					Request---Reply
package com.unisys.verticle.communication;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.eventbus.EventBus;
import io.vertx.core.eventbus.MessageConsumer;
import io.vertx.example.util.Runner;
import io.vertx.ext.web.Router;

class Address {
  public final static String PUB_SUB_ADDRESS = "news.in.covid";
  public final static String POINT_TO_POINT = "covid.fin.request";
  public final static String REQUEST_REPLY = "covid.lab.report";
}

///////////////////////////////////////PUB-SUB//////////////////////////////////////////////////////////
class CovidCommunicatorVerticle extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    Router appRouter = Router.router(vertx);
    //pub-sub
    Router broadcastRouter = Router.router(vertx);
    //point to point
    Router pointToPointRouter = Router.router(vertx);

    //Request-Reply
    Router requestReplyRouter = Router.router(vertx);


    appRouter.mountSubRouter("/api/brodcast", broadcastRouter);
    appRouter.mountSubRouter("/api/requestfin", pointToPointRouter);
    appRouter.mountSubRouter("/api/status", requestReplyRouter);


    broadcastRouter.get("/:message").handler(ctx -> {
      //Event Bus to send message to other Verticles
      String message = ctx.pathParam("message");
      EventBus eventBus = vertx.eventBus();
      //publish - one to many
      eventBus.publish(Address.PUB_SUB_ADDRESS, message);
      ctx.response().end("Message has Broad casted");
    });

    pointToPointRouter.get("/:howmuch").handler(ctx -> {
      //Event Bus to send message to other Verticles
      String message = ctx.pathParam("howmuch");
      EventBus eventBus = vertx.eventBus();
      //send - one to one
      eventBus.send(Address.POINT_TO_POINT, message);
      ctx.response().end("Message has been sent");
    });

    requestReplyRouter.get("/:name").handler(ctx -> {
      //Event Bus to send message to other Verticles
      String name = ctx.pathParam("name");
      String messageToSend = "Report of " + name;
      //send message and get reply : request-reply with ack
      vertx.eventBus().request(Address.REQUEST_REPLY, messageToSend, asyncResult -> {
        if (asyncResult.succeeded()) {
          System.out.println(asyncResult.result().body());
          ctx.response().end(asyncResult.result().body().toString());
        } else {
          System.out.println(asyncResult.cause());
        }
      });

    });
    vertx.createHttpServer().requestHandler(appRouter).listen(8080, handler -> {
      if (handler.succeeded()) {
        System.out.println("Event Bus Web Server is running at " + handler.result().actualPort());
      }
    });

  }
}

//PUB - SUB Listener
class NewsSevenVerticle extends AbstractVerticle {
  public void consume() {
    //Get the Reference of Event Bus
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> consumer = eventBus.consumer(Address.PUB_SUB_ADDRESS);
    //process the message
    consumer.handler(msg -> {
      System.out.println(this.getClass().getSimpleName() + " => " + msg.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}

class BBCVerticle extends AbstractVerticle {
  public void consume() {
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.PUB_SUB_ADDRESS);
    messageConsumer.handler(message -> {
      System.out.println(this.getClass().getSimpleName() + " => " + message.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}

class NDTVVerticle extends AbstractVerticle {
  public void consume() {
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.PUB_SUB_ADDRESS);
    messageConsumer.handler(message -> {
      System.out.println(this.getClass().getSimpleName() + " => " + message.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}
///////////////////////////////////////PUB-SUB//////////////////////////////////////////////////////////

///////////////////////////////////////POINT TO POINT//////////////////////////////////////////////////////////

class CenertalFinanceVerticle extends AbstractVerticle {

  public void consume() {
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.POINT_TO_POINT);
    //handle /process the message/news
    messageConsumer.handler(news -> {
      System.out.println("Request 1 -  : " + news.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}

///////////Request-Reply///////////////////////////////////////////////////////////////////////
class LabVerticle extends AbstractVerticle {
  public void consume() {
    EventBus eventBus = vertx.eventBus();
    //pub-sub
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.REQUEST_REPLY);
    //handle /process the message/news
    messageConsumer.handler(news -> {
      System.out.println("Request -  : " + news.body());
      //sending reply /ack
      news.reply(news.body() + " who  is Critical , Need More attention");
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}


public class EventBusMainVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(EventBusMainVerticle.class);
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    vertx.deployVerticle(new CovidCommunicatorVerticle());
    /////pub-sub
    vertx.deployVerticle(new NewsSevenVerticle());
    vertx.deployVerticle(new BBCVerticle());
    vertx.deployVerticle(new NDTVVerticle());
    //point to point
    vertx.deployVerticle(new CenertalFinanceVerticle());
    //request-reply
    vertx.deployVerticle(new LabVerticle());

  }
}
............................................................................................
	HTTP communication - Web Clients-Sending and receving messages via http protocal
............................................................................................

Web Client:

Vert.x Web Client is an asynchronous HTTP and HTTP/2 client.

The Web Client makes easy to do HTTP request/response interactions with a web server, and provides advanced features like:

Json body encoding / decoding
request/response pumping
request parameters
unified error handling
form submissions

How to add web client in project?
pom.xml
<dependency>
 <groupId>io.vertx</groupId>
 <artifactId>vertx-web-client</artifactId>
 <version>4.2.4</version>
</dependency>


package com.unisys.nonblocking.http.web.communication;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.buffer.Buffer;
import io.vertx.example.util.Runner;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.client.HttpRequest;
import io.vertx.ext.web.client.WebClient;
import io.vertx.ext.web.handler.BodyHandler;

class HelloVerticle extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    Router router = Router.router(vertx);
    router.route().handler(BodyHandler.create());
    router.get("/api/hello").handler(routingContext -> {
      routingContext.response().end("Hello");
    });

    vertx.createHttpServer()
      .requestHandler(router)
      .listen(3000, httpServerAsyncResult -> {
        if (httpServerAsyncResult.succeeded()) {
          System.out.println("Provider(Hello) Verticle Server is Running " + httpServerAsyncResult.result().actualPort());
        }
      });
  }
}

class GreeterVerticle extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    Router router = Router.router(vertx);
    WebClient webClient = WebClient.create(vertx);

    router.route().handler(BodyHandler.create());
    router.get("/api/greet").handler(routingContext -> {
      //we communiate hello verticle and get data and send
     // HttpRequest<Buffer> httpRequest = webClient.get(3000, "localhost", "/api/hello");
      HttpRequest<Buffer> httpRequest = webClient.getAbs("http://localhost:3000/api/hello");
      httpRequest.send(response -> {
        if (response.succeeded()) {
          System.out.println(response.result().bodyAsString());
          routingContext.response().setStatusCode(200).end(response.result().bodyAsString());
        } else {
          routingContext.response().setStatusCode(200).end(response.cause().getMessage());
        }
      });

    });
    vertx.createHttpServer()
      .requestHandler(router)
      .listen(3001, httpServerAsyncResult -> {
        if (httpServerAsyncResult.succeeded()) {
          System.out.println("Consumer(Greeter) Verticle Server is Running " + httpServerAsyncResult.result().actualPort());
        }
      });
  }
}
//call third party web service communication.

class UsersVerticle extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    Router router = Router.router(vertx);
    WebClient webClient = WebClient.create(vertx);

    router.get("/api/users").handler(routingContext -> {

      webClient.getAbs("https://jsonplaceholder.typicode.com/users").send(res -> {
        System.out.println(res.result().bodyAsJsonArray());
        routingContext.response()
          .putHeader("content-type", "application/json")
          .setStatusCode(200).end(res.result().bodyAsJsonArray().encodePrettily());

      });

    });
    vertx.createHttpServer()
      .requestHandler(router)
      .listen(3002, httpServerAsyncResult -> {
        if (httpServerAsyncResult.succeeded()) {
          System.out.println("Users Verticle Server is Running " + httpServerAsyncResult.result().actualPort());
        }
      });
  }
}


public class WebClientVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(WebClientVerticle.class);
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    vertx.deployVerticle(new GreeterVerticle());
    vertx.deployVerticle(new HelloVerticle());
    vertx.deployVerticle(new UsersVerticle());
  }
}
.............................................................................................
				Vertx and Relational database:
.............................................................................................

Vertx and Relational database:
..............................

JDBC is a technoloy through which you can connect relational databases.

JDBC works database independant , you can connect with any databases with help of jdbc driver.

now a days we are using orm frameworks -jpa,hibernate; orm internally uses jdbc only.

vertx as of no orm support. you have to write jdbc code only. jdbc is non blocking.

JDBC is nonblocking , so apis are callback based or reactive based.

Lets start coding:

1.you jdbc dependency.

<dependency>
 <groupId>io.vertx</groupId>
 <artifactId>vertx-jdbc-client</artifactId>
</dependency>
1.create JDBCClient Object

   final JDBCClient client = JDBCClient.createShared(vertx, new JsonObject()
        .put("url", "jdbc:hsqldb:mem:test?shutdown=true")
        .put("driver_class", "org.hsqldb.jdbcDriver")
        .put("max_pool_size", 30)
        .put("user", "SA")
        .put("password", ""));


2.You have to use callback chain pattern
   connection succcess
		|
		do sql operations
   else
    |
   throw Connection.

client.getConnection(connection -> {
      if (connection.succeeded()) {
        System.out.println("COnnection is ready");
        
      } else {
        System.out.println(connection.cause());
      }
    });

3.Get SqlConnection instance
    client.getConnection(connection -> {
      if (connection.succeeded()) {
        System.out.println("COnnection is ready");
        //get conneciton object
        final SQLConnection con = connection.result();


      } else {
        System.out.println(connection.cause());
      }
    });


3.Table creation :
client.getConnection(connection -> {
      if (connection.succeeded()) {
        System.out.println("COnnection is ready");
        //get conneciton object
        final SQLConnection con = connection.result();
        String CREATE_TABLE = "create table test(id int primary key, name varchar(255))";
        con.execute(CREATE_TABLE, tableCreate -> {
          if (tableCreate.failed()) {
            System.out.println(tableCreate.cause());
          } else {
            System.out.println("Tables are created");
            
          }

        });

      } else {
        System.out.println(connection.cause());
      }
    });

3.Table insert and select

client.getConnection(connection -> {
      if (connection.succeeded()) {
        System.out.println("COnnection is ready");
        //get conneciton object
        final SQLConnection con = connection.result();
        String CREATE_TABLE = "create table test(id int primary key, name varchar(255))";
        con.execute(CREATE_TABLE, tableCreate -> {
          if (tableCreate.failed()) {
            System.out.println(tableCreate.cause());
          } else {
            System.out.println("Tables are created");

            String INSERT_QUERY = "insert into test values(1, 'Hello')";
            con.execute(INSERT_QUERY, tableInsert -> {

              if (tableInsert.failed()) {
                System.out.println(tableInsert.cause());
              } else {
                //show sample data; write select query
                String SELECT_QUERY = "select * from test";
                con.query(SELECT_QUERY, selectResult -> {
                  for (JsonArray line : selectResult.result().getResults()) {
                    System.out.println(line.encode());
                  }
                  // and close the connection
                  con.close(done -> {
                    if (done.failed()) {
                      throw new RuntimeException(done.cause());
                    }
                  });
                });
              }
            });
          }

        });
..............................................................................................
package com.unisys.databases;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;
import io.vertx.ext.jdbc.JDBCClient;
import io.vertx.ext.sql.SQLConnection;

public class JDBCClientVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(JDBCClientVerticle.class);
  }

  public void prepareDatabase() {
    JsonObject connectionString = new JsonObject()
      .put("url", "jdbc:hsqldb:mem:test?shutdown=true")
      .put("driver_class", "org.hsqldb.jdbcDriver")
      .put("max_pool_size", 30)
      .put("user", "SA")
      .put("password", "");
    JDBCClient jdbcClient = JDBCClient.createShared(vertx, connectionString);
    //Establishing connection
    jdbcClient.getConnection(connection -> {
      if (connection.succeeded()) {
        System.out.println("Connection is success");
        //Connection Reference
        SQLConnection sqlConnection = connection.result();
        String CREATE_TABLE = "create table user(id int primary key, name varchar(255))";
        sqlConnection.execute(CREATE_TABLE, tableCreate -> {
          if (tableCreate.succeeded()) {
            String INSERT_QUERY = "insert into user values(1, 'subramanian')";
            sqlConnection.execute(INSERT_QUERY, tableInsert -> {

              if (tableInsert.failed()) {
                System.out.println(tableInsert.cause());
              } else {
                //show sample data; write select query
                String SELECT_QUERY = "select * from user";
                sqlConnection.query(SELECT_QUERY, selectResult -> {
                  for (JsonArray line : selectResult.result().getResults()) {
                    System.out.println(line.encode());
                  }
                  // and close the connection
                  sqlConnection.close(done -> {
                    if (done.failed()) {
                      throw new RuntimeException(done.cause());
                    }
                  });
                });
              }
            });

          } else {
            System.out.println("Tables are created");
          }

        });

      } else {
        System.out.println("Connection is failed");
      }
    });

  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    prepareDatabase();
  }

}
.............................................................................................
				Vertx Threading Models 
			    (Non blocking and blocking code)


Vertx Threading Models:

1.Vertx provides a pool threads to handle async actions(events) via Event Pool Threads.
  Per Vertx engine ,no event loop thread is equal to no of cpu core.

2.Vertx Provides another pool of threads to handle blocking operations called "Worker pool threads".


Blocking code

-Thread.sleep
-long running task
-legacy file io
-legacy network 
-database 
-external api


 Any blocking code can't be executed inside event loop thread.
 Any blocking code must be executed in a separte threads - Worker pool threads.
 Worker pool threads are used for running long running blocking code.

Use case : -1  Getting Event loop thread information

package com.unisys.threading;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.example.util.Runner;

class GreeterVerticle extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    System.out.println(GreeterVerticle.class.getName() + " is Running on " + Thread.currentThread().getName());
  }
}


public class BlockingVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(BlockingVerticle.class);
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    System.out.println(BlockingVerticle.class.getName() + " is Running on " + Thread.currentThread().getName());

    for (int i = 1; i < 27; i++) {
      vertx.deployVerticle(new GreeterVerticle());

    }
  }
}

OUTPUT:
com.unisys.threading.BlockingVerticle is Running on vert.x-eventloop-thread-1
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-2
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-3
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-5
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-4
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-6
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-7
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-8
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-9
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-10
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-13
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-11
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-14
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-16
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-15
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-12
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-17
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-18
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-20
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-19
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-21
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-22
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-23
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-0
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-2
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-3
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-1


Use case 1: Writing blocking code:
..................................

Thread.sleep
class GreeterVerticle extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    System.out.println(GreeterVerticle.class.getName() + " is Running on " + Thread.currentThread().getName());
    //blocking code.
    try {
      Thread.sleep(1000);
      System.out.println("Hi i am  output after blocking!!!");
    } catch (InterruptedException e) {
      System.out.println(e.getMessage());
    }
  }
}
when you run the above code , you will get output.
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-2
Hi i am  output after blocking!!!

The 2nd Version , increasing timeout from 1000 to 3000
class GreeterVerticle extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    System.out.println(GreeterVerticle.class.getName() + " is Running on " + Thread.currentThread().getName());
    //blocking code.
    try {
      Thread.sleep(3000);
      System.out.println("Hi i am  output after blocking!!!");
    } catch (InterruptedException e) {
      System.out.println(e.getMessage());
    }
  }
}
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-2
Feb 03, 2022 3:51:46 PM io.vertx.core.impl.BlockedThreadChecker
WARNING: Thread Thread[vert.x-eventloop-thread-2,5,main] has been blocked for 2443 ms, time limit is 2000 ms
Hi i am  output after blocking!!!
 
 Here we are getting warning, means that you have blocked the current event loop thread  more than 2000 ms.

         "Event loop thread can be blocked up to 2000ms" => Default time out for a thread


Suppose if you block the thread 5000ms, you will get more warnings

class GreeterVerticle extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    System.out.println(GreeterVerticle.class.getName() + " is Running on " + Thread.currentThread().getName());
    //blocking code.
    try {
      Thread.sleep(5000);
      System.out.println("Hi i am  output after blocking!!!");
    } catch (InterruptedException e) {
      System.out.println(e.getMessage());
    }
  }
}

Feb 03, 2022 3:54:33 PM io.vertx.core.impl.BlockedThreadChecker
WARNING: Thread Thread[vert.x-eventloop-thread-2,5,main] has been blocked for 2633 ms, time limit is 2000 ms
Feb 03, 2022 3:54:34 PM io.vertx.core.impl.BlockedThreadChecker
WARNING: Thread Thread[vert.x-eventloop-thread-2,5,main] has been blocked for 3634 ms, time limit is 2000 ms
Feb 03, 2022 3:54:35 PM io.vertx.core.impl.BlockedThreadChecker
WARNING: Thread Thread[vert.x-eventloop-thread-2,5,main] has been blocked for 4635 ms, time limit is 2000 ms
Hi i am  output after blocking!!!
..............................................................................................

more than 3 warnings, still thread is blocked, it will throw exeception

io.vertx.core.VertxException: Thread blocked

class GreeterVerticle extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    System.out.println(GreeterVerticle.class.getName() + " is Running on " + Thread.currentThread().getName());
    //blocking code.
    try {
      Thread.sleep(8000);
      System.out.println("Hi i am  output after blocking!!!");
    } catch (InterruptedException e) {
      System.out.println(e.getMessage());
    }
  }

com.unisys.threading.BlockingVerticle is Running on vert.x-eventloop-thread-1
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-2
Feb 03, 2022 3:56:01 PM io.vertx.core.impl.BlockedThreadChecker
WARNING: Thread Thread[vert.x-eventloop-thread-2,5,main] has been blocked for 2631 ms, time limit is 2000 ms
Feb 03, 2022 3:56:02 PM io.vertx.core.impl.BlockedThreadChecker
WARNING: Thread Thread[vert.x-eventloop-thread-2,5,main] has been blocked for 3633 ms, time limit is 2000 ms
Feb 03, 2022 3:56:03 PM io.vertx.core.impl.BlockedThreadChecker
WARNING: Thread Thread[vert.x-eventloop-thread-2,5,main] has been blocked for 4634 ms, time limit is 2000 ms
Feb 03, 2022 3:56:04 PM io.vertx.core.impl.BlockedThreadChecker
WARNING: Thread Thread[vert.x-eventloop-thread-2,5,main] has been blocked for 5636 ms, time limit is 2000 ms
io.vertx.core.VertxException: Thread blocked
	at java.base@11.0.11/java.lang.Thread.sleep(Native Method)
	at app//com.unisys.threading.GreeterVerticle.start(BlockingVerticle.java:14)
	at app//io.vertx.core.impl.DeploymentManager.lambda$doDeploy$5(DeploymentManager.java:196)
	at app//io.vertx.core.impl.DeploymentManager$$Lambda$80/0x0000000800179840.handle(Unknown Source)
	at app//io.vertx.core.impl.AbstractContext.dispatch(AbstractContext.java:100)
	at app//io.vertx.core.impl.AbstractContext.dispatch(AbstractContext.java:63)
	at app//io.vertx.core.impl.EventLoopContext.lambda$runOnContext$0(EventLoopContext.java:38)
	at app//io.vertx.core.impl.EventLoopContext$$Lambda$81/0x000000080017a440.run(Unknown Source)
	at app//io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164)
	at app//io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:469)
	at app//io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:503)
	at app//io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986)
	at app//io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at app//io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.base@11.0.11/java.lang.Thread.run(Thread.java:834)

Feb 03, 2022 3:56:05 PM io.vertx.core.impl.BlockedThreadChecker
WARNING: Thread Thread[vert.x-eventloop-thread-2,5,main] has been blocked for 6638 ms, time limit is 2000 ms
.............................................................................................
		What if i want to write blocking code inside non blocking context
.............................................................................................

There are two ways to run blocking code.

1.Convert the Event loop thread verticle into worker verticle 

2.I dont want to run the entire verticle in worker thread rather only few apis.



Types of Verticle:

1.standard Verticle
   Verticles are normal , executed by event loop thread
2.Woker verticles
   Verticles are special,executed by a separate thread of execution called "Worker poll threads".

How to create Worker Verticle?
 
Before worker verticle:

Vertx Configurations:

Most of the Vertx objects are configurable using "Configuration Objects".

->HTTP Server Configuration Object
     HttpServerOptions
 HttpServerOptions serverOptions = new HttpServerOptions()
      .setPort(8080).setHost("localhost");
->Event Bus configuration OBject
  DeliveryOptions options = new DeliveryOptions().addHeader("myheader","value");
      vertx.eventBus().send("hello",options);

->Verticle configuration Object, is passed while deployment.
   DeploymentOptions options = new DeploymentOptions().setWorker(true)
   vertx.deployVerticle("com.mycompany.MyVerticle", options);

->Vertx Configuration Object, which change the vertx engine configuration
  VertxOptions


Blocking Verticle:
class GreeterVerticle extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    System.out.println(GreeterVerticle.class.getName() + " is Running on " + Thread.currentThread().getName());
    //blocking code.
    try {
      Thread.sleep(8000);
      System.out.println("Hi i am  output after blocking!!!");
    } catch (InterruptedException e) {
      System.out.println(e.getMessage());
    }
  }
}
DeploymentOptions deploymentOptions = new DeploymentOptions().setWorker(true);
    vertx.deployVerticle(new GreeterVerticle(),deploymentOptions);
..............................................................................................

vert.excuteBlocking:
class UserVerticle extends AbstractVerticle {

  private void resultHandler(AsyncResult<String> resultHandler) {
    System.out.println("Result Handler" + Thread.currentThread().getName());
    if (resultHandler.succeeded()) {
      System.out.println("Blocking api Result goes Ready Here");
      System.out.println(resultHandler.result());
    } else {
      System.out.println(resultHandler.cause().getMessage());
    }
  }

  //blocking method : this operation should be handled by worker pool thread
  public void findAll(Promise<String> promise) {
    System.out.println("findAll : " + Thread.currentThread().getName());
    try {
      Thread.sleep(4000);
      System.out.println("Wake Up for sending data to Non blocking Service");
      //this result will be accessed inside non blocking code
      promise.complete("Hey this is blocking Result");

    } catch (InterruptedException es) {
      promise.fail("Something went wrong in blocking service");
    }
  }
  //non blocking method


  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    //how to wrap blocking code.
    vertx.executeBlocking(this::findAll, this::resultHandler);
  }
}
package com.unisys.threading;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.AsyncResult;
import io.vertx.core.DeploymentOptions;
import io.vertx.core.Promise;
import io.vertx.core.eventbus.DeliveryOptions;
import io.vertx.core.http.HttpServerOptions;
import io.vertx.example.util.Runner;
import io.vertx.ext.web.Router;


class UserVerticle extends AbstractVerticle {

  private void resultHandler(AsyncResult<String> resultHandler) {
    System.out.println("Result Handler" + Thread.currentThread().getName());
    if (resultHandler.succeeded()) {
      System.out.println("Blocking api Result goes Ready Here");
      System.out.println(resultHandler.result());
    } else {
      System.out.println(resultHandler.cause().getMessage());
    }
  }

  //blocking method : this operation should be handled by worker pool thread
  public void findAll(Promise<String> promise) {
    System.out.println("findAll : " + Thread.currentThread().getName());
    try {
      Thread.sleep(4000);
      System.out.println("Wake Up for sending data to Non blocking Service");
      //this result will be accessed inside non blocking code
      promise.complete("Hey this is blocking Result");

    } catch (InterruptedException es) {
      promise.fail("Something went wrong in blocking service");
    }
  }
  //non blocking method


  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    //how to wrap blocking code.
    vertx.executeBlocking(this::findAll, this::resultHandler);

    //web end point
    Router router = Router.router(vertx);

    //non blocking handler :  handler
    //router.get("/api/blocking").handler(routingContext -> {});
    router.get("/api/blocking").blockingHandler(rc -> {
      System.out.println("Http Request Served => " + Thread.currentThread().getName());
      try {
        //blocking code
        Thread.sleep(5000);
        String blockingResult = "Blocking result";
        rc.response().end(blockingResult);
      } catch (Exception e) {

      }
    });

    vertx.createHttpServer().requestHandler(router).listen(8888, ar -> {
      System.out.println("Non Blocking and Blocking Server " + ar.result().actualPort());
    });


  }
}


class GreeterVerticle extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    System.out.println(GreeterVerticle.class.getName() + " is Running on " + Thread.currentThread().getName());
    //blocking code.
    try {
      Thread.sleep(8000);
      System.out.println("Hi i am  output after blocking!!!");
    } catch (InterruptedException e) {
      System.out.println(e.getMessage());
    }
  }
}


public class BlockingVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(BlockingVerticle.class);
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);

    System.out.println(BlockingVerticle.class.getName() + " is Running on " + Thread.currentThread().getName());

    HttpServerOptions serverOptions = new HttpServerOptions()
      .setPort(8080).setHost("localhost");
    vertx.createHttpServer(serverOptions).requestHandler(httpServerRequest -> {
      DeliveryOptions options = new DeliveryOptions().addHeader("myheader", "value");
      vertx.eventBus().send("hello", options);
    }).listen(httpServerAsyncResult -> {
      System.out.println(httpServerAsyncResult.result().actualPort());
    });

    //worker verticle
    DeploymentOptions deploymentOptions = new DeploymentOptions().setWorker(true);
    vertx.deployVerticle(new GreeterVerticle(), deploymentOptions);

    //Regular verticle with blocking code
    vertx.deployVerticle(new UserVerticle());
//

//    for (int i = 1; i < 27; i++) {
//      vertx.deployVerticle(new GreeterVerticle());
//
//    }
  }
}
..............................................................................................
				Vertx and MicroServices
..............................................................................................
Application Pattern:

1.old style  -monolithic

2.new style  -Microservices
 
 Indepedant Development,Testing,deployment,Maintaince,Team but collabrate.
.............................................................................................
Monolith:

-Technology first J2EE, Domain Next.


Team: OMS - PM- More PLS
1. DEV
2. TESTING
3. RELEASE
4. OPERATIONS


1.Req
2.Design
   High Level-UML,Database
   Low level - Runtime,databases,tools......
3.coding

-Vendor-lock in : Mono-lithic
   -DEV,TESTING,PRODUCTION.
-Work flow is highly sequencial
   Req -Complete
   Dev
   testing
   Release
   Production
  Delay in delivery:Cost increased
-Production cost was huge

Data Centers
 -need to purchase high powered servers - bare metal servers
 
Cost:
   -Hardware
   -OS -Linux-Ubuntu
   -Tools -Servers,databases etc....
   -Matrix Hell -  Mapping software components in dev and Production..


How to build enterprise jee based app.

App  must support a variety of different clients including desktop browsers. 

The application might also expose an API for 3rd parties to consume.

It might also integrate with other applications via a message broker. 

The application handles requests (HTTP requests and messages) by executing business logic; 

accessing a database; 

exchanging messages with other systems;

and returning a HTML/JSON/XML response. 

There are logical components corresponding to different functional areas of the application.

............................................................................................

IF App needs to talk to external systems like Message Brokers, other Systems like Main frames.

RPC/RPI
MOM
Connectors Arch.

BIZ LOGIC:

1- Service Layer : isloate service layer into separate component

 can be inside one app - one layer, that layer may run on different jvms -  distributed Arch.


Layer :

 Client ---- Web Layer  ----Service Layer ---- Repository Layer

/////////////////////////////////////////////////////////////////////////////////////////////

Packaging Model:
 
WAR - Web archive
EAR .

Problems with Single JAR/WAR:

1. Scalability
 Vertical scablitity
 Horzitional scability 

2.Deployments
    -Bare Metal Deployment

////////////////////////////////////////////////////////////////////////////////////////////
Monoloith distributed app development drabackbacks:

-Time is taken for project delivery
   -Requirements 
   -High level design and low level design
   -coding
   -testing
   -release
   -production- live

-Technology Stack and Vendor lock in
   -You need to build the entire app using one technology or one vendor product
    eg: J2EE, Oracle,Weblogic

-Production and maintance cost
  -You need to setup large data centers , you need to maintain them.

Companies like amzon,netflix,google wanted to change the app development model.
                                "Micro services"


Micro services are architural model of req,dev,test,relase,production,maintaince different ways.
    Continous req collecting
    Continous dev
    Continuous testing
    Continuous release
    Continuous deployment
    Using rented data centers: Cloud

-Domain First, Technology Next: Domain Driven Design.
-No Vendor lock- Multi tech stack.
-Indidual dev , deployment - orders is development ,tested,deployed,customers are developed,tested deployment.
   -Parrel dev.
-Automation -dev ops
   release - CI 
   deployment - Containerized - Docker..
-Introduction of Cloud computing
..............................................................................................

How to start Building Microservices?


Road Map :

0.Tech Stack - Java,Javascript,Go,Python.....,Mixed
1.Infrastructure
 ->Framework 
	SpringCloud,Vertx,Quarks....
        Moleculer,StrongLoop....
 ->Deployment
      Cloud
      Containers
      Cloud + Containers
 ->Management tools
     metrics
     loggers
     tracing
 ->Integration
	api gateway
        message brokers
        esb

2.Development
     -Coding
  Development Infrastructure
   Communication Patterns 
          -HTTP,TCP,HTTP2,protobuf....
          Brokers -  Message Brokers
   Fault Managment
   Transaction management
   configuration management


MicroService App  == { infrastructure  +   coding }

.............................................................................................
				What any software offers to users
			    (What microservice software offers to users)

                                         "Data"
                                       
..............................................................................................

How to expose data to users?

      "API"  ---------Application Programming interface
..............................................................................................

How to design / implement API?

      "Object" - Object encapsulate API

Object is represented as "Service" - Service Design
..............................................................................................

API Design Types in Web:
........................

1.REST API

2.GRAPHQL API

3.RPC
   Regular api which to be called via tcp or local method call
  gRPC is most popular rpc implementations
..............................................................................................
				Microservice Implementation

Service Implementation:

1.Verticle
    ->HTTP verticle
    ->Message driven Verticle - event Bus
    ->gRpc Verticle -  RPC implemenation

.............................................................................................
				Vertx Configurgation.


How to configure Vertx application:

Vert.x Config
  This component provides an extensible way to configure Vert.x applications.


Configuration Stores(Storage):
..............................

Physical storage:

1.files
2.directories -ldap....
3.HTTP Servers - a separate HTTP server.
4.Redis
5.System Properties
6.environment properties
7.In memory Store: Application memory

Configuration representation inisde vertx is json object.

Storage file formats:
1.yaml
2.json
3.properties
......
Verticle:
 -can read config  data from the Vertx Context Object / DeploymentOptions
 -can read config data  from the file via command line args
 -can read from any storage via Vertx-Config module objects like ConfigReteriver.


Verticles and Configuration:
package com.unisys.microservices.config;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.DeploymentOptions;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;

class GreeterVerticle extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    JsonObject config = config();
    System.out.println(config.encodePrettily());
    String message = config.getString("message", "default");
    int port = config.getInteger("port", 8080);
    System.out.println("=>" + message.toUpperCase());

    vertx.createHttpServer()
      .requestHandler(request -> {
        request.response().end(config().getString("message", "You are lucky!!"));
      })
      .listen(config().getInteger("http.port", 3000));
  }
}


public class ConfigMainVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(ConfigMainVerticle.class);
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    JsonObject config = new JsonObject().put("message", "Hello!!!")
      .put("port", 3000).put("http.port",3002);
    DeploymentOptions options = new DeploymentOptions().setConfig(config);
//    DeploymentOptions options = new DeploymentOptions();

    vertx.deployVerticle(new GreeterVerticle(), options);
  }
}

..............................................................................................

Config From Configuration System:
package com.unisys.microservices.config;

import io.vertx.config.ConfigRetriever;
import io.vertx.config.ConfigRetrieverOptions;
import io.vertx.config.ConfigStoreOptions;
import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;

class ApplicationVerticle extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    ConfigStoreOptions options = new ConfigStoreOptions()
      .setType("file")
      .setFormat("json")
      .setConfig(new JsonObject().put("path", "conf/config.json"));
    ConfigRetriever retriever = ConfigRetriever.create(vertx,
      new ConfigRetrieverOptions().addStore(options));

    retriever.getConfig(config -> {
      if (config.succeeded()) {
        System.out.println("Config is Ready");
        //System.out.println(config.result());
        JsonObject configRes = config.result();
        System.out.println(configRes.getString("appName"));
        System.out.println(configRes.getString("version"));

      } else {
        System.out.println("Config Error : " + config.cause());
      }
    });

  }
}

public class ExternalConfigMainVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(ExternalConfigMainVerticle.class);
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    vertx.deployVerticle(new ApplicationVerticle());
  }
}

How to read config data from the git?

Req:

Logger dependency must be available in class path.

    <dependency>
      <groupId>org.slf4j</groupId>
      <artifactId>slf4j-log4j12</artifactId>
      <version>1.7.26</version>
    </dependency>
    <dependency>
      <groupId>org.slf4j</groupId>
      <artifactId>slf4j-log4j12</artifactId>
      <version>1.7.26</version>
    </dependency>
package com.unisys.microservices.config;

import io.vertx.config.ConfigRetriever;
import io.vertx.config.ConfigRetrieverOptions;
import io.vertx.config.ConfigStoreOptions;
import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;

class ApplicationVerticle extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    // System.out.println("hello");
    ConfigStoreOptions git = new ConfigStoreOptions()
      .setType("git")
      .setConfig(new JsonObject()
        .put("url", "https://github.com/cescoffier/vertx-config-test.git")
        .put("path", "local")
        .put("filesets",
          new JsonArray().add(new JsonObject().put("pattern", "*.json"))));

    ConfigRetriever retriever = ConfigRetriever.create(vertx,
      new ConfigRetrieverOptions().addStore(git));

    retriever.getConfig().onSuccess(jsonObject -> {
      System.out.println("inside config" + jsonObject);
    }).onFailure(err -> {
      System.out.println("error " + err.getMessage());

    });
    vertx.createHttpServer().requestHandler(httpServerRequest -> {

      httpServerRequest.response().end("Hello");
    }).listen(8080, ar -> {
      System.out.println("server is running");
    });

}

public class ExternalConfigMainVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(ExternalConfigMainVerticle.class);
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    vertx.deployVerticle(new ApplicationVerticle());
  }
}
.............................................................................................
				 Reactive Programming/System
.............................................................................................



What is Reactive?

  Oxford dictionary defines reactive  as "showing a response to a stimulus"

Showing a response to a stimulus

1.1 (Physiology) Showing an immune response to a specific antigen

1.2 (of a disease or illness) caused by a reaction to something: ‘reactive
depression’

Acting in response to a situation rather than creating or controlling it

Reactive means Showing response(result) based on events(Event driven Programming model).

Why Reactive?

We start from the desire to build a system that is "responsive to users". This means the
system should respond to user input in a timely fashion under all circumstances.

Because any single computer can fail at any time, we need to distribute such a system
over multiple computers.

............................................................................................
					Reactive Systems

The Software system we build called distributed systems(MicroService) must have the following properties , if the system has the following properties the system is reactive.


1.It must react to its users (responsive).
2.It must react to failure and stay available (resilient).
3.It must react to variable load conditions (elastic).
4.It must react to inputs (message-driven).

Systems built as Reactive Systems are more flexible, loosely-coupled and scalable.


How to build reactive applications?

There are patterns and implementations available.


InfraStructure Pattern:

-elastic patterns
  Scalling apps vertically and horizontal using hardware and software resources.

  increasing more machines based on load using Clusters and load balancer -Vertical scalling
  decreasing machines as much as possible using "Nonblocking and async" architecture-  horizontal 

Vertx supports both scalling;

horizontal scalling via "NonBlocking implementations" - Less threads ,more concurrency.

Vertical scalling via "Vertx Clusters"

Vertx even supports virtualization using "container technology".


Software Patterns:

1.Message Driven
   Software components exchange messages async.
 Vertx supports async messsage passing via "eventbus"
 Vertx Supports async message passing via "rxprogramming -reactive apis"
 
2.Resilient :
   Falut Management. if sofware components interacts subject to fault.

Vertx provides fault management via

1.CircuiteBreaker
2.Resilience4j - third party
3.Rx Programming apis
.............................................................................................
		How to integrate Reactive Principles in Programming languages


Reactive Princples  started implementation in Microsoft by Erik Meijer. who created /implemented reactive priciples in c#(.net platform), after that Netflix started implementing the same idea using Java Language.

Reactive Framework /Extensions on Programming language:
........................................................
https://reactivex.io/languages.html
1..net   -rx.net
2.java  - rxjava

https://akka.io/
AKKA
.............................................................................................

How to write reactive programming in java?

All Reactive Programming uses three principles

1.Observable Design pattern - Used to design event driven model.

2.Iterator design pattern -  used to pull and push data async/sync

3.Functional style patterns(pure functions/immutablity)

.............................................................................................

Java and Reactive Programming implementation

1.Rxjava
2.Project Reactor - Spring Boot
3.Mutiny  - RedHat, used in side Quarkus and vertx
.............................................................................................

How to write Rxjava programming?

<dependency>
  <groupId>io.reactivex.rxjava3</groupId>
  <artifactId>rxjava</artifactId>
  <version>3.1.3</version>
</dependency>


Core Concepts;

1.Publisher /Callee/Provider
  Who sends data based evt driven programming
  Publishers emits Event.
Event types:
 1.data event - onData
     is triggered when data is ready to sent
 2.error event - onError
     is trigger when some execption occurs during streaming
 3.complete event -onComplete
     is triggered if no more events are emitted.

2.Subscriber/Callee/Listener
  
   Who listens for events(data,error,complete).
   What ever events are emitted,Subscriber invokes a callback function, process the events.

3.Stream
    Flow of data /sequenence of data from publisher to subscriber.
   
4.Operators
    Apis/methods for creating stream,sending events,processing events.

5.back pressure(Reactive Streams spec).

1.Publisher /Callee/Provider && Subscriber
  Both are java objects only.

Rxjava Provides different varients of publisher.

1.Observable
2.Subject
3.Single
4.Maybe
5.Completeable
6.Flowable

How to stream data?
package com.unisys.rx;

import io.reactivex.rxjava3.core.Observable;

public class FirstPublisher {
    public static Observable<String> publishMessage() {
        return Observable.create(subscriber -> {
            System.out.println();
            //push data to the subscriber
            subscriber.onNext("Hello"); //
            subscriber.onNext("How are you");
            subscriber.onNext("Welcome");
            subscriber.onError(new RuntimeException("oops!"));
            subscriber.onNext("Goodbye");
            //no more data
            subscriber.onComplete();
        });
    }

    public static void main(String[] args) {
        //caller - Subscriber
        publishMessage().subscribe(onNext -> {
            System.out.println(onNext);
        }, onError -> {
            System.out.println(onError);
        }, () -> {
            System.out.println("Stream is over");
        });
    }
}
..............................................................................................

Transformation:
package com.unisys.rx;

import io.reactivex.rxjava3.core.Observable;

public class TransformingObservable {
    public static Observable<String> publishMessage() {
        return  Observable.create(subscriber -> {
            //push data to the subscriber
            subscriber.onNext("Hello"); //
            subscriber.onNext("How are you");
            subscriber.onNext("Welcome");
            subscriber.onNext("Goodbye");
            //no more data
            subscriber.onComplete();
        }).map(item -> {
            return item.toString().toUpperCase();
        });


}

    public static void main(String[] args) {
        //caller - Subscriber
        publishMessage().subscribe(onNext -> {
            System.out.println(onNext);
        }, onError -> {
            System.out.println(onError);
        }, () -> {
            System.out.println("Stream is over");
        });
    }
}
...........................................................................................

Data Sources and Streaming:

I have an array, List, sequence of numbers , how to stream them.

Observable provides factory api to stream particular type of data source.

for sequence of items

package com.unisys.rx;

import io.reactivex.rxjava3.core.Observable;

import java.util.List;

public class DataSourcePublisher {
    public static Observable<Integer> publishNumbers() {
        return Observable.just(1, 2, 3, 4, 5, 6)
                .map(DataSourcePublisher::doubleIt)
                .filter(DataSourcePublisher::isEven);
    }

    //publish numbers 1 to 100
    public static Observable<Integer> publishLongNumbers() {
        return Observable.range(1, 100)
                .filter(DataSourcePublisher::isEven);
    }

    //publish array of items
    public static Observable<Integer> publishArrayOfItems() {
        Integer[] array = {1, 2, 3, 4, 5};
        return Observable.fromArray(array);
    }

    public static Observable<Integer> publishListofItems() {
        List<Integer> list = List.of(1, 2, 3, 4, 5);
        return Observable.fromIterable(list);
    }

    public static void main(String[] args) {
        //sequence of numbers
//        publishNumbers().subscribe(System.out::println, System.out::println, () -> {
//            System.out.println("Stream over");
//        });
//        publishLongNumbers().subscribe(System.out::println, System.out::println, () -> {
//            System.out.println("Stream over");
//        });
        publishArrayOfItems().subscribe(System.out::println, System.out::println, () -> {
            System.out.println("Stream over");
        });
        publishListofItems().subscribe(System.out::println, System.out::println, () -> {
            System.out.println("Stream over");
        });
    }

    private static Integer doubleIt(Integer item) {
        return item * 2;
    }

    private static boolean isEven(Integer item) {
        return item % 2 == 0;
    }
}
..............................................................................................
1.Single
2.Maybe
3.Completeable

Streo types :
 Bean
   -Component,Service,Repository,Controller

Rx java Streo Types:
...................
Observable - o---n 
Single - only item
Maybe - single or empty
Completeable - only complete


Single:
......
RxJava (and its derivatives like RxGroovy & RxScala) has developed an Observable variant called “Single.”

A Single is something like an Observable, but instead of emitting a series of values — anywhere from none at all to an infinite number — it always either emits one value or an error notification.

    public static void singleType() {
        Single.create(emitter -> {
            emitter.onSuccess("Hello");
        }).subscribe(System.out::println);

        Single.create(emitter -> {
            emitter.onError(new RuntimeException("error"));
        }) .subscribe(System.out::println, System.out::println);

         Single.just(1).subscribe(System.out::println);
    }


Single 

package com.unisys.rx;

import io.reactivex.rxjava3.core.Observable;
import io.reactivex.rxjava3.core.Single;

public class SingleItemPublisher {
    //publish single item
    public static Single<Integer> publishSingleItem(){
        return Single.just(1);
        
    }
    public static void main(String[] args) {
        publishSingleItem().subscribe(System.out::println);
    }
}

Completeable:

only signal

public static void completeTest() {
        Completable.complete().subscribe(() -> System.out.println("Completeable"));
    }

package com.unisys.rx;

import io.reactivex.rxjava3.core.Completable;

public class CompleteablePublisher {
    public static void main(String[] args) {
        Completable.complete().subscribe(() -> System.out.println("Completeable"));
    }
}
..............................................................................................
				 Flowable

Reactive manifesto
ReactiveX.io

Reactive Streams Spec
Reactive Streams is an initiative to provide a standard for asynchronous stream processing with non-blocking back pressure

Reactive Streams:

It is spec.

Back Pressure:

Upstream is faster enough to stream data to downstream , where downstream is unable to process data.
   -Back Pressure.

When back pressure happens , 
  -data loss
  -data inconsisistency


How to manage backpressure?
we have various patterns

Rxjava 1.x 
 -Through backpressure operators
Buffer
Sample
Debounce
Window
filter
.....
backpressure operators
 strategies for coping with Observables that produce items more rapidly than their observers consume them


1.Via Operators:

Most of the Flitering Operaors are back pressure managed operators

 debounce,distinct,ElementAt,filter,first,ignoreElements,Last,sample,skip,skipLast,take,takeLast.

During backpressure, items may be droped
 drop operators: fliter
 collecting operators: window,buffer


2.Reactive Pull
..............
Above two strategies manage backpressure by dropping items, if your application need to process all the items emitted by source observable then you can’t use those strategies.

In this scenario, using reactive pull strategy is the right choice. In reactive pull, subscriber requests required number of items from observable by calling request().


Reactive Pull:

 Reactive programs supports push paradigm
 Reactive programs supports even pull also


PUSH + PULL = Reactive PULL

Down Stream can control up stream with help of mediator object that is called
"Subscription object"

DownStream --------Subscription ---------UpStream

DownStream --------Subscription ---------UpStream
                        |
                 request(no-elements)

Reactive Streams:
.................
   Reactive Stream is spec published to enable backpressure and create Back Pressure streams.-https://www.reactive-streams.org/

How provide backPressure handling feature at api level or Publisher level?

Soultion : Publisher level, in order to provide publisher , Many companies joined together

who published another spec "Reactive Stream"

Reactive Streams is an initiative to provide a standard for asynchronous stream processing with non-blocking back pressure. This encompasses efforts aimed at runtime environments (JVM and JavaScript) as well as network protocols.



The Team provided common spec:

1.Publisher
2.Subscriber
3.Subscription
4.Processor


Flowable vs Observable

Flowable 
  emits 0...n items
  backpressure ready streams
  implements reactive stream spec

Observable
  emits 0..n items
  no backpressure
  no reactive stream stream spec.


package com.unisys.rx;

import io.reactivex.rxjava3.core.Flowable;
import io.reactivex.rxjava3.core.Observable;

public class ReactiveStreams {
    static void sleep(long milliseconds) {
        try {
            Thread.sleep(milliseconds);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) {
        Flowable.range(1, 999_999_999)
                .map(MyItem::new) //upstream is fast enough to send data
                .subscribe(myItem -> {
                    sleep(500); //down stream/subscriber are slow
                    System.out.println("Received MyItem " +
                            myItem.id);
                });
        sleep(Long.MAX_VALUE);
    }

    static final class MyItem {
        final int id;

        MyItem(int id) {
            this.id = id;
            System.out.println("Consuming myitem " + id);
        }
    }

}
.....................................................................................................

Vertx and Rxjava ;

Vertx provides reactive programming via vertx-rx 

<dependency>
 <groupId>io.vertx</groupId>
 <artifactId>vertx-rx-java3</artifactId>
 <version>4.2.4</version>
</dependency>

vertx provides high level abstraction on rxjava apis.

Vertx provides rxjava version of every object in vertx.

AbstractVerticle - io.vertx.core.AbstractVerticle
Reactive Version:
AbstractVerticle - 



package com.unisys.rx;

import io.reactivex.rxjava3.core.Single;
import io.vertx.core.Promise;
import io.vertx.example.util.Runner;
import io.vertx.rxjava3.core.AbstractVerticle;
import io.vertx.rxjava3.core.eventbus.EventBus;
import io.vertx.rxjava3.core.http.HttpServer;
import io.vertx.rxjava3.ext.web.client.HttpResponse;
import io.vertx.rxjava3.ext.web.client.WebClient;
import io.vertx.rxjava3.ext.web.codec.BodyCodec;

class ReactiveWebClient extends AbstractVerticle {

  @Override
  public void start(Promise<Void> startFuture) throws Exception {
    super.start(startFuture);
    vertx.createHttpServer().requestHandler(req -> {
      WebClient webClient = WebClient.create(vertx);
      Single<HttpResponse<String>> request = webClient.get(8081, "localhost", "/").as(BodyCodec.string()).rxSend();
      //fire the http call
      request.subscribe(result -> {
        req.response().end(result.body());
      });
    }).rxListen(3000).subscribe();
  }
}


class GreeterReactive extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startFuture) throws Exception {
    super.start(startFuture);
    //reactive web server
    EventBus eventBus = vertx.eventBus();

    eventBus.consumer("com.unisys").toFlowable().subscribe(message -> {
      System.out.println(message.body().toString());
      message.reply("PONG");
    });
    vertx.setPeriodic(1000, v -> {
      eventBus.rxRequest("com.unisys", "PING").subscribe(reply -> {
        System.out.println("Received Reply " + reply.body());
      });
    });

    //This is not enabled with Reactive Streams
//    vertx.createHttpServer().requestHandler(httpServerRequest -> {
//      httpServerRequest.response().end("Hello");
//
//    }).rxListen(8080).subscribe();
    HttpServer httpServer = vertx.createHttpServer();
    httpServer.requestStream().toFlowable().subscribe(req -> {
      req.response().end("Stream data over http using web client");
    });
    httpServer.rxListen(8081).subscribe(System.out::println);


  }
}

public class ReactiveVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(ReactiveVerticle.class);
  }

  @Override
  public void start(Promise<Void> startFuture) throws Exception {
    super.start(startFuture);
    vertx.rxDeployVerticle(new GreeterReactive())
      .subscribe(data -> System.out.println(data), System.out::println);
    vertx.deployVerticle(new ReactiveWebClient());
  }
}

........................................................................................................
					Distrubuted Vertx
........................................................................................................

Vertx Types:
...........

1.Standard Vertx
2.Clustered Vertx

Distributed Architecture: Microservices
.......................................


Verticle Communication:
......................

1.Within Process : 

  Within single Vertx

2.among Vertx Engines

Vertx - Clustering:
...................

Clustering , means organization application under one communication channel.

Vertx uses integration/clustering technologies.

Vertx uses hazelcast ClusterManager/provider by default.

Cluster : group of something - group of verticles/vertx instance/jvm

in order to connect vertx apps across processes, we need cordinator 
-Bride softwares

Vertx can work with
-hazelcast
-apache zookeeper
-apache ignite
-apache Infinispan

ClusterManagers

by default, vertx has hazelcast, we dont need to configure by default.

How to enable clustering?

In vertx clustering can be enabled in two ways

1.through code

Vertx Configuration;

Types of vertx:
1.standard vertx
2.clusteredVertx

Vertx.createClusteredVertx()



ClusterManager mgr = new HazelcastClusterManager();

VertxOptions options = new VertxOptions().setClusterManager(mgr);

Vertx.clusteredVertx(options, res -> {
  if (res.succeeded()) {
    Vertx vertx = res.result();

  } else {
    // failed!
  }
});

..............................................................................................
			Scalability : How to run multiple instance of the same service
.............................................................................................
package com.unisys.distributed.scalling;

import io.vertx.rxjava3.core.AbstractVerticle;
import io.vertx.rxjava3.core.http.HttpServer;

//SCALE THIS Service into multiple instances
public class GreeterService extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();
    HttpServer httpServer = vertx.createHttpServer();
    httpServer.requestStream().toFlowable().subscribe(req -> {
      req.response().end("Hello!How are you : " + Thread.currentThread().getName() + " =>" + hashCode());
    });
    httpServer.rxListen(3000).subscribe(onSuccess -> {
      System.out.println("Server is Running on " + onSuccess.actualPort());
    });
  }
}

package com.unisys.distributed.scalling;

import io.vertx.core.DeploymentOptions;
import io.vertx.core.Promise;
import io.vertx.example.util.Runner;
import io.vertx.rxjava3.core.AbstractVerticle;


public class ScallerDeployer extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(ScallerDeployer.class);
  }

  @Override
  public void start(Promise<Void> startFuture) throws Exception {
    super.start(startFuture);
    DeploymentOptions options = new DeploymentOptions().setInstances(5);

    vertx.rxDeployVerticle(GreeterService.class.getName(), options).subscribe(res -> {
      System.out.println(GreeterService.class.getName() + " " + res);
    }, err -> {
      System.out.println(err);
    });
  }
}


Try to test :
with chrome
http://localhost:3000/
Hello!How are you : vert.x-eventloop-thread-3 =>703670605

and again with other client -postman
http://localhost:3000/

Hello!How are you : vert.x-eventloop-thread-5 =>94658234

............................................................................................
			Clustering : How to communicate across vertx Engine
			         (Scallablity + High availablity)
............................................................................................

Vertx Configuration;

Types of vertx:
1.standard vertx
2.clusteredVertx

ClusterManager mgr = new HazelcastClusterManager();

VertxOptions options = new VertxOptions().setClusterManager(mgr);

Vertx.clusteredVertx(options, res -> {
  if (res.succeeded()) {
    Vertx vertx = res.result();
    //deployment
  } else {
    // failed!
  }
});

Configuring cluster manager:

Vertx provides default-cluster.xml which is packaged inside cluster jar.

if you want to override you can override cluster.xml file

How to enable cluster feature?

java -jar target/app.jar -cp . -cluster

vertx run verticle -cp . -cluster

via docker
docker run -i -t vertx/vertx4-exec run verticle -cp . -cluster



1.Clustering
   
   We can run multiple vertx applications and each application can communicate each other 
via centeralized cluter channel software(hazelcast,zookeeper,apache ignite).

in order to setup cluster on vertx engine
1.we have to enable via Vertx.clusteredVertx Method.


Demo setup:
we are simulating two verticles running separtely. how we can do that

-need to run two verticles having main method.

Two verticles are exchanging message via event bus (Distributed Event Bus).


ConsumerVerticle
package com.unisys.distributed.cluster;

import io.vertx.core.*;
import io.vertx.core.eventbus.EventBus;
import io.vertx.core.eventbus.MessageConsumer;
import io.vertx.core.spi.cluster.ClusterManager;
import io.vertx.spi.cluster.hazelcast.HazelcastClusterManager;

import java.lang.management.ManagementFactory;
import java.lang.management.RuntimeMXBean;


public class ConsumerVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    ClusterManager mgr = new HazelcastClusterManager();
    VertxOptions options = new VertxOptions().setClusterManager(mgr).setHAEnabled(true).setHAGroup("g1");
    Vertx.clusteredVertx(options, cluster -> {
      if (cluster.succeeded()) {
        //Get the reference of Cluster Powered Vertx Engine
        Vertx vertx = cluster.result();
        //deploy the verticle in cluster.
        DeploymentOptions deploymentOptions = new DeploymentOptions().setInstances(3);
        cluster.result().deployVerticle("com.unisys.distributed.cluster.ConsumerVerticle", deploymentOptions).onSuccess(res -> {
          System.out.println("Deployment Id => " + res);
        }).onFailure(err -> {
          System.out.println(err);
        });
      } else {
        // failed!
        System.out.println("Cluster is failed" + cluster.cause());
      }
    });


  }


  @Override
  public void start(Promise<Void> startFuture) throws Exception {
    super.start(startFuture);
    System.out.println("started");
    EventBus eventBus = vertx.eventBus();
    //Declare Consumer
    MessageConsumer<String> consumer = eventBus.consumer("news.in.covid");
    //handle/process the message/news
    consumer.handler(news -> {
      RuntimeMXBean runtimeBean = ManagementFactory.getRuntimeMXBean();
      String jvmName = runtimeBean.getName();
      System.out.println("Node  Name = " + jvmName);
      long pid = Long.valueOf(jvmName.split("@")[0]);
      System.out.println("PID  = " + pid + " Thread = " + Thread.currentThread().getName());
      System.out.println("News 7's Today News : " + news.body());
    });
  }
}

Please run the above code:
log4j:WARN No appenders could be found for logger (io.vertx.core.logging.LoggerFactory).
log4j:WARN Please initialize the log4j system properly.
log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info.
Feb 06, 2022 4:28:47 PM com.hazelcast.instance.impl.HazelcastInstanceFactory
WARNING: Hazelcast is starting in a Java modular environment (Java 9 and newer) but without proper access to required Java packages. Use additional Java arguments to provide Hazelcast access to Java internal API. The internal API access is used to get the best performance results. Arguments to be used:
 --add-modules java.se --add-exports java.base/jdk.internal.ref=ALL-UNNAMED --add-opens java.base/java.lang=ALL-UNNAMED --add-opens java.base/java.nio=ALL-UNNAMED --add-opens java.base/sun.nio.ch=ALL-UNNAMED --add-opens java.management/sun.management=ALL-UNNAMED --add-opens jdk.management/com.sun.management.internal=ALL-UNNAMED
Feb 06, 2022 4:28:47 PM com.hazelcast.system
INFO: [192.168.0.105]:5702 [dev] [4.2.2] Hazelcast 4.2.2 (20210811 - c38011e) starting at [192.168.0.105]:5702
Feb 06, 2022 4:28:48 PM com.hazelcast.spi.discovery.integration.DiscoveryService
INFO: [192.168.0.105]:5702 [dev] [4.2.2] No discovery strategy is applicable for auto-detection
Feb 06, 2022 4:28:48 PM com.hazelcast.instance.impl.Node
INFO: [192.168.0.105]:5702 [dev] [4.2.2] Using Multicast discovery
Feb 06, 2022 4:28:48 PM com.hazelcast.cp.CPSubsystem
WARNING: [192.168.0.105]:5702 [dev] [4.2.2] CP Subsystem is not enabled. CP data structures will operate in UNSAFE mode! Please note that UNSAFE mode will not provide strong consistency guarantees.
Feb 06, 2022 4:28:48 PM com.hazelcast.internal.diagnostics.Diagnostics
INFO: [192.168.0.105]:5702 [dev] [4.2.2] Diagnostics disabled. To enable add -Dhazelcast.diagnostics.enabled=true to the JVM arguments.
Feb 06, 2022 4:28:48 PM com.hazelcast.core.LifecycleService
INFO: [192.168.0.105]:5702 [dev] [4.2.2] [192.168.0.105]:5702 is STARTING
WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.hazelcast.internal.networking.nio.SelectorOptimizer (file:/C:/Users/sasub/.m2/repository/com/hazelcast/hazelcast/4.2.2/hazelcast-4.2.2.jar) to field sun.nio.ch.SelectorImpl.selectedKeys
WARNING: Please consider reporting this to the maintainers of com.hazelcast.internal.networking.nio.SelectorOptimizer
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
Feb 06, 2022 4:28:49 PM com.hazelcast.internal.cluster.impl.MulticastJoiner
INFO: [192.168.0.105]:5702 [dev] [4.2.2] Trying to join to discovered node: [192.168.0.105]:5701
Feb 06, 2022 4:28:49 PM com.hazelcast.internal.server.tcp.TcpServerConnection
INFO: [192.168.0.105]:5702 [dev] [4.2.2] Initialized new cluster connection between /192.168.0.105:64429 and /192.168.0.105:5701
Feb 06, 2022 4:28:55 PM com.hazelcast.internal.cluster.ClusterService
INFO: [192.168.0.105]:5702 [dev] [4.2.2] 

Members {size:2, ver:2} [
	Member [192.168.0.105]:5701 - bd057b19-0e66-431c-93ee-1c07194f13c4
	Member [192.168.0.105]:5702 - ee414cdf-d3e2-4049-83ef-e95f527c5540 this
]

Feb 06, 2022 4:28:56 PM com.hazelcast.core.LifecycleService
INFO: [192.168.0.105]:5702 [dev] [4.2.2] [192.168.0.105]:5702 is STARTED
started
started
started
Deployment Id => c2c972d6-43f6-4553-97e5-ef31de3e6f82
Node  Name = 7976@LAPTOP-R2TGGFDL
Node  Name = 7976@LAPTOP-R2TGGFDL
Node  Name = 7976@LAPTOP-R2TGGFDL
PID  = 7976 Thread = vert.x-eventloop-thread-2
PID  = 7976 Thread = vert.x-eventloop-thread-3
PID  = 7976 Thread = vert.x-eventloop-thread-1
News 7's Today News : Last 24 hrs, 50000 covid patients in India From  11808@LAPTOP-R2TGGFDL
News 7's Today News : Last 24 hrs, 50000 covid patients in India From  11808@LAPTOP-R2TGGFDL
News 7's Today News : Last 24 hrs, 50000 covid patients in India From  11808@LAPTOP-R2TGGFDL
Node  Name = 7976@LAPTOP-R2TGGFDL
PID  = 7976 Thread = vert.x-eventloop-thread-1
Node  Name = 7976@LAPTOP-R2TGGFDL
PID  = 7976 Thread = vert.x-eventloop-thread-2
News 7's Today News : Last 24 hrs, 50000 covid patients in India From  11808@LAPTOP-R2TGGFDL
Node  Name = 7976@LAPTOP-R2TGGFDL
PID  = 7976 Thread = vert.x-eventloop-thread-3
News 7's Today News : Last 24 hrs, 50000 covid patients in India From  11808@LAPTOP-R2TGGFDL
News 7's Today News : Last 24 hrs, 50000 covid patients in India From  11808@LAPTOP-R2TGGFDL
Node  Name = 7976@LAPTOP-R2TGGFDL
Node  Name = 7976@LAPTOP-R2TGGFDL
Node  Name = 7976@LAPTOP-R2TGGFDL
PID  = 7976 Thread = vert.x-eventloop-thread-3
PID  = 7976 Thread = vert.x-eventloop-thread-2
News 7's Today News : Last 24 hrs, 50000 covid patients in India From  11808@LAPTOP-R2TGGFDL
PID  = 7976 Thread = vert.x-eventloop-thread-1
News 7's Today News : Last 24 hrs, 50000 covid patients in India From  11808@LAPTOP-R2TGGFDL
Node  Name = 7976@LAPTOP-R2TGGFDL
News 7's Today News : Last 24 hrs, 50000 covid patients in India From  11808@LAPTOP-R2TGGFDL
Node  Name = 7976@LAPTOP-R2TGGFDL
Node  Name = 7976@LAPTOP-R2TGGFDL
PID  = 7976 Thread = vert.x-eventloop-thread-3
PID  = 7976 Thread = vert.x-eventloop-thread-1
PID  = 7976 Thread = vert.x-eventloop-thread-2
News 7's Today News : Last 24 hrs, 50000 covid patients in India From  11808@LAPTOP-R2TGGFDL
News 7's Today News : Last 24 hrs, 50000 covid patients in India From  11808@LAPTOP-R2TGGFDL
News 7's Today News : Last 24 hrs, 50000 covid patients in India From  11808@LAPTOP-R2TGGFDL
Node  Name = 7976@LAPTOP-R2TGGFDL
Node  Name = 7976@LAPTOP-R2TGGFDL
PID  = 7976 Thread = vert.x-eventloop-thread-3
News 7's Today News : Last 24 hrs, 50000 covid patients in India From  11808@LAPTOP-R2TGGFDL
Node  Name = 7976@LAPTOP-R2TGGFDL
Node  Name = 7976@LAPTOP-R2TGGFDL
PID  = 7976 Thread = vert.x-eventloop-thread-2
News 7's Today News : Last 24 hrs, 50000 covid patients in India From  11808@LAPTOP-R2TGGFDL
PID  = 7976 Thread = vert.x-eventloop-thread-3
Node  Name = 7976@LAPTOP-R2TGGFDL
PID  = 7976 Thread = vert.x-eventloop-thread-1
News 7's Today News : Last 24 hrs, 50000 covid patients in India From  11808@LAPTOP-R2TGGFDL
PID  = 7976 Thread = vert.x-eventloop-thread-2
News 7's Today News : Last 24 hrs, 50000 covid patients in India From  11808@LAPTOP-R2TGGFDL
News 7's Today News : Last 24 hrs, 50000 covid patients in India From  11808@LAPTOP-R2TGGFDL
Node  Name = 7976@LAPTOP-R2TGGFDL
PID  = 7976 Thread = vert.x-eventloop-thread-1
News 7's Today News : Last 24 hrs, 50000 covid patients in India From  11808@LAPTOP-R2TGGFDL
Node  Name = 7976@LAPTOP-R2TGGFDL
Node  Name = 7976@LAPTOP-R2TGGFDL
PID  = 7976 Thread = vert.x-eventloop-thread-1
Node  Name = 7976@LAPTOP-R2TGGFDL
PID  = 7976 Thread = vert.x-eventloop-thread-2
News 7's Today News : Last 24 hrs, 50000 covid patients in India From  11808@LAPTOP-R2TGGFDL
PID  = 7976 Thread = vert.x-eventloop-thread-3
Node  Name = 7976@LAPTOP-R2TGGFDL
PID  = 7976 Thread = vert.x-eventloop-thread-1
News 7's Today News : Last 24 hrs, 50000 covid patients in India From  11808@LAPTOP-R2TGGFDL
News 7's Today News : Last 24 hrs, 50000 covid patients in India From  11808@LAPTOP-R2TGGFDL
News 7's Today News : Last 24 hrs, 50000 covid patients in India From  11808@LAPTOP-R2TGGFDL
Node  Name = 7976@LAPTOP-R2TGGFDL



package com.unisys.distributed.cluster;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.DeploymentOptions;
import io.vertx.core.Vertx;
import io.vertx.core.VertxOptions;
import io.vertx.core.spi.cluster.ClusterManager;
import io.vertx.spi.cluster.hazelcast.HazelcastClusterManager;

import java.lang.management.ManagementFactory;
import java.lang.management.RuntimeMXBean;

public class PublisherVerticle extends AbstractVerticle {

  public static void main(String[] args) {
    ClusterManager mgr = new HazelcastClusterManager();
    VertxOptions options = new VertxOptions()
      .setClusterManager(mgr).setHAEnabled(true).setHAGroup("g1");

    Vertx.clusteredVertx(options, vertxAsyncResult -> {
      if (vertxAsyncResult.succeeded()) {
        //deploy verticles on cluster env.
        DeploymentOptions deploymentOptions = new DeploymentOptions()
          .setInstances(2).setHa(true);
        vertxAsyncResult.result().deployVerticle("com.unisys.distributed.cluster.PublisherVerticle", deploymentOptions, res -> {
          if (res.succeeded()) {
            System.out.println("Deployment id is: " + res.result());
          } else {
            System.out.println("Deployment failed!" + res.cause());
          }
        });

      } else {
        System.out.println("Cluster up failed: " + vertxAsyncResult.cause());
      }
    });

  }

  @Override
  public void start() throws Exception {
    super.start();
    RuntimeMXBean runtimeBean = ManagementFactory.getRuntimeMXBean();
    String jvmName = runtimeBean.getName();
    //processid
    long pid = Long.valueOf(jvmName.split("@")[0]);
    vertx.setPeriodic(5000, ar -> {
      System.out.println("PID  = " + pid + " Thread = " + Thread.currentThread().getName());
      //publish message
      String news = "Last 24 hrs, 50000 covid patients in India" + " From  " + jvmName;
      vertx.eventBus().publish("news.in.covid", news);
    });

  }
}


"C:\Program Files\Java\jdk-11.0.11\bin\java.exe" "-javaagent:C:\Program Files\JetBrains\IntelliJ IDEA Community Edition 2020.1.1\lib\idea_rt.jar=64290:C:\Program Files\JetBrains\IntelliJ IDEA Community Edition 2020.1.1\bin" -Dfile.encoding=UTF-8 -classpath E:\session\UniSys\2022\Vertx-training\vertxstarter\target\classes;C:\Users\sasub\.m2\repository\io\vertx\vertx-core\4.2.4\vertx-core-4.2.4.jar;C:\Users\sasub\.m2\repository\io\netty\netty-common\4.1.73.Final\netty-common-4.1.73.Final.jar;C:\Users\sasub\.m2\repository\io\netty\netty-buffer\4.1.73.Final\netty-buffer-4.1.73.Final.jar;C:\Users\sasub\.m2\repository\io\netty\netty-transport\4.1.73.Final\netty-transport-4.1.73.Final.jar;C:\Users\sasub\.m2\repository\io\netty\netty-handler\4.1.73.Final\netty-handler-4.1.73.Final.jar;C:\Users\sasub\.m2\repository\io\netty\netty-codec\4.1.73.Final\netty-codec-4.1.73.Final.jar;C:\Users\sasub\.m2\repository\io\netty\netty-tcnative-classes\2.0.46.Final\netty-tcnative-classes-2.0.46.Final.jar;C:\Users\sasub\.m2\repository\io\netty\netty-handler-proxy\4.1.73.Final\netty-handler-proxy-4.1.73.Final.jar;C:\Users\sasub\.m2\repository\io\netty\netty-codec-socks\4.1.73.Final\netty-codec-socks-4.1.73.Final.jar;C:\Users\sasub\.m2\repository\io\netty\netty-codec-http\4.1.73.Final\netty-codec-http-4.1.73.Final.jar;C:\Users\sasub\.m2\repository\io\netty\netty-codec-http2\4.1.73.Final\netty-codec-http2-4.1.73.Final.jar;C:\Users\sasub\.m2\repository\io\netty\netty-resolver\4.1.73.Final\netty-resolver-4.1.73.Final.jar;C:\Users\sasub\.m2\repository\io\netty\netty-resolver-dns\4.1.73.Final\netty-resolver-dns-4.1.73.Final.jar;C:\Users\sasub\.m2\repository\io\netty\netty-codec-dns\4.1.73.Final\netty-codec-dns-4.1.73.Final.jar;C:\Users\sasub\.m2\repository\com\fasterxml\jackson\core\jackson-core\2.13.1\jackson-core-2.13.1.jar;C:\Users\sasub\.m2\repository\io\vertx\vertx-web\4.2.4\vertx-web-4.2.4.jar;C:\Users\sasub\.m2\repository\io\vertx\vertx-web-common\4.2.4\vertx-web-common-4.2.4.jar;C:\Users\sasub\.m2\repository\io\vertx\vertx-auth-common\4.2.4\vertx-auth-common-4.2.4.jar;C:\Users\sasub\.m2\repository\io\vertx\vertx-bridge-common\4.2.4\vertx-bridge-common-4.2.4.jar;C:\Users\sasub\.m2\repository\io\vertx\vertx-web-client\4.2.4\vertx-web-client-4.2.4.jar;C:\Users\sasub\.m2\repository\io\vertx\vertx-jdbc-client\4.2.4\vertx-jdbc-client-4.2.4.jar;C:\Users\sasub\.m2\repository\io\vertx\vertx-sql-client\4.2.4\vertx-sql-client-4.2.4.jar;C:\Users\sasub\.m2\repository\com\mchange\c3p0\0.9.5.5\c3p0-0.9.5.5.jar;C:\Users\sasub\.m2\repository\com\mchange\mchange-commons-java\0.2.19\mchange-commons-java-0.2.19.jar;C:\Users\sasub\.m2\repository\io\vertx\vertx-config\4.2.4\vertx-config-4.2.4.jar;C:\Users\sasub\.m2\repository\io\vertx\vertx-config-git\4.2.4\vertx-config-git-4.2.4.jar;C:\Users\sasub\.m2\repository\org\eclipse\jgit\org.eclipse.jgit\4.4.1.201607150455-r\org.eclipse.jgit-4.4.1.201607150455-r.jar;C:\Users\sasub\.m2\repository\com\jcraft\jsch\0.1.53\jsch-0.1.53.jar;C:\Users\sasub\.m2\repository\com\googlecode\javaewah\JavaEWAH\0.7.9\JavaEWAH-0.7.9.jar;C:\Users\sasub\.m2\repository\org\apache\httpcomponents\httpclient\4.5.3\httpclient-4.5.3.jar;C:\Users\sasub\.m2\repository\org\apache\httpcomponents\httpcore\4.4.6\httpcore-4.4.6.jar;C:\Users\sasub\.m2\repository\commons-logging\commons-logging\1.1.1\commons-logging-1.1.1.jar;C:\Users\sasub\.m2\repository\commons-codec\commons-codec\1.15\commons-codec-1.15.jar;C:\Users\sasub\.m2\repository\io\vertx\vertx-hazelcast\4.2.4\vertx-hazelcast-4.2.4.jar;C:\Users\sasub\.m2\repository\com\hazelcast\hazelcast\4.2.2\hazelcast-4.2.2.jar;C:\Users\sasub\.m2\repository\io\vertx\vertx-rx-java3\4.2.4\vertx-rx-java3-4.2.4.jar;C:\Users\sasub\.m2\repository\io\vertx\vertx-rx-java3-gen\4.2.4\vertx-rx-java3-gen-4.2.4.jar;C:\Users\sasub\.m2\repository\io\reactivex\rxjava3\rxjava\3.0.13\rxjava-3.0.13.jar;C:\Users\sasub\.m2\repository\org\reactivestreams\reactive-streams\1.0.3\reactive-streams-1.0.3.jar;C:\Users\sasub\.m2\repository\io\vertx\vertx-rx-gen\4.2.4\vertx-rx-gen-4.2.4.jar;C:\Users\sasub\.m2\repository\io\vertx\vertx-codegen\4.2.4\vertx-codegen-4.2.4.jar;C:\Users\sasub\.m2\repository\org\slf4j\slf4j-log4j12\1.7.26\slf4j-log4j12-1.7.26.jar;C:\Users\sasub\.m2\repository\org\slf4j\slf4j-api\1.7.26\slf4j-api-1.7.26.jar;C:\Users\sasub\.m2\repository\log4j\log4j\1.2.17\log4j-1.2.17.jar;C:\Users\sasub\.m2\repository\org\hsqldb\hsqldb\2.3.4\hsqldb-2.3.4.jar com.unisys.distributed.cluster.PublisherVerticle
log4j:WARN No appenders could be found for logger (io.vertx.core.logging.LoggerFactory).
log4j:WARN Please initialize the log4j system properly.
log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info.
Feb 06, 2022 4:28:38 PM com.hazelcast.instance.impl.HazelcastInstanceFactory
WARNING: Hazelcast is starting in a Java modular environment (Java 9 and newer) but without proper access to required Java packages. Use additional Java arguments to provide Hazelcast access to Java internal API. The internal API access is used to get the best performance results. Arguments to be used:
 --add-modules java.se --add-exports java.base/jdk.internal.ref=ALL-UNNAMED --add-opens java.base/java.lang=ALL-UNNAMED --add-opens java.base/java.nio=ALL-UNNAMED --add-opens java.base/sun.nio.ch=ALL-UNNAMED --add-opens java.management/sun.management=ALL-UNNAMED --add-opens jdk.management/com.sun.management.internal=ALL-UNNAMED
Feb 06, 2022 4:28:39 PM com.hazelcast.system
INFO: [192.168.0.105]:5701 [dev] [4.2.2] Hazelcast 4.2.2 (20210811 - c38011e) starting at [192.168.0.105]:5701
Feb 06, 2022 4:28:39 PM com.hazelcast.spi.discovery.integration.DiscoveryService
INFO: [192.168.0.105]:5701 [dev] [4.2.2] No discovery strategy is applicable for auto-detection
Feb 06, 2022 4:28:40 PM com.hazelcast.instance.impl.Node
INFO: [192.168.0.105]:5701 [dev] [4.2.2] Using Multicast discovery
Feb 06, 2022 4:28:40 PM com.hazelcast.cp.CPSubsystem
WARNING: [192.168.0.105]:5701 [dev] [4.2.2] CP Subsystem is not enabled. CP data structures will operate in UNSAFE mode! Please note that UNSAFE mode will not provide strong consistency guarantees.
Feb 06, 2022 4:28:40 PM com.hazelcast.internal.diagnostics.Diagnostics
INFO: [192.168.0.105]:5701 [dev] [4.2.2] Diagnostics disabled. To enable add -Dhazelcast.diagnostics.enabled=true to the JVM arguments.
Feb 06, 2022 4:28:40 PM com.hazelcast.core.LifecycleService
INFO: [192.168.0.105]:5701 [dev] [4.2.2] [192.168.0.105]:5701 is STARTING
WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.hazelcast.internal.networking.nio.SelectorOptimizer (file:/C:/Users/sasub/.m2/repository/com/hazelcast/hazelcast/4.2.2/hazelcast-4.2.2.jar) to field sun.nio.ch.SelectorImpl.selectedKeys
WARNING: Please consider reporting this to the maintainers of com.hazelcast.internal.networking.nio.SelectorOptimizer
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
Feb 06, 2022 4:28:42 PM com.hazelcast.internal.cluster.ClusterService
INFO: [192.168.0.105]:5701 [dev] [4.2.2] 

Members {size:1, ver:1} [
	Member [192.168.0.105]:5701 - bd057b19-0e66-431c-93ee-1c07194f13c4 this
]

Feb 06, 2022 4:28:42 PM com.hazelcast.core.LifecycleService
INFO: [192.168.0.105]:5701 [dev] [4.2.2] [192.168.0.105]:5701 is STARTED
Feb 06, 2022 4:28:43 PM com.hazelcast.internal.partition.impl.PartitionStateManager
INFO: [192.168.0.105]:5701 [dev] [4.2.2] Initializing cluster partition table arrangement...
Deployment id is: bc2c22e3-e23c-481a-a98e-866e365d2e6e
PID  = 11808 Thread = vert.x-eventloop-thread-2
PID  = 11808 Thread = vert.x-eventloop-thread-1
Feb 06, 2022 4:28:49 PM com.hazelcast.internal.server.tcp.TcpServerConnection
INFO: [192.168.0.105]:5701 [dev] [4.2.2] Initialized new cluster connection between /192.168.0.105:5701 and /192.168.0.105:64429
PID  = 11808 Thread = vert.x-eventloop-thread-1
PID  = 11808 Thread = vert.x-eventloop-thread-2
Feb 06, 2022 4:28:55 PM com.hazelcast.internal.cluster.ClusterService
INFO: [192.168.0.105]:5701 [dev] [4.2.2] 

Members {size:2, ver:2} [
	Member [192.168.0.105]:5701 - bd057b19-0e66-431c-93ee-1c07194f13c4 this
	Member [192.168.0.105]:5702 - ee414cdf-d3e2-4049-83ef-e95f527c5540
]

Feb 06, 2022 4:28:55 PM com.hazelcast.internal.partition.InternalPartitionService
INFO: [192.168.0.105]:5701 [dev] [4.2.2] Remaining migration tasks: 1. (repartitionTime=Thu Jan 01 05:30:00 IST 1970, plannedMigrations=0, completedMigrations=0, remainingMigrations=0, totalCompletedMigrations=0)
Feb 06, 2022 4:28:55 PM com.hazelcast.internal.partition.impl.MigrationManager
INFO: [192.168.0.105]:5701 [dev] [4.2.2] Repartitioning cluster data. Migration tasks count: 271
Feb 06, 2022 4:28:55 PM com.hazelcast.internal.partition.impl.MigrationManager
INFO: [192.168.0.105]:5701 [dev] [4.2.2] All migration tasks have been completed. (repartitionTime=Sun Feb 06 16:28:55 IST 2022, plannedMigrations=271, completedMigrations=271, remainingMigrations=0, totalCompletedMigrations=271)
PID  = 11808 Thread = vert.x-eventloop-thread-1
PID  = 11808 Thread = vert.x-eventloop-thread-2
PID  = 11808 Thread = vert.x-eventloop-thread-1
PID  = 11808 Thread = vert.x-eventloop-thread-2
PID  = 11808 Thread = vert.x-eventloop-thread-2
PID  = 11808 Thread = vert.x-eventloop-thread-1
PID  = 11808 Thread = vert.x-eventloop-thread-2
PID  = 11808 Thread = vert.x-eventloop-thread-1
PID  = 11808 Thread = vert.x-eventloop-thread-2
PID  = 11808 Thread = vert.x-eventloop-thread-1
Feb 06, 2022 4:29:21 PM com.hazelcast.internal.server.tcp.TcpServerConnection
WARNING: [192.168.0.105]:5701 [dev] [4.2.2] Connection[id=1, /192.168.0.105:5701->/192.168.0.105:64429, qualifier=null, endpoint=[192.168.0.105]:5702, alive=false, connectionType=MEMBER, planeIndex=0] closed. Reason: Exception in Connection[id=1, /192.168.0.105:5701->/192.168.0.105:64429, qualifier=null, endpoint=[192.168.0.105]:5702, alive=true, connectionType=MEMBER, planeIndex=0], thread=hz.gifted_hypatia.IO.thread-in-0
java.io.IOException: An existing connection was forcibly closed by the remote host
	at java.base/sun.nio.ch.SocketDispatcher.read0(Native Method)
	at java.base/sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:43)
	at java.base/sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:276)
	at java.base/sun.nio.ch.IOUtil.read(IOUtil.java:245)
	at java.base/sun.nio.ch.IOUtil.read(IOUtil.java:223)
	at java.base/sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:358)
	at com.hazelcast.internal.networking.nio.NioInboundPipeline.process(NioInboundPipeline.java:119)
	at com.hazelcast.internal.networking.nio.NioThread.processSelectionKey(NioThread.java:383)
	at com.hazelcast.internal.networking.nio.NioThread.processSelectionKeys(NioThread.java:368)
	at com.hazelcast.internal.networking.nio.NioThread.selectLoop(NioThread.java:294)
	at com.hazelcast.internal.networking.nio.NioThread.executeRun(NioThread.java:249)
	at com.hazelcast.internal.util.executor.HazelcastManagedThread.run(HazelcastManagedThread.java:102)

Feb 06, 2022 4:29:21 PM com.hazelcast.internal.server.tcp.TcpServerConnector
INFO: [192.168.0.105]:5701 [dev] [4.2.2] Connecting to /192.168.0.105:5702, timeout: 10000, bind-any: true
PID  = 11808 Thread = vert.x-eventloop-thread-2
PID  = 11808 Thread = vert.x-eventloop-thread-1
Feb 06, 2022 4:29:23 PM com.hazelcast.internal.server.tcp.TcpServerConnector
INFO: [192.168.0.105]:5701 [dev] [4.2.2] Could not connect to: /192.168.0.105:5702. Reason: IOException[Connection refused: no further information to address /192.168.0.105:5702]
PID  = 11808 Thread = vert.x-eventloop-thread-2
PID  = 11808 Thread = vert.x-eventloop-thread-1
Feb 06, 2022 4:29:30 PM com.hazelcast.internal.server.tcp.TcpServerConnector
INFO: [192.168.0.105]:5701 [dev] [4.2.2] Connecting to /192.168.0.105:5702, timeout: 10000, bind-any: true
Feb 06, 2022 4:29:32 PM com.hazelcast.internal.server.tcp.TcpServerConnector
INFO: [192.168.0.105]:5701 [dev] [4.2.2] Could not connect to: /192.168.0.105:5702. Reason: IOException[Connection refused: no further information to address /192.168.0.105:5702]
Feb 06, 2022 4:29:32 PM com.hazelcast.internal.server.tcp.TcpServerConnector
INFO: [192.168.0.105]:5701 [dev] [4.2.2] Connecting to /192.168.0.105:5702, timeout: 10000, bind-any: true
PID  = 11808 Thread = vert.x-eventloop-thread-2
PID  = 11808 Thread = vert.x-eventloop-thread-1
Feb 06, 2022 4:29:34 PM com.hazelcast.internal.server.tcp.TcpServerConnector
INFO: [192.168.0.105]:5701 [dev] [4.2.2] Could not connect to: /192.168.0.105:5702. Reason: IOException[Connection refused: no further information to address /192.168.0.105:5702]
Feb 06, 2022 4:29:34 PM com.hazelcast.internal.server.tcp.TcpServerConnectionErrorHandler
WARNING: [192.168.0.105]:5701 [dev] [4.2.2] Removing connection to endpoint [192.168.0.105]:5702 Cause => java.io.IOException {Connection refused: no further information to address /192.168.0.105:5702}, Error-Count: 5
Feb 06, 2022 4:29:34 PM com.hazelcast.internal.cluster.impl.MembershipManager
INFO: [192.168.0.105]:5701 [dev] [4.2.2] Removing Member [192.168.0.105]:5702 - ee414cdf-d3e2-4049-83ef-e95f527c5540
Feb 06, 2022 4:29:34 PM com.hazelcast.internal.cluster.ClusterService
INFO: [192.168.0.105]:5701 [dev] [4.2.2] 

Members {size:1, ver:3} [
	Member [192.168.0.105]:5701 - bd057b19-0e66-431c-93ee-1c07194f13c4 this
]

Feb 06, 2022 4:29:34 PM com.hazelcast.transaction.TransactionManagerService
INFO: [192.168.0.105]:5701 [dev] [4.2.2] Committing/rolling-back live transactions of [192.168.0.105]:5702, UUID: ee414cdf-d3e2-4049-83ef-e95f527c5540
Feb 06, 2022 4:29:34 PM com.hazelcast.internal.partition.impl.MigrationManager
INFO: [192.168.0.105]:5701 [dev] [4.2.2] Partition balance is ok, no need to repartition.
PID  = 11808 Thread = vert.x-eventloop-thread-2
PID  = 11808 Thread = vert.x-eventloop-thread-1
PID  = 11808 Thread = vert.x-eventloop-thread-1
PID  = 11808 Thread = vert.x-eventloop-thread-2
PID  = 11808 Thread = vert.x-eventloop-thread-2
PID  = 11808 Thread = vert.x-eventloop-thread-1
PID  = 11808 Thread = vert.x-eventloop-thread-1
PID  = 11808 Thread = vert.x-eventloop-thread-2
............................................................................................
				3.High Avaliablity and Fail-Over
............................................................................................

When we are running vertx in cluster env, there is possiblity of vertx instances may die abruuptly.
The verticle is running in the same vertx engine, we need to move to antoher vertx engines

Rules for fail-over:
1.All vertx engine should be part of cluster
2.All vertx engines should have common "cluster-group-id"
3.Fail over is enabled by killing process only, not ctrl+c or Kill -SIGINT

How to enable fail-over?

via command line

Steps: 

Open cmd  3 command prompt

1.vertx run ConsumerVerticle.java -ha -hagroup g1
2.vertx run PublisherVerticle.java -ha -hagroup g1
3.vertx bare -hagroup g1

via code
    VertxOptions options = new VertxOptions().setClusterManager(mgr)
   .setHAEnabled(true).setHAGroup("g1");


How  to enable auto scalling(means if any one instance dies ,automatically we can redeploy into another instances).

docker run -i -t vertx/vertx4-exec bare -hagroup g1


.............................................................................................

package com.cts.vertx.cluster;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.DeploymentOptions;
import io.vertx.core.Vertx;
import io.vertx.core.VertxOptions;
import io.vertx.core.spi.cluster.ClusterManager;
import io.vertx.spi.cluster.hazelcast.HazelcastClusterManager;

import java.lang.management.ManagementFactory;
import java.lang.management.RuntimeMXBean;

public class PublisherVerticle extends AbstractVerticle {

  public static void main(String[] args) {
    ClusterManager mgr = new HazelcastClusterManager();
    VertxOptions options = new VertxOptions().setClusterManager(mgr).setHAEnabled(true).setHAGroup("g1");

    Vertx.clusteredVertx(options, vertxAsyncResult -> {
      if (vertxAsyncResult.succeeded()) {
        //deploy verticles on cluster env.
        DeploymentOptions deploymentOptions = new DeploymentOptions()
          .setInstances(2).setHa(true);
        vertxAsyncResult.result().deployVerticle("com.cts.vertx.cluster.PublisherVerticle", deploymentOptions, res -> {
          if (res.succeeded()) {
            System.out.println("Deployment id is: " + res.result());
          } else {
            System.out.println("Deployment failed!");
          }
        });

      } else {
        System.out.println("Cluster up failed: " + vertxAsyncResult.cause());
      }
    });

  }

  @Override
  public void start() throws Exception {
    super.start();
    RuntimeMXBean runtimeBean = ManagementFactory.getRuntimeMXBean();
    String jvmName = runtimeBean.getName();
    //processid
    long pid = Long.valueOf(jvmName.split("@")[0]);
    vertx.setPeriodic(5000, ar -> {
      System.out.println("PID  = " + pid + " Thread = " + Thread.currentThread().getName());
      //publish message
      String news = "Last 24 hrs, 50000 covid patients in India" + " From  " + jvmName;
      vertx.eventBus().publish("news.in.covid", news);
    });

  }
}
.............................................................................................
package com.cts.vertx.cluster;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.DeploymentOptions;
import io.vertx.core.Vertx;
import io.vertx.core.VertxOptions;
import io.vertx.core.eventbus.EventBus;
import io.vertx.core.eventbus.MessageConsumer;
import io.vertx.core.spi.cluster.ClusterManager;
import io.vertx.spi.cluster.hazelcast.HazelcastClusterManager;

import java.lang.management.ManagementFactory;
import java.lang.management.RuntimeMXBean;

public class ConsumerVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    ClusterManager mgr = new HazelcastClusterManager();
    VertxOptions options = new VertxOptions().setClusterManager(mgr).setHAEnabled(true).setHAGroup("g1");
    Vertx.clusteredVertx(options, cluster -> {
      if (cluster.succeeded()) {
        DeploymentOptions deploymentOptions = new DeploymentOptions();
        cluster.result().deployVerticle("com.cts.vertx.cluster.ConsumerVerticle", deploymentOptions, res -> {
          if (res.succeeded()) {
            System.out.println("Deployment id is: " + res.result());
          } else {
            System.out.println("Deployment failed!");
          }
        });
      } else {
        System.out.println("Cluster up failed: " + cluster.cause());
      }
    });
  }

  private void consumeNews() {
    EventBus eventBus = vertx.eventBus();
    //Declare Consumer
    MessageConsumer<String> consumer = eventBus.consumer("news.in.covid");
    //handle/process the message/news
    consumer.handler(news -> {
      RuntimeMXBean runtimeBean = ManagementFactory.getRuntimeMXBean();
      String jvmName = runtimeBean.getName();
      System.out.println("Node  Name = " + jvmName);
      long pid = Long.valueOf(jvmName.split("@")[0]);
      System.out.println("PID  = " + pid + " Thread = " + Thread.currentThread().getName());
      System.out.println("News 7's Today News : " + news.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consumeNews();
  }
}

.............................................................................................
Taskkill /PID 12696 /F
.............................................................................................
					Shared Resources



Service Discovery and Registry:
..............................

Lookup server and naming server.

Data Base server which stores 'resources' :  web site address : dns server

Same concept is used in distributed programming/microservices:
-> RMI, EJB,DCOM

Why Service Registry?

 Registry is data base, used to store resources in centralized place.

The programs and applications  are located in networks , so it is difficult to locate/search resources.

Service discovery :

 The process of looking up resources, called service discovery.


Registry Server:
 It is key-value pair database, Where you can store and "lookup"  resources.

What we can store inside Registry Server in vertx?

 Resources:

Types of Resources(Services):
.............................
The services you can register into registry

HTTP Endpoint -HttpEndPoint.createRecord
Event Bus Service -EventBus.createRecord
Message Source
JDBC Data Source
Redis Data Source
MongoDb Data Source

Shared Data / Resource:

 In vertx you can store resources in centrialized place, and you share it across application.

eg: you have one jdbc connection, where you will store connection object, thats where shared data comes into picture.


Shared data architecture is "Service Discovery and Registry"

Implementation:

What you need?

1.Registry server- where you can store all shared resources(httpendpoint,jdbcconnection,eventbus...)

Vertx provides default built in Registry Server:
...............................................
-Key value data structure;
  Map- implementations.

Popular Registry Servers:
.........................
1.eureka server
2.Apache zoo keeper
3.Consule
4.Kubernetes
5.Redis
etc....


Steps:
package com.unisys.distributed.serviceregistry;

import io.vertx.core.AbstractVerticle;

public class HelloRestService extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();
    vertx.createHttpServer().requestHandler(request -> {
      if (request.path().equals("/api/hello")) {
        request.response().end("<h1>Hello! I am coming via Service Discovery<h1>");
      }
    }).listen(3001);
  }
}

Publisher
package com.unisys.distributed.serviceregistry;
import io.vertx.core.AbstractVerticle;
import io.vertx.core.json.JsonObject;
import io.vertx.servicediscovery.Record;
import io.vertx.servicediscovery.ServiceDiscovery;
import io.vertx.servicediscovery.ServiceDiscoveryOptions;
import io.vertx.servicediscovery.types.HttpEndpoint;


public class ServicePublisherVerticle extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();
    //Service Discovery Options
//    ServiceDiscovery.create(vertx)
//      .registerServiceImporter(new ZookeeperServiceImporter()
//        , new JsonObject().put("connection", "127.0.0.1:2181"));
    ServiceDiscoveryOptions discoveryOptions = new ServiceDiscoveryOptions();
    //enable discovery server : apache zoo keeper
    discoveryOptions.setBackendConfiguration(new JsonObject()
      .put("connection", "127.0.0.1:2181")
      .put("ephemeral", true)
      .put("guaranteed", true)
      .put("basePath", "/services/my-backend")
    );
    ServiceDiscovery discovery = ServiceDiscovery.create(vertx, discoveryOptions);

    //Record Creation,Record type is Resource Type;storing webclient Resource into registry
    Record httpEndPointRecord = HttpEndpoint.createRecord("myrecord", "localhost", 3001, "/api/hello");

    //publish: add record into zookeeper
    discovery.publish(httpEndPointRecord, ar -> {
      if (ar.succeeded()) {
        System.out.println("Successfully published ..>>>>" + ar.result().toJson());
      } else {
        System.out.println(" Not Published " + ar.cause());
      }
    });

  }
}

Consumer
package com.unisys.distributed.serviceregistry;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.json.JsonObject;
import io.vertx.ext.web.client.WebClient;
import io.vertx.servicediscovery.ServiceDiscovery;
import io.vertx.servicediscovery.ServiceDiscoveryOptions;
import io.vertx.servicediscovery.types.HttpEndpoint;

public class ServiceConsumerVerticle extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();
    ServiceDiscoveryOptions discoveryOptions = new ServiceDiscoveryOptions();
    //enable discovery server : apache zoo keeper
    discoveryOptions.setBackendConfiguration(new JsonObject()
      .put("connection", "127.0.0.1:2181")
      .put("ephemeral", true)
      .put("guaranteed", true)
      .put("basePath", "/services/my-backend")
    );
    ServiceDiscovery discovery = ServiceDiscovery.create(vertx, discoveryOptions);

    vertx.createHttpServer().requestHandler(req -> {
      HttpEndpoint.getWebClient(discovery, new JsonObject().put("name", "myrecord"), sar -> {
        // get web client
        WebClient webClient = sar.result();
        webClient.get("/api/hello").send(res -> {
          System.out.println("Response is ready!");
          req.response().end(res.result().bodyAsString());
        });
        req.response().endHandler(ar -> {
          //remove /release discovery record
          ServiceDiscovery.releaseServiceObject(discovery, webClient);
        });
      });


    }).listen(3000, ar -> {
      System.out.println("Service Consumer Service ");
    });


  }
}
package com.unisys.distributed.serviceregistry;

import io.vertx.core.Vertx;

public class ServiceDiscoveryMainVerticle {
  public static void main(String[] args) {
    Vertx vertx = Vertx.vertx();
    vertx.deployVerticle(new HelloRestService());
    vertx.deployVerticle(new ServicePublisherVerticle());
    vertx.deployVerticle(new ServiceConsumerVerticle());
  }
}
..............................................................................................
				Resilence - Fault Management
..............................................................................................

Vert.x Provides circuit Breaker is an implementation of Circuit Breaker pattern.

It keeps tracks of number of failures and opens the circuit when a threshold is reached.
optionally fallback is given.

States CB:

1.closed
   -Application is working well
2.open
  -Application is failing
3.Half Open
  -Application is recovering from failures


if cb in open state
 What to do? or how to react for failures.

When cb can open?

 if max failures reached
 if timeout is reached
  

1.Circuit Breaker Configuration.

CircuitBreaker breaker = CircuitBreaker.create("my-circuit-breaker", vertx,
    new CircuitBreakerOptions()
        .setMaxFailures(5) // number of failure before opening the circuit
        .setTimeout(2000) // consider a failure if the operation does not succeed in time
        .setFallbackOnFailure(true) // do we call the fallback on failure
        .setResetTimeout(10000) // time spent in open state before attempting to re-try
);

// ---
// Store the circuit breaker in a field and access it as follows
// ---

breaker.execute(promise -> {
  // some code executing with the breaker
  // the code reports failures or success on the given promise.
  // if this promise is marked as failed, the breaker increased the
  // number of failures
}).onComplete(ar -> {
  // Get the operation result.
});
 


package com.unisys.distributed.faulttolerence;

import io.vertx.circuitbreaker.CircuitBreaker;
import io.vertx.circuitbreaker.CircuitBreakerOptions;
import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.buffer.Buffer;
import io.vertx.ext.web.client.HttpResponse;
import io.vertx.ext.web.client.WebClient;

public class CircuitBreakerPatternVerticle extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    CircuitBreakerOptions options = new CircuitBreakerOptions();
    options.setMaxFailures(2);// no of failures will be allowed , after that , ciruit will open
    options.setTimeout(3000); // consider a failure if the operation does not succeed in time
    options.setFallbackOnFailure(true); // if any failure, should i handle fallback or not
    options.setResetTimeout(5000); // time spent in open state before attempting to retry.

    CircuitBreaker circuitBreaker = CircuitBreaker.create("my-circuit-breaker", vertx, options);
    vertx.createHttpServer().requestHandler(req -> {
      circuitBreaker.executeWithFallback(future -> {
        //risky code
        WebClient client = WebClient.create(vertx);
        client.get(3000, "localhost", "/").send(ar -> {
          // Obtain response
          HttpResponse<Buffer> response = ar.result();
          if (response.statusCode() != 200) {
            future.fail("HTTP error");
          } else {
            future.complete(response.bodyAsString());
          }
        });
      }, v -> {
        // Executed when the circuit is opened
        return "Hello, I am fallback";
      }).onComplete(ar -> {
        // Do something with the result
        if (ar.succeeded()) {
          //System.out.println(ar.result());
          req.response().end(ar.result());
        } else {
          System.out.println(ar.cause());

        }
      });
    }).listen(8080);

  }
}
package com.unisys.distributed.faulttolerence;

import io.vertx.core.AbstractVerticle;

public class SomeService extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();
    vertx.createHttpServer().requestHandler(r -> {
      vertx.setTimer(5000, ar -> {
        r.response().end("I am fine but delayed!");
      });
    }).listen(3000);
  }
}
package com.unisys.distributed.faulttolerence;

import io.vertx.core.Vertx;

public class CBDeployer {
  public static void main(String[] args) {
    Vertx vertx = Vertx.vertx();
    vertx.deployVerticle(new SomeService());
    vertx.deployVerticle(new CircuitBreakerPatternVerticle());
  }
}





























































































