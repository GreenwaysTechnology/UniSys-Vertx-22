					Vertx
..............................................................................................File Descriptor:

-It is data structure(array) which is available in the kernal- having key -value pairs 
 It stores the information about io devices.

-It is created for every process - Per Process 

File Descriptor maps io devices with The application Progams

lets say i have java program runs on jvm.

When ever jvm starts , file descriptor is created and kept for io interaction.

File Descriptor contains two fields
 ------------------------------------
 File Descriptor Entries           File Pointer Reference
     0                                 STDIN    -KEYBOARD Binding
     1                                 STDOUT   -Monitor Binding
     2                                 STDERROR -Monitor Binding
     3                                  ?
     4                                  ?


The first three enteries are created when process bootstraps.

Lets take an eg : i want to read data from the disk file?.

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class CopyBytes {
    public static void main(String[] args) throws IOException {

        FileInputStream in = null;
        FileOutputStream out = null;

        try {
            in = new FileInputStream("xanadu.txt");
            out = new FileOutputStream("outagain.txt");
            int c;

            while ((c = in.read()) != -1) {
                out.write(c);
            }
        } finally {
            if (in != null) {
                in.close();
            }
            if (out != null) {
                out.close();
            }
        }
    }
}

In this program, when application calls "in.read()"
    ----------------->JVM invokes system call(api written in c language)------|os keneral
                      -->It will add an entry into file descriptor table and binds the disk file location
 
  
File Descriptor contains two fields
 ------------------------------------
 File Descriptor Entries           File Pointer Reference
     0                                 STDIN    -KEYBOARD Binding
     1                                 STDOUT   -Monitor Binding
     2                                 STDERROR -Monitor Binding
     3                                 HD------------->bINDING HARDDRIVE
     4                                 NETWORK -----|NEC BINDING
.............................................................................................
				Multi threading and IO Models
............................................................................................

Every modern process(JVM) is multi threaded.
Each thread can be created and assigned for an io operations : concurrent io /parrell io.
Every thread is blocked/freezed until data is ready from io channels.

Based this idea only web servers were designed : Multi threading and io.

In web , there is programming model request(read)-response(write)(Network IO) model

Client--------------------IO Channel------------------------Server

Server Design:
..............

Every Web server is multi threaded -tomcat.

When ever a new request(io request) is arrived, Tomcat(Server) creates/assigns "a thread"
............................................................................................
C10K Problem:
.............
The C10k problem is the problem of optimizing network sockets to handle a large number of clients at the same time.

 1000 REQ = 1000 Threads - This is Problem

 More Req ==Minimum number of Threads

Why? What is problem of Threading:

if i create thread
 -memory allocation 
 -managing life cycle of threads

if thread is created , requests kernal for data, if the data not ready.

if data is not ready during that time thread is waiting(blocking)/blocked 
lets say , thread has created it is waiting for 1ms for data. this 1ms during that thread is useless, can be used by any one.

The cpu, will pause the unused thread for 1ms, if data is ready again it will activate-This process is called context switch.
.............................................................................................
				How to build efficient network io apps
.............................................................................................

Before 2000, all programming languages used blocking io apis by default,even today all programming langugages blocking io apis.

C10K problem and its solution:

Every os has blocking api only.

After 2000, First,Linux introduced a new api called non blocking io api - "select"

1st Implementation:

 select  + read 

select will add entry , returns control back to process
read will be fired to read data once it is ready in the keneral
............................................................................................

2nd Implementation:

Poll:
.....

Poll is similar to Select -nonblocking,but data is reterived not by calling extra method(read).
Polling is nothing pushing- Data is pushed from the kernal to Application process

select is Pull based - Data is pulled from the kernal.

Even driven Programming , Event driven io. when ever data is ready, poll will start sending signal(event) to application Process, where application process listens for events, once event is given which starts processing that event.

...........................................................................................

3rd Implmentation:

epoll:

->epoll is a framework extended from poll.
->monitoring multiple file descriptors to see if I/O is possible on any of   them. 


Epoll loop:
           for (;;) {
               nfds = epoll_wait(epollfd, events, MAX_EVENTS, -1);
               if (nfds == -1) {
                   perror("epoll_wait");
                   exit(EXIT_FAILURE);
               }

               for (n = 0; n < nfds; ++n) {
                   if (events[n].data.fd == listen_sock) {
                       conn_sock = accept(listen_sock,
                                          (struct sockaddr *) &addr, &addrlen);
                       if (conn_sock == -1) {
                           perror("accept");
                           exit(EXIT_FAILURE);
                       }
                       setnonblocking(conn_sock);
                       ev.events = EPOLLIN | EPOLLET;
                       ev.data.fd = conn_sock;
                       if (epoll_ctl(epollfd, EPOLL_CTL_ADD, conn_sock,
                                   &ev) == -1) {
                           perror("epoll_ctl: conn_sock");
                           exit(EXIT_FAILURE);
                       }
                   } else {
                       do_use_fd(events[n].data.fd);
                   }
               }


Epoll runs a loop indefintly for io operations(network io), when ever data is ready which emits event to the process.

When operating systems supports non blocking infrastructure, language and runtimes should support that
The first non blocking implemention was nginx web server - the first c10k solution

flollwed by nginx "2008" -  Node.js- Non blocking soultion.
..............................................................................................
.............................................................................................
				Vertx Inspired from Node.js
............................................................................................

In node there is only one event loop thread, who process events from kernal.

Vertx added more threads to process events.

Vertx implements c10K problem solution on JVM
   -Limited threads but max concurrency
   -Non blocking io apis 

Vertx by default maintains threads based Number of cup cores

i have 12 core, each core -2 threads
 
 12*2 = 24 threads

                   24 threads now can handle XXXX no  Requests
...........................................................................................
...........................................................................................
			   Vertx Core Concepts
		Vertx helps to build 100% scalable non blocking + reactive applications
..............................................................................................

Reactive - Data Streaming
Nonblocking/Async -  Thread Management and processing events
..............................................................................................

Lets Code:

1.Vertx Instance -Vertx Engine
2.Verticals 
3.Event Bus
..............................................&&&&&&&&&&&&&&&&&.............................

How to setup vertx project

vertx supports

1.maven
2.gradle

project can be simple 

1.normal java project
2.standard mvn project
3.vertx project from https://start.vertx.io/


How to run Vertx Project?

Vertx application will have entry Point , configured in general pom.xml

<main.verticle>com.unisys.MainVerticle</main.verticle>
<launcher.class>io.vertx.core.Launcher</launcher.class>


mvnw clean compile exec:java

=mvnw clean package -  jar file - fat jar /regular
java -jar target/vertxstarter-1.0.0-SNAPSHOT-fat.jar
.............................................................................................
					Vertx Engine/Runtime
.............................................................................................

Vertx Engine is a java class, represented as interface in the vertx.io.core package.

Role of Vertx Engine:

1.To run vertx app
2.To help to access all non blocking infrastructure
  ->HTTP Webserver
  ->TCP Servers
  ->UDP Servers
  ->FS ACCESS
  ->Object interactions via "Event Bus".
  ->CPU Timer access
  ->App deployment and undeployment
  ->Create Shared data.

Vertx Application Components:
............................

In spring Framework apps are collection of objects called "beans".
In Vertx apps are collection of objects called "Verticles".

What is Verticle?

Verticle:
  -It is java object
  -Where we write all non blocking application logics.
  -It can be deployed and undeployed on vertx instance (engine).
  -It is based on design pattern called "Actor-like Model" - based on akka frameworks
  -Verticles are bound to "Event loop " , are processed by event loop threads.

Deployment means "the action of bringing resources into effective action." - allocating resource for use.

Deployment Resources for a Verticle:

1.Assign/bound a event loop thread to a verticle.

..............................................................................................
How to vertx Program?

Ways 

1. via main method
package com.unisys;

import io.vertx.core.Vertx;

public class HelloWorldVertx {
  public static void main(String[] args) {
    //Vertx Engine Creation
    Vertx vertx = Vertx.vertx();
    System.out.println(vertx);
    System.out.println(Thread.currentThread().getName());
    //create simple non blocking web server
    vertx.createHttpServer().requestHandler(req -> {
      System.out.println(Thread.currentThread().getName());
      req.response().end("Hello Vertx");
    }).listen(8080);

  }
}

2.via lanucher
<main.verticle>com.unisys.MainVerticle</main.verticle>
<launcher.class>io.vertx.core.Launcher</launcher.class>

io.vertx.core.Launcher;

A main() class that can be used to create Vert.x instance and deploy a verticle, or run a bare Vert.x instance.

This class is used by the vertx command line utility to deploy verticles from the command line. It is extensible as "commands" can be added using the CommandFactory SPI.

mvn compile exec:java


3.via vertx command line utility.
  -vertx 4 has removed external command line tools.

vertx

4.via java jar model

-fat jar / uber jar :
  -embeded application
 appcode + server code

mvn clean package
 
java -jar target/starter-vertx-1.0.0-SNAPSHOT-fat.jar
........................................................................................................

Vertx-Modules:
core
web
reactive
microservices
data
messaging
.......................................................................................................		vertx-core:

-Verticles
-Event loop Threads
-Callback based programming
		

Verticle:
  -It is java object
  -It can be deployed and undeployed on vertx instance (engine).
  -It is based on design pattern called "Actor-like Model" - based on akka frameworks
  -Verticles are bound to "Event loop" , are processed by event loop threads.

Verticle is interface which provides life cycle methods 
  -init
  -start - called when verticle during deployment
  -stop  - called when verticles during undeployment
..............................................................................................

Vertx Objective is to build non blocking io apps -  networks,filesystem,data base.

Vertx Programming styles:

1.Without Verticle

public class HelloWorldVertx {
  public static void main(String[] args) {
    //Vertx Engine Creation
    Vertx vertx = Vertx.vertx();
    System.out.println(vertx);
    System.out.println(Thread.currentThread().getName());
    //create simple non blocking web server
    vertx.createHttpServer().requestHandler(req -> {
      System.out.println(Thread.currentThread().getName());
      req.response().end("Hello Vertx");
    }).listen(8080);

  }
}


2.With Verticle
  Use of verticles with Vert.x is entirely optional, but if you use them they provide an  "actor-like deployment and concurrency model", out of the box.

verticle is  class , if you want to create your own verticle, you need to inherit.

import io.vertx.core.AbstractVerticle;

public class GreetingVerticle extends AbstractVerticle {
  
}

Verticle is interface which provides life cycle methods 
  -init
  -start - called when verticle during deployment
  -stop  - called when verticles during undeployment


................................................................................

Deploying Verticles

Via main Method:
import io.vertx.core.Vertx;

public class GreeterDeployerMain {
  public static void main(String[] args) {
    Vertx vertx = Vertx.vertx();
   //deploy the verticle on vertx engine
//    vertx.deployVerticle(new GreetingVerticle());
    vertx.deployVerticle(GreetingVerticle.class.getName());
    vertx.deployVerticle("com.unisys.GreetVerticle");
    vertx.close();
  }
}

via Verticle itself:

One Verticle can deploy other Verticle.

inside verticle vertx reference is available by default.

Vertx vert=Vertx.vertx(); you dont need to write this code

package com.unisys;

import io.vertx.core.AbstractVerticle;

public class GreeterDeployer extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new GreetingVerticle());
  }
}
..............................................................................................

Via Runner Class;
.................
package com.unisys;

import io.vertx.core.AbstractVerticle;
import io.vertx.example.util.Runner;

public class GreeterDeployer extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(GreeterDeployer.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new GreetingVerticle());
  }
}
.............................................................................................
				Vertx Core Concepts
............................................................................................

.............................................................................................
				Non Blocking Applications
..............................................................................................

Patterns for writting non blockings apps

1.callback style -  traditional
2.reactive style -  streaming

Non blocking apis
1.timer
2.http
3.fs

Callback Style

1.Future
2.Promise

Future:
io.vertx.core.Future

Vertx uses futures to reprsent "Asynchronous" Results

Future is like transport object to transport data between caller and callee in async manner.

 Caller----Future--------Callee

What type of data Future can carry.

 - Success---- |
		--- >Future
 - Failure---- |

AsyncResult<T> :
   Object which has either success data or failure data.
   Used in caller side to capture data which was sent by Callee
..............................................................................................

Use case : How to create Future,encasulate success,failure , how to listen for data?

package com.unisys.futures;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.example.util.Runner;

class FutureTransferVerticle extends AbstractVerticle {

  //method which returns future -  callee
  public Future<String> sayHello() {
//    return Future.future(new Handler<Promise<String>>() {
//      @Override
//      public void handle(Promise<String> stringPromise) {
//        stringPromise.complete("Hello");
//      }
//    });
    //We are returning
    return Future.future(future -> future.complete("Hello"));
  }

  //method which throws error
  public Future<String> createErrorMessage() {
    return Future.future(f -> f.fail("Something went wrong!!"));
  }

  //biz logic which may send success or failure data
  public Future<String> login(String username, String password) {
    return Future.future(handler -> {
      if (username.equals("admin") && password.equals("admin")) {
        handler.complete("Login success");
      } else {
        handler.fail("Login Failed");
      }
    });
  }


  @Override
  public void start() throws Exception {
    super.start();
    //caller
//    createFuture().onComplete(new Handler<AsyncResult<String>>() {
//      @Override
//      public void handle(AsyncResult<String> asyncResult) {
//             if(async.succ) {

//             } else {}
//      }
//    });
    sayHello().onComplete(asyncResult -> {
      if (asyncResult.succeeded()) {
        //read data
        System.out.println(asyncResult.result());
      } else {
        System.out.println(asyncResult.cause().getMessage());
      }
    });
    //listen for error
    createErrorMessage().onComplete(asyncResult -> {
      if (asyncResult.failed()) {
        System.out.println(asyncResult.cause());
      }
    });
    //listen for success or failer
    login("admin", "admin").onComplete(asyncResult -> {
      if (asyncResult.failed()) {
        System.out.println(asyncResult.cause());
      }
      System.out.println(asyncResult.result());
    });
    login("xxx", "xxx").onComplete(asyncResult -> {
      if (asyncResult.failed()) {
        System.out.println(asyncResult.cause());
      } else {
        System.out.println(asyncResult.result());
      }
    });
  }
}


public class FutureVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    System.out.println("deploying...");
    Runner.runExample(FutureVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("deploying...");

    vertx.deployVerticle(new FutureTransferVerticle());
  }
}
..............................................................................................
				Listener Short cuts
..............................................................................................

login().onComplete() -  1
   here handler<AsyncResult> is parameter
login().onSuccess()
login().onFailure()
   here direct data -Handler<T> is parameter

  login("admin", "admin")
      .onSuccess(res -> System.out.println(res))
      .onFailure(err -> System.out.println(err));
    login("admin", "admin")
      .onSuccess(System.out::println)
      .onFailure(System.out::println);
.............................................................................................
				Future Object creation types
............................................................................................


Pattern - 1:

Future.future() - factoryMethod
 public Future<String> login(String username, String password) {
    return Future.future(handler -> {
      if (username.equals("admin") && password.equals("admin")) {
        handler.complete("Login success");
      } else {
        handler.fail("Login Failed");
      }
    });
  }

Pattern - 2:

Future.succeedFuture()
Future.failedFuture()
 
  public Future<String> loginV1(String username, String password) {
    if (username.equals("admin") && password.equals("admin")) {
      return Future.succeededFuture("Login is Successful");
    } else {
      return Future.failedFuture("Login failed");
    }
  }
loginV1("admin", "admin")
      .onSuccess(System.out::println)
      .onFailure(System.out::println);


Pattern - 3, Instead of Returning Future, Pass function as parameter - Higher Order function Pattern

  public void loginV2(String userName, String password, Handler<AsyncResult<String>> aHandler) {
    if (userName.equals("admin") && password.equals("admin")) {
      //encapsulate data
      aHandler.handle(Future.succeededFuture("Login is Successful"));
    } else {
      aHandler.handle(Future.failedFuture("Login failed"));
    }
  }

loginV2("admin", "admin", handler -> {
      if (handler.succeeded()) {
        System.out.println(handler.result());
      } else {
        System.out.println(handler.cause());
      }
    });
..............................................................................................
				Callback Chaining
			        Nested Callbacks
.............................................................................................

Legacy Application flow : object oriented and sync flow
  
dependent operations  , should happen one by one

Object oriented seq work flow /Sync work flow

 1.connect db - connect()
 2.Query results -queryResult()
 3.Formate results -formateResult()
 4.add results into http response stream - write()
 5.send/flush the results to clients - send()

 Connection con=DriverManager.getConnection("connectionstring");
 QueryResult queryres=con.queryResult()
 List<T> results = formatResult(queryres)
 response.write(results)
 reponse.end();

...........................................................................................
How the above task can be done in functional programming ; vertx?


Functional sequential workflow:

 Nested Callback : Callback chaining: functional style

  Handler function is called as callback function

"The out put of one callback is input to the another callback : nested callbacks

   cb1
     --cb2
         -cb3
            --cbN
              --process the result.
.............................................................................................


Use case :

 getUser ----|if data is available
			|	|
			|
			      	 call login method with  output of getUser
                        |
		     if not
			 -error

Note : output of one function will be input to another function.
..............................................................................................
package com.unisys.callback;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.example.util.Runner;

//model
class User {
  private String userName;
  private String password;

  public User(String userName, String password) {
    this.userName = userName;
    this.password = password;
  }

  public String getUserName() {
    return userName;
  }

  public void setUserName(String userName) {
    this.userName = userName;
  }

  public String getPassword() {
    return password;
  }

  public void setPassword(String password) {
    this.password = password;
  }

}

class PageVerticle extends AbstractVerticle {

  //chanining

  //api - getUser - return user Details
  //login - which takes input from the getUser
  private Future<String> getUser() {
    User user = new User("admin", "admin");
//    User user = null;
    if (user != null) {
      return Future.succeededFuture(user.getUserName());
    } else {
      return Future.failedFuture("User not Found");
    }
  }

  //login method
  private Future<String> login(String userName) {
    if (userName.equals("admin")) {
      return Future.succeededFuture("Login Success");
    } else {
      return Future.failedFuture("Login failed");
    }
  }

  //page
  private Future<String> showPage(String status) {
    if (status.equals("Login Success")) {
      return Future.succeededFuture("Welcome to Dashboard");
    } else {
      return Future.failedFuture("Please Retry!");
    }

  }

  @Override

  public void start() throws Exception {
    super.start();
    getUser().onComplete(e -> {
      if (e.succeeded()) {
        System.out.println(e.result());
        //call login method
        login(e.result()).onComplete(loginEvent -> {
          if (loginEvent.succeeded()) {
            System.out.println(loginEvent.result());
            showPage(loginEvent.result()).onComplete(pageEvent -> {
              if (pageEvent.succeeded()) {
                System.out.println(pageEvent.result());
              } else {
                System.out.println(pageEvent.cause());
              }
            });
          } else {
            System.out.println(loginEvent.cause());
          }
        });
      } else {
        System.out.println(e.cause());
      }
    });
  }
}


public class CallbackVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(CallbackVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new PageVerticle());
  }
}
..............................................................................................
				Callback Hell
.............................................................................................

getUser().onComplete(e -> {
      if (e.succeeded()) {
        System.out.println(e.result());
        //call login method
        login(e.result()).onComplete(loginEvent -> {
          if (loginEvent.succeeded()) {
            System.out.println(loginEvent.result());
            showPage(loginEvent.result()).onComplete(pageEvent -> {
              if (pageEvent.succeeded()) {
                System.out.println(pageEvent.result());
              } else {
                System.out.println(pageEvent.cause());
              }
            });
          } else {
            System.out.println(loginEvent.cause());
          }
        });
      } else {
        System.out.println(e.cause());
      }
    });

Look at the above code , ask your self

1.is it easy to understand?
2.is it easy to scale
3.is it easy to maintain

No!

This is called callback hell; The callback hell is way of writing complex callbacks.

can we escape from callback hell problem, how to write better callback based programming?

Yes! 
.................

Refactoring callback chaining code.
//How to refactor this above code
    getUser().onSuccess(user -> {
      System.out.println(user);
      login(user).onSuccess(status -> {
        System.out.println(status);
        showPage(status).onSuccess(page -> {
          System.out.println(page);
        }).onFailure(err -> {
          System.out.println(err);
        });
      }).onFailure(err -> {
        System.out.println(err);
      });
    }).onFailure(err -> {
      System.out.println(err);
    });
.............................................................................................
				Callback Hell Soultion :Future.compose Method

.............................................................................................

f1.and(f2)

package com.unisys.callback;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.example.util.Runner;

//model
class User {
  private String userName;
  private String password;

  public User(String userName, String password) {
    this.userName = userName;
    this.password = password;
  }

  public String getUserName() {
    return userName;
  }

  public void setUserName(String userName) {
    this.userName = userName;
  }

  public String getPassword() {
    return password;
  }

  public void setPassword(String password) {
    this.password = password;
  }

}

class PageVerticle extends AbstractVerticle {

  //chanining

  //api - getUser - return user Details
  //login - which takes input from the getUser
  private Future<String> getUser() {
    System.out.println("Get User is called");
    User user = new User("admin", "admin");
//    User user = null;
    if (user != null) {
      return Future.succeededFuture(user.getUserName());
    } else {
      return Future.failedFuture("User not Found");
    }
  }

  //login method
  private Future<String> login(String userName) {
    System.out.println("login is called");

    if (userName.equals("admin")) {
      return Future.succeededFuture("Login Success");
    } else {
      return Future.failedFuture("Login failed");
    }
  }

  //page
  private Future<String> showPage(String status) {
    System.out.println("ShowPage is called");

    if (status.equals("Login Success")) {
      return Future.succeededFuture("Welcome to Dashboard");
    } else {
      return Future.failedFuture("Please Retry!");
    }

  }

  @Override

  public void start() throws Exception {
    super.start();
//    getUser().onComplete(e -> {
//      if (e.succeeded()) {
//        System.out.println(e.result());
//        //call login method
//        login(e.result()).onComplete(loginEvent -> {
//          if (loginEvent.succeeded()) {
//            System.out.println(loginEvent.result());
//            showPage(loginEvent.result()).onComplete(pageEvent -> {
//              if (pageEvent.succeeded()) {
//                System.out.println(pageEvent.result());
//              } else {
//                System.out.println(pageEvent.cause());
//              }
//            });
//          } else {
//            System.out.println(loginEvent.cause());
//          }
//        });
//      } else {
//        System.out.println(e.cause());
//      }
//    });
//    //How to refactor this above code
//    getUser().onSuccess(user -> {
//      System.out.println(user);
//      login(user).onSuccess(status -> {
//        System.out.println(status);
//        showPage(status).onSuccess(page -> {
//          System.out.println(page);
//        }).onFailure(err -> {
//          System.out.println(err);
//        });
//      }).onFailure(err -> {
//        System.out.println(err);
//      });
//    }).onFailure(err -> {
//      System.out.println(err);
//    });

    //compose method
    System.out.println("Using compose Method");
//    getUser().compose(user -> {
//        System.out.println("Get user is called");
//        return login(user); //Return Future
//      }).compose(status -> {
//        System.out.println("Login is called");
//        return showPage(status);
//      })
//      .onSuccess(s -> {
//        System.out.println("Show page is called");
//        System.out.println(s);
//      }).onFailure(err -> {
//        System.out.println(err);
//      });
    getUser()
      .compose(user -> login(user))
      .compose(status -> showPage(status))
      .onSuccess(s -> {
        System.out.println(s);
      }).onFailure(err -> {
        System.out.println(err);
      });
    getUser()
      .compose(this::login)
      .compose(this::showPage)
      .onSuccess(System.out::println)
      .onFailure(System.out::println);
  }
}


public class CallbackVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(CallbackVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new PageVerticle());
  }
}

..........................................................................................
				Compose Eg
package com.unisys.callback;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.example.util.Runner;

//model
class User {
  private String userName;
  private String password;

  public User(String userName, String password) {
    this.userName = userName;
    this.password = password;
  }

  public String getUserName() {
    return userName;
  }

  public void setUserName(String userName) {
    this.userName = userName;
  }

  public String getPassword() {
    return password;
  }

  public void setPassword(String password) {
    this.password = password;
  }

}

class PageVerticle extends AbstractVerticle {

  //chanining

  //api - getUser - return user Details
  //login - which takes input from the getUser
  private Future<String> getUser() {
    System.out.println("Get User is called");
    User user = new User("admin", "admin");
//    User user = null;
    if (user != null) {
      return Future.succeededFuture(user.getUserName());
    } else {
      return Future.failedFuture("User not Found");
    }
  }

  //login method
  private Future<String> login(String userName) {
    System.out.println("login is called");

    if (userName.equals("admin")) {
      return Future.succeededFuture("Login Success");
    } else {
      return Future.failedFuture("Login failed");
    }
  }

  //page
  private Future<String> showPage(String status) {
    System.out.println("ShowPage is called");

    if (status.equals("Login Success")) {
      return Future.succeededFuture("Welcome to Dashboard");
    } else {
      return Future.failedFuture("Please Retry!");
    }

  }

  @Override

  public void start() throws Exception {
    super.start();
//    getUser().onComplete(e -> {
//      if (e.succeeded()) {
//        System.out.println(e.result());
//        //call login method
//        login(e.result()).onComplete(loginEvent -> {
//          if (loginEvent.succeeded()) {
//            System.out.println(loginEvent.result());
//            showPage(loginEvent.result()).onComplete(pageEvent -> {
//              if (pageEvent.succeeded()) {
//                System.out.println(pageEvent.result());
//              } else {
//                System.out.println(pageEvent.cause());
//              }
//            });
//          } else {
//            System.out.println(loginEvent.cause());
//          }
//        });
//      } else {
//        System.out.println(e.cause());
//      }
//    });
//    //How to refactor this above code
//    getUser().onSuccess(user -> {
//      System.out.println(user);
//      login(user).onSuccess(status -> {
//        System.out.println(status);
//        showPage(status).onSuccess(page -> {
//          System.out.println(page);
//        }).onFailure(err -> {
//          System.out.println(err);
//        });
//      }).onFailure(err -> {
//        System.out.println(err);
//      });
//    }).onFailure(err -> {
//      System.out.println(err);
//    });

    //compose method
    System.out.println("Using compose Method");
//    getUser().compose(user -> {
//        System.out.println("Get user is called");
//        return login(user); //Return Future
//      }).compose(status -> {
//        System.out.println("Login is called");
//        return showPage(status);
//      })
//      .onSuccess(s -> {
//        System.out.println("Show page is called");
//        System.out.println(s);
//      }).onFailure(err -> {
//        System.out.println(err);
//      });
    // "hello".trim().toUpperCase()
    //Future.compose().compose().onSuccess().OnFailure
    getUser()
      .compose(user -> login(user))
      .compose(status -> showPage(status))
      .onSuccess(s -> {
        System.out.println(s);
      }).onFailure(err -> {
        System.out.println(err);
      });
    getUser()
      .compose(this::login)
      .compose(this::showPage)
      .onSuccess(System.out::println)
      .onFailure(System.out::println);
  }
}


public class CallbackVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(CallbackVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new PageVerticle());
  }
}
..............................................................................................
			   .............................................................................................
				Advanced Composition :CompositFuture
.............................................................................................
		
i have three methods

-startDbServer
-startHttpServer
-startConfigServer

After success of all methods only i have to initalize my app, if any one of the server failed
i have to throw error and stop .

Future Coordination:
 Coordination of mutliple futures can be achieved with Vertx futures.

Supports concurrent composition(run serveral async operations in paralle) and sequential composition -chain async operations.

CompositeFuture.all(f1,f2,f3,f4,f5,f6)

-all composition waits until all futures are successful or any one fails.

CompositeFuture.any(f1,f2,f3,f4,f5,f6)
    any composition waits for the succeeded future.

package com.cts.vertx.future;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.CompositeFuture;
import io.vertx.core.Future;
import io.vertx.example.util.Runner;

public class CompositFutureVerticle extends AbstractVerticle {

  public static void main(String[] args) {
    Runner.runExample(CompositFutureVerticle.class);
  }

  public Future<String> startDbServer() {
    System.out.println("Db Server Started");
    return Future.succeededFuture("Db server is up");
  }

  public Future<String> startWebServer() {
    System.out.println("WebServer Server Started");
    //  return Future.succeededFuture("Web server is up");
    return Future.failedFuture("Port is already In Use");
  }

  public Future<String> startConfigServer() {
    System.out.println("Config Server Started");
    return Future.succeededFuture("Config Server is up");
  }

  @Override
  public void start() throws Exception {
    super.start();

    Future<String> dbServer = startDbServer();
    Future<String> webServer = startWebServer();
    Future<String> configServer = startConfigServer();
    //coordinate all servers; make sure every server is ready.
    CompositeFuture.all(dbServer, webServer, configServer).onComplete(ar -> {
      if (ar.succeeded()) {
        System.out.println("All Server is Up");
      } else {
        System.out.println(ar.cause());
      }
    });

  }
}
..............................................................................................
Promises:

Async Wrapper Object : Promise:
...............................

Promise is async abstraction largly promoted by javascript community.

Dont Compare  javascript Promises with Vertx Promises , because both are different.

Promise is "semantically meaningfull abstraction" for handling async results.

Many times developers confuse with java Future and Vertx Future.

Promises can't be processed directly with onComplete/setHandler/OnSuccecc/onFailure apis.

Promises must be converted into Future before processing.


Promise:

package com.unisys.promises;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.example.util.Runner;

class LoginVerticle extends AbstractVerticle {

  //Return Promise, later convert into Future if you want, or any api dirctly uses promises
  public Promise<String> auth(String userName, String password) {
    //create Promise object
    Promise<String> promise = Promise.promise();
    if (userName.equals("admin") && password.equals("admin")) {
      promise.complete("Login success");
    } else {
      promise.fail("Login failed");
    }
    return promise;
  }

  public Future<String> authV1(String userName, String password) {
    //create Promise object
    Promise<String> promise = Promise.promise();
    if (userName.equals("admin") && password.equals("admin")) {
      promise.complete("Login success");
    } else {
      promise.fail("Login failed");
    }
    return promise.future();
  }

  @Override
  public void start() throws Exception {
    super.start();
    //future method will convert promise into Future
    auth("admin", "admin").future()
      .onSuccess(System.out::println)
      .onFailure(System.out::println);

    authV1("admin", "admin")
      .onSuccess(System.out::println)
      .onFailure(System.out::println);
  }
}

public class PromiseVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(PromiseVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new LoginVerticle());
  }
}
............................................................................................
				Verticle Start Method
...........................................................................................


Async Verticle Start and Stop:

Sometimes you want to do something in your verticle start-up which takes some time and you don’t want the verticle to be considered deployed until that happens. For example you might want to start an HTTP server in the start method and propagate the asynchronous result of the server listen method

The way to do it is to implement the asynchronous start method(start method with Promise Arg)
.This version of the method takes a Future(Promise) as a parameter. When the method returns the verticle will not be considered deployed.

Every Verticle will have unique deploymentId, which can be used to unDeploy the verticles

package com.unisys.promises;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.example.util.Runner;

public class DeployHttpVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(DeployHttpVerticle.class);
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);

//        vertx.deployVerticle(new HttpVerticle(), ar -> {
//      if (ar.succeeded()) {
//        System.out.println("Verticle deloyed  : " + ar.result());
//      }
//    });
    vertx.deployVerticle(HttpVerticle.class.getName(), ar -> {
      if (ar.succeeded()) {
        System.out.println(HttpVerticle.class.getName() + " Deployment ID " +  ar.result());
      }
    });
    vertx.deployVerticle(HttpVerticle.class.getName(), ar -> {
      if (ar.succeeded()) {
        System.out.println(HttpVerticle.class.getName() + " Deployment ID " +  ar.result());
      }
    });
  }
}
..............................................................................................
				 Vertx Non Blocking Programming(IO)
..............................................................................................

Vertx provides lot of non blocking apis

1.Timer
2.File System
3.HTTP API


package com.unisys.nonblocking.timers;

import io.vertx.core.*;
import io.vertx.example.util.Runner;

public class TimersVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(TimersVerticle.class);
  }

  private void blockMe(String str) {
    System.out.println(str);
  }

  //  public void delay(long delayTime) {
//    vertx.setTimer(delayTime, handler -> {
//      System.out.println("I am delayed output" + "Timeout is " + delayTime);
//    });
//  }
//  public Future<String> delay(long delayTime) {
//    Future<String> future = Future.future(ar -> {
//      vertx.setTimer(delayTime, handler -> {
//        //System.out.println("I am delayed output" + "Timeout is " + delayTime);
//        String response = "I am delayed output" + "Timeout is " + delayTime;
//      });
//    });
//    //return future;
//
//  }

  public void delay(long delayTime, Handler<AsyncResult<String>> aHandler) {
    vertx.setTimer(delayTime, handler -> {
      String response = "I am delayed output" + "Timeout is " + delayTime;
      aHandler.handle(Future.succeededFuture(response));
    });
  }

  //tick
  public void tick(Handler<AsyncResult<String>> aHandler) {
    long timerId = vertx.setPeriodic(1000, handler -> {
      aHandler.handle(Future.succeededFuture(Math.random() + ""));
    });
    //stop ticking
    vertx.setTimer(10000, stopHandler -> {
      System.out.println("Stop Polling");
      vertx.cancelTimer(timerId);
    });
  }


  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    blockMe("start");
//    delay(5000);
//    delay(3000);
    delay(500, asyncResult -> {
      System.out.println(asyncResult.result());
    });
    tick(res -> {
      System.out.println(res.result());
    });

    blockMe("end");
  }
}
..............................................................................................
				   Data Interchange Formats
..............................................................................................

JSON :
package com.unisys.datainterchange;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;

public class JSONVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(JSONVerticle.class);
  }

  public Future<JsonObject> getUser() {
    JsonObject user = new JsonObject();
    user.put("id", 1);
    user.put("firstName", "Subramanian");
    user.put("lastName", "Murugan");
    return Future.succeededFuture(user);
  }


  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    getUser().onSuccess(user -> {
      System.out.println(user.encodePrettily());
    });
  }
}
.............................................................................................
					Fluent Api /Fluent Patterns
...........................................................................................
Instead of writing multiple lines of code and storing them into mutliple variables. we can chain the apis, finally we can get output, This is sometimes called as builder pattern.
Vertx apis are fully fulent.


package com.unisys.datainterchange;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;

public class JSONVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(JSONVerticle.class);
  }

  public Future<JsonArray> getUser() {
//    JsonObject user = new JsonObject();
//    user.put("id", 1);
//    user.put("firstName", "Subramanian");
//    user.put("lastName", "Murugan");
    //Vertx Flutent Pattern
    JsonObject user = new JsonObject()
      .put("id", 1)
      .put("firstName", "Subramanian")
      .put("lastName", "Murugan")
      .put("address", new JsonObject()
        .put("city", "Coimbatore")
        .put("state", "Tamil Nadu"));

    JsonArray users = new JsonArray()
      .add(user)
      .add(user)
      .add(new JsonObject()
        .put("id", 1)
        .put("firstName", "Subramanian")
        .put("lastName", "Murugan")
        .put("address", new JsonObject()
          .put("city", "Coimbatore")
          .put("state", "Tamil Nadu")));


    return Future.succeededFuture(users);
  }


  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    getUser().onSuccess(user -> {
      System.out.println(user.encodePrettily());
    });
  }
}
..............................................................................................
Merging:
package com.unisys.datainterchange;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;

public class JSONVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(JSONVerticle.class);
  }

  public Future<JsonArray> getUser() {
//    JsonObject user = new JsonObject();
//    user.put("id", 1);
//    user.put("firstName", "Subramanian");
//    user.put("lastName", "Murugan");
    //Vertx Flutent Pattern
    JsonObject skill = new JsonObject().put("skillId", 100).put("skill", "Vertx");

    JsonObject user = new JsonObject()
      .put("id", 1)
      .put("firstName", "Subramanian")
      .put("lastName", "Murugan")
      .mergeIn(skill)
      .put("address", new JsonObject()
        .put("city", "Coimbatore")
        .put("state", "Tamil Nadu"));

    JsonArray users = new JsonArray()
      .add(user)
      .add(user)
      .add(new JsonObject()
        .put("id", 1)
        .put("firstName", "Subramanian")
        .put("lastName", "Murugan")
        .put("address", new JsonObject()
          .put("city", "Coimbatore")
          .put("state", "Tamil Nadu")));


    return Future.succeededFuture(users);
  }


  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    getUser().onSuccess(user -> {
      System.out.println(user.encodePrettily());

    });
  }
}
.............................................................................................
				Non Blocking Network IO Application
.............................................................................................

HTTP Server Application:

=>Vertx provides webserver, you dont need to deploy vertx apps on Tomcat like container.
=>Vertx Webserver is fully non blocking, powered with event loop threads.


vertx.createHttpServer();

package com.unisys.nonblocking.http;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerResponse;
import io.vertx.example.util.Runner;

public class SimpleHTTPVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(SimpleHTTPVerticle.class);
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    //writing http apps
    HttpServer httpServer = vertx.createHttpServer();

    //Your app code : Request and Response Handlers
    httpServer.requestHandler(request -> {
      HttpServerResponse response = request.response();
      response.end("Hello Vertx");
    });
    //start the server
    httpServer.listen(3000, httpServerAsyncResult -> {
      if (httpServerAsyncResult.succeeded()) {
        System.out.println("Server is Up @ " + httpServerAsyncResult.result().actualPort());
      } else {
        System.out.println(httpServerAsyncResult.cause());
      }
    });

  }
}
..............................................................................................

Fluent WebServer:
package com.unisys.nonblocking.http;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.AsyncResult;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerRequest;
import io.vertx.example.util.Runner;

public class FluentHTTPServer extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(FluentHTTPServer.class);
  }

  private static void handle(HttpServerRequest request) {
    request.response().end("Hello Http Server");
  }

  private static void startServer(AsyncResult<HttpServer> httpServerAsyncResult) {
    if (httpServerAsyncResult.succeeded()) {
      System.out.println("Server is Up @ " + httpServerAsyncResult.result().actualPort());
    } else {
      System.out.println(httpServerAsyncResult.cause());
    }
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    //writing http apps
//    vertx.createHttpServer()
//      .requestHandler(request -> request.response().end("Hello Http Server"))
//      .listen(3000, httpServerAsyncResult -> {
//        if (httpServerAsyncResult.succeeded()) {
//          System.out.println("Server is Up @ " + httpServerAsyncResult.result().actualPort());
//        } else {
//          System.out.println(httpServerAsyncResult.cause());
//        }
//      });

    vertx.createHttpServer()
      .requestHandler(FluentHTTPServer::handle)
      .listen(3000, FluentHTTPServer::startServer);

  }
}
.............................................................................................
				  How to write Restfull webservices
..............................................................................................

Web:
  Distributed Information system 

In 1981/82 , Internet was open sourced...

British scientist Tim Berners-Lee invented the World Wide Web while working at CERN in 1989,based on internet.

Internet - network system
Web -software system , helps to transfer information over internet.

1991 - Web started for other biz systems.

1989 -1995 - Static Web- only transfering html.
1995-- till date - dynamic content generation tech -  cgi,j2ee,asp,php..

1998- Ecommerce - How to transfer data/information among biz 

Birth of Web Services:
......................

The Program which sends data /information via internet to other systems not inthe form of html.

2000 -  The data interchange conference held. where many people proposed various data formats
There were more than 30 formates proposed - xml,json,dat,txt,csv.........
At the end "XML" Was choosen. 

Web based on XML format - WebServices using XML - SOAP(protocal designed to transport xml docs over http) Web Service

2005 -  SOAP based webservices started failing due to XML documents.

REST Got introduced -  
  REST Can transport data over http only.
  REST can transport data in different formats -  JSON
  REST modeled based on HTTP verb semantics -  GET,UPDATE,DELETE,PUT.

2008 - SPA  How to build  Userfaces in the client side.
..............................................................................................
				Today Web Technology

API : Application Programming Interface
 entry and exit point of data transmission.
 Unit of Computation.
 API is implemented in many ways

1.REST APIS
2.GraphQL API
3.RPC/RPI api
4.MOM  api 

Client Side - SPAS/Mobile Apps


REST APIS Using Vertx:
......................

Resource:
  The data which need to be returned.

Resource identifier -  URI - "/api/customers/list" - GET 

API Verbs
 GET -  read
 PUT  - update
 DELETE - remove
 POST -  Send data


package com.unisys.nonblocking.http;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpMethod;
import io.vertx.example.util.Runner;

public class SimpleHTTPAPI extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(SimpleHTTPAPI.class);
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    vertx.createHttpServer()
      .requestHandler(request -> {
        //build rest api
        if (request.uri().equals("/api/users") && request.method() == HttpMethod.GET) {
          request.response().setStatusCode(200).end("users-GET");
        }
        if (request.uri().equals("/api/users") && request.method() == HttpMethod.POST) {
          request.response().setStatusCode(200).end("users-POST");
        }
        if (request.uri().equals("/api/users") && request.method() == HttpMethod.PUT) {
          request.response().setStatusCode(200).end("users-PUT");
        }
      })
      .listen(3000,server -> {
        if (server.succeeded()) {
          System.out.println(server.result().actualPort() + " Server is running");
        } else {
          System.out.println(server.cause());
        }
      });


  }
}
I WANT TO build REST End point :


URL - resource mapping
 /api/resource
 
METHOD -  GET ,POST,PUT,DELETE....


  public void buildREST() {
    vertx.createHttpServer().requestHandler(request -> {
      //URL MAPPING AND METHOD MAPPING
      if (request.uri().equals("/api/users") && request.method() == HttpMethod.GET) {
        request.response().setStatusCode(200).end("users-GET");
      }
      if (request.uri().equals("/api/users") && request.method() == HttpMethod.POST) {
        request.response().setStatusCode(200).end("users-POST");
      }
      if (request.uri().equals("/api/users") && request.method() == HttpMethod.PUT) {
        request.response().setStatusCode(200).end("users-PUT");
      }
    }).listen(3000, httpServerAsyncResult -> {
      if (httpServerAsyncResult.succeeded()) {
        System.out.println("server is running at " + httpServerAsyncResult.result().actualPort());
      } else {
        System.out.println("Server has failed to start");
      }
    });
  }

Have a look at the above, notice the drawbacks.

-The developer write all method and resource mapping logic
-There is no proper modularity in build ing apps.

Soultion:

Vertx provides a small framework for abstracting these things
vertx-web

Concepts:

Router:
........
 Router is one the core concepts of vertx-web.
 Its object which maintains zero or more Routes("url mappers")
 Router takes an http request and finds the matching routing for that request.
 Every route has handler which process requests and send responses.


RoutingContext:
   It is container object , from which you can get request and response object.


Use case : Basic routing:

package com.unisys.nonblocking.http.web;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerOptions;
import io.vertx.core.http.HttpServerResponse;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;
import io.vertx.ext.web.Router;

public class SimpleWebAPI extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(SimpleWebAPI.class);
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);

    HttpServerOptions options;
    HttpServer server = vertx.createHttpServer();
//    server.requestHandler(request -> {
//      HttpServerResponse serverResponse = request.response();
//      serverResponse.setStatusCode(200);
//      serverResponse.putHeader("content-type", "application/json");
//      JsonObject greet = new JsonObject().put("message", "Hello");
//      serverResponse.end(greet.encodePrettily());
//    });

    //Router creation
    Router router = Router.router(vertx);
    //route
    router.route().handler(ctx -> {
      HttpServerResponse serverResponse = ctx.response();
      serverResponse.setStatusCode(200);
      serverResponse.putHeader("content-type", "application/json");
      JsonObject greet = new JsonObject().put("message", "Hello Vertx Web");
      serverResponse.end(greet.encodePrettily());
    });

    server.requestHandler(router);
    server.listen(8080);

  }
}
...........................................................................................
					Routers using route method

package com.unisys.nonblocking.http.web;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpMethod;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerOptions;
import io.vertx.core.http.HttpServerResponse;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;
import io.vertx.ext.web.Router;

public class SimpleWebAPI extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(SimpleWebAPI.class);
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);

    HttpServerOptions options;
    HttpServer server = vertx.createHttpServer();
//    server.requestHandler(request -> {
//      HttpServerResponse serverResponse = request.response();
//      serverResponse.setStatusCode(200);
//      serverResponse.putHeader("content-type", "application/json");
//      JsonObject greet = new JsonObject().put("message", "Hello");
//      serverResponse.end(greet.encodePrettily());
//    });

    //Router creation
    Router router = Router.router(vertx);

    //new Route
    router.route(HttpMethod.GET, "/api/hello").handler(ctx -> {
      System.out.println("hello");
      HttpServerResponse serverResponse = ctx.response();
      serverResponse.setStatusCode(200);
      serverResponse.putHeader("content-type", "application/json");
      JsonObject greet = new JsonObject().put("message", "Hello");
      serverResponse.end(greet.encodePrettily());
    });
    router.route(HttpMethod.GET, "/api/hai").handler(ctx -> {
      System.out.println("hai");
      HttpServerResponse serverResponse = ctx.response();
      serverResponse.setStatusCode(200);
      serverResponse.putHeader("content-type", "application/json");
      JsonObject greet = new JsonObject().put("message", "Hai");
      serverResponse.end(greet.encodePrettily());
    });
    //route : wild card pattern  , any route
    router.route().handler(ctx -> {
      HttpServerResponse serverResponse = ctx.response();
      serverResponse.setStatusCode(200);
      serverResponse.putHeader("content-type", "application/json");
      JsonObject greet = new JsonObject().put("message", "Home");
      serverResponse.end(greet.encodePrettily());
    });
    server.requestHandler(router);
    server.listen(8080);

  }
}
............................................................................................
				Path Parameters
............................................................................................
package com.unisys.nonblocking.http.web;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerResponse;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;
import io.vertx.ext.web.Router;

public class RouterVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(RouterVerticle.class);
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    HttpServer server = vertx.createHttpServer();
    //Router creation
    Router router = Router.router(vertx);


    //new Route
    router.get("/api/hello").handler(ctx -> {
      System.out.println("hello");
      HttpServerResponse serverResponse = ctx.response();
      serverResponse.setStatusCode(200);
      serverResponse.putHeader("content-type", "application/json");
      JsonObject greet = new JsonObject().put("message", "Hello");
      serverResponse.end(greet.encodePrettily());
    });
    router.get("/api/hai").handler(ctx -> {
      System.out.println("hai");
      HttpServerResponse serverResponse = ctx.response();
      serverResponse.setStatusCode(200);
      serverResponse.putHeader("content-type", "application/json");
      JsonObject greet = new JsonObject().put("message", "Hai");
      serverResponse.end(greet.encodePrettily());
    });
    router.post("/api/hai").handler(ctx -> {
      System.out.println("hai");
      HttpServerResponse serverResponse = ctx.response();
      serverResponse.setStatusCode(200);
      serverResponse.putHeader("content-type", "application/json");
      JsonObject greet = new JsonObject().put("message", "Hai -POST");
      serverResponse.end(greet.encodePrettily());
    });
//path Parameters: dynamic url  /api/hello/subramanian | Ram | John
    router.get("/api/hello/:whom").handler(ctx -> {
      HttpServerResponse serverResponse = ctx.response();
      //using request object extract path parameters
      String whom = ctx.pathParam("whom");
      serverResponse.setStatusCode(200);
      serverResponse.putHeader("content-type", "application/json");
      JsonObject greet = new JsonObject().put("message", "greet " + whom);
      serverResponse.end(greet.encodePrettily());
    });

    //route : wild card pattern  , any route
    router.route().handler(ctx -> {
      HttpServerResponse serverResponse = ctx.response();
      serverResponse.setStatusCode(200);
      serverResponse.putHeader("content-type", "application/json");
      JsonObject greet = new JsonObject().put("message", "Home");
      serverResponse.end(greet.encodePrettily());
    });
    server.requestHandler(router);
    server.listen(8080);

  }
}
.............................................................................................
				How to read Payload
.............................................................................................


How to read payload?

 router.post("/api/greet").handler(ctx -> {
      HttpServerResponse serverResponse = ctx.response();
      //reading data:
      JsonObject payload = ctx.getBodyAsJson();
      System.out.println(payload.encodePrettily());

      serverResponse.setStatusCode(200);
      serverResponse.putHeader("content-type", "application/json");
      JsonObject greet = new JsonObject().put("message", "Hai -POST");
      serverResponse.end(greet.encodePrettily());
    });

when you run, you will get error like below?

Feb 02, 2022 4:23:37 PM io.vertx.ext.web.RoutingContext
WARNING: BodyHandler in not enabled on this route: RoutingContext.getBodyAsJson() in always be NULL
Feb 02, 2022 4:23:37 PM io.vertx.ext.web.RoutingContext
SEVERE: Unhandled exception in router
java.lang.NullPointerException
	at com.unisys.nonblocking.http.web.RouterVerticle.lambda$start$2(RouterVerticle.java:45)

From the client side we send "json" , json is simple text format, but vertx deals Object

POST /api/greet
{
  "message" : "How are you?"

}

Solution:
    //which enables parsers -  json-  JsonObject

router.route().handler(BodyHandler.create());


router.post("/api/greet").handler(ctx -> {
      HttpServerResponse serverResponse = ctx.response();
      //reading data:
      JsonObject payload = ctx.getBodyAsJson();
      System.out.println(payload.encodePrettily());

      serverResponse.setStatusCode(200);
      serverResponse.putHeader("content-type", "application/json");
      JsonObject greet = new JsonObject().put("message", "Hai -POST");
      serverResponse.end(greet.encodePrettily());
    });
..............................................................................................
package com.unisys.nonblocking.http.web;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerResponse;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.handler.BodyHandler;

public class RouterVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(RouterVerticle.class);
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    HttpServer server = vertx.createHttpServer();
    //Router creation
    Router router = Router.router(vertx);
    //which enables parsers -  json-  JsonObject
    router.route().handler(BodyHandler.create());

    //new Route
    router.get("/api/hello").handler(ctx -> {
      System.out.println("hello");
      HttpServerResponse serverResponse = ctx.response();
      serverResponse.setStatusCode(200);
      serverResponse.putHeader("content-type", "application/json");
      JsonObject greet = new JsonObject().put("message", "Hello");
      serverResponse.end(greet.encodePrettily());
    });
    router.get("/api/hai").handler(ctx -> {
      System.out.println("hai");
      HttpServerResponse serverResponse = ctx.response();
      serverResponse.setStatusCode(200);
      serverResponse.putHeader("content-type", "application/json");
      JsonObject greet = new JsonObject().put("message", "Hai");
      serverResponse.end(greet.encodePrettily());
    });
    router.post("/api/greet").handler(ctx -> {
      HttpServerResponse serverResponse = ctx.response();
      //reading data:
      JsonObject payload = ctx.getBodyAsJson();
      System.out.println(payload.encodePrettily());

      serverResponse.setStatusCode(200);
      serverResponse.putHeader("content-type", "application/json");
      JsonObject greet = new JsonObject().put("message", "Hai -POST");
      serverResponse.end(greet.encodePrettily());
    });
//path Parameters: dynamic url  /api/hello/subramanian | Ram | John
    router.get("/api/hello/:whom").handler(ctx -> {
      HttpServerResponse serverResponse = ctx.response();
      //using request object extract path parameters
      String whom = ctx.pathParam("whom");
      serverResponse.setStatusCode(200);
      serverResponse.putHeader("content-type", "application/json");
      JsonObject greet = new JsonObject().put("message", "greet " + whom);
      serverResponse.end(greet.encodePrettily());
    });


    server.requestHandler(router);
    server.listen(8080);

  }
}
.............................................................................................
				 Query Parameters

.............................................................................................

URL :
http://localhost:8080/api/good?message=eve

   router.get("/api/good").handler(ctx -> {
      List<String> message = ctx.queryParam("message");
      System.out.println(message.size());
      ctx.response().end("good " + message.get(0));
    });

..............................................................................................
				Resource Oriented Routers


Domain Models:

/api/users
   list
   save
   update
   remove

/api/products
  list
  save
  update
  

What if i have more resources and more routes?

ProductRouter - /api/products
UserRouter -  /api/users
Payment Router - /api/payment

server.requestHandler(?);

SubRouters and Main routers

- you can have more subrouters - prodct,user,payment..
-  you can have only one main /app router -  approuter
- that app router only can passed to requestHandler(appRouter).

How to bind /connect app router with subrouter

Router has method called "mountSubRouter"

package com.unisys.nonblocking.http.web;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.RoutingContext;
import io.vertx.ext.web.handler.BodyHandler;

public class ResourceRouters extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(ResourceRouters.class);
  }

  private static void list(RoutingContext ctx) {
    ctx.response().end("Users");
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    //SubRouters
    Router userRouter = Router.router(vertx);
    Router productsRouter = Router.router(vertx);
    Router customerRouter = Router.router(vertx);
    //Main/app router
    Router appRouter = Router.router(vertx);
    //initialize global Parser
    appRouter.route().handler(BodyHandler.create());
    userRouter.get("/list").handler(UserRouter::list);
    userRouter.post("/create").handler(UserRouter::create);
    productsRouter.get("/list").handler(ProductsRouter::list);
    customerRouter.get("/list").handler(CustomersRouter::list);

    //Mount/Bind appRouter with subRouters
    appRouter.mountSubRouter("/api/users", userRouter);
    appRouter.mountSubRouter("/api/products", productsRouter);
    appRouter.mountSubRouter("/api/customers", customerRouter);

    vertx.createHttpServer().requestHandler(appRouter).listen(8080, handler -> {
      if (handler.succeeded()) {
        System.out.println("Webserver is running at " + handler.result().actualPort());
      }
    });


  }

  //inner class
  private static class UserRouter {
    public static void create(RoutingContext ctx) {
      JsonObject user = ctx.getBodyAsJson();
      System.out.println(user.encodePrettily());
      ctx.response().setStatusCode(201).end("User saved");
    }

    public static void list(RoutingContext ctx) {
      ctx.response().setStatusCode(200).end("User list");
    }
  }

  private static class ProductsRouter {
    public static void create(RoutingContext ctx) {
      JsonObject user = ctx.getBodyAsJson();
      System.out.println(user.encodePrettily());
      ctx.response().setStatusCode(201).end("Product saved");
    }

    public static void list(RoutingContext ctx) {
      ctx.response().setStatusCode(200).end("Product list");
    }
  }

  private static class CustomersRouter {
    public static void create(RoutingContext ctx) {
      JsonObject user = ctx.getBodyAsJson();
      System.out.println(user.encodePrettily());
      ctx.response().setStatusCode(201).end("Customers saved");
    }

    public static void list(RoutingContext ctx) {
      ctx.response().setStatusCode(200).end("Customers list");
    }
  }
}
............................................................................................
				Exception Handling
.............................................................................................

If something went wrong how to handle exception and how to send error messages to clients.

router.failureHandler(fRctx->{
  //extract error information
  send error data to client
})

package com.unisys.nonblocking.http.web;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;
import io.vertx.ext.web.Router;

public class WebExceptionVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(WebExceptionVerticle.class);
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    Router userRouter = Router.router(vertx);
    Router appRouter = Router.router(vertx);
    appRouter.mountSubRouter("/api/users", userRouter);

    userRouter.get("/list/:name").handler(ctx -> {
      String name = ctx.pathParam("name");
      if (name.equals("admin")) {
        ctx.response().setStatusCode(200).end("You are valid User");
      } else {
        throw new RuntimeException("You are Invalid User!!!!");
      }
    }).failureHandler(fctx -> {
      int statuCode = fctx.statusCode();
      String message = fctx.failure().getMessage();
      JsonObject jsonObject = new JsonObject().put("code", 100).put("message", message);
      fctx.response().setStatusCode(statuCode).end(jsonObject.encodePrettily());
    });

    vertx.createHttpServer().requestHandler(appRouter).listen(8080, handler -> {
      if (handler.succeeded()) {
        System.out.println("Webserver is running at " + handler.result().actualPort());
      }
    });
  }
}

.............................................................................................

Handlers Type:

router.handler() -  async request handler
router.failureHandler() - async exception/error handler.

Global Handlers:
BodyHandler - converts "json string" into JsonObject
TimeoutHandler - to set Request timeout for given url or global
blockingHandler - For writing blocking code.

.............................................................................................
				Content Negoation
............................................................................................
Rest api can accept and return multiple data formats based on Request from the client.

One Single Rest api can serve data in multiple formats such as  xml,html,pdf,json,text...

package com.unisys.nonblocking.http.web;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.handler.ResponseContentTypeHandler;

public class ContentNegoation extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(ContentNegoation.class);
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    Router userRouter = Router.router(vertx);
    Router appRouter = Router.router(vertx);

    //adding header automatically into response
    appRouter.route().handler(ResponseContentTypeHandler.create());

    appRouter.mountSubRouter("/api/users", userRouter);

    userRouter.get("/")
      .produces("application/json")
      .handler(ctx -> {
        System.out.println(ctx.getAcceptableContentType());
//        if (ctx.getAcceptableContentType().equals("text/plain")) {
//          ctx.response().end("Text content");
//        } else {
//          ctx.response().end(new JsonObject().put("content", "json").encodePrettily());
//        }
        ctx.response().end(new JsonObject().put("content", "json").encodePrettily());
      });

    vertx.createHttpServer().requestHandler(appRouter).listen(8080, handler -> {
      if (handler.succeeded()) {
        System.out.println("Webserver is running at " + handler.result().actualPort());
      }
    });
  }
}
..............................................................................................
				 Verticle(Object) Communications
.............................................................................................

Object Communication Patterns:
=>With in Process(Within JVM) (WithIn Vertx Engine)
=>Across process(Across JVM) (Across Vertx Engine)

With in Process(Within JVM) (WithIn Vertx Engine):

In General java objects talk each other by calling methods on each other.

class OrderController {
   OrderService service
   
  placeOrder(){
    this.service.processOrder()
  }
}

class OrderService{

  processOrder(){
   return 'order data'
 }
}

Vertx:
class OrderPlacerVerticle extends AbstractVerticle {
       
}
               ||
class OrderProviderVerticle extends AbstractVerticle {

}

In Vertx verticles communicate by default "Async /in non blocking".

Verticles Communication Styles:

1.Actor Model Communication Style
  https://doc.akka.io/docs/akka/current/typed/guide/actors-intro.html
2.HTTP communication Style.

Vertx uses loosly coupled communcation style using "Event Bus"  - which is implemenation  of actor like model.


1.message oriented style :Event Bus

Event Bus:

-Event Bus is nerve of vertx systems.

-Vertx By default is distributed

-Vertx carries distributed architecture by default

-In Vertx Verticles can communicate via Centraized Broker which is built in called event Bus.
-Event Bus uses tcp transport layer by default
-EventBus can send and recive data in the form of json and buffer


Event Bus:

1.Event Bus can allow verticles sends data from one place to another place
2.Event Bus forms a distributed peer-to-peer messaging system spannining multiple server nodes   and multiple browers.
3.Event bus allows sending messages in three ways
  1.pub/sub : one to many
  2.point-to-point : one to one
  3.request-reply(reponse) - one to one with acknowlegement.

4.Event bus identifies clients via "addressing"
   Messages are sent on the event bus to an "address"
   Address schemes can be any naming convention, recommendation is dns model "in.news.covid"
   
5.Handlers
   Since vertx is non blocking, messages are processed by handlers.
   You have to register a handler at an address

6.Type of Data
   Data type of message could be any primitive-int,char,boolean,String, Buffer,JSON

   Per Vertx Engine only One Event Bus-singleTon
............................................................................................


How to get Event Bus Object?

EventBus mybus =  vertx.eventBus();

starting send message

mybus.send
mybus.publish
mybus.request
..............................................................................................
				   PUB - SUB
..............................................................................................
package com.unisys.verticle.communication;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.eventbus.EventBus;
import io.vertx.core.eventbus.MessageConsumer;
import io.vertx.example.util.Runner;
import io.vertx.ext.web.Router;

class Address {
  public final static String PUB_SUB_ADDRESS = "news.in.covid";
  public final static String POINT_TO_POINT = "covid.fin.request";
  public final static String REQUEST_REPLY = "covid.lab.report";
}

//http verticle
class CovidCommunicatorVerticle extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    Router appRouter = Router.router(vertx);
    Router broadcastRouter = Router.router(vertx);
    appRouter.mountSubRouter("/api/brodcast", broadcastRouter);
    broadcastRouter.get("/:message").handler(ctx -> {
      //Event Bus to send message to other Verticles
      String message = ctx.pathParam("message");
      EventBus eventBus = vertx.eventBus();
      eventBus.publish(Address.PUB_SUB_ADDRESS, message);
      ctx.response().end("Message has Broad casted");
    });
    vertx.createHttpServer().requestHandler(appRouter).listen(8080, handler -> {
      if (handler.succeeded()) {
        System.out.println("Event Bus Web Server is running at " + handler.result().actualPort());
      }
    });

  }
}

//PUB - SUB Listener
class NewsSevenVerticle extends AbstractVerticle {
  public void consume() {
    //Get the Reference of Event Bus
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> consumer = eventBus.consumer(Address.PUB_SUB_ADDRESS);
    //process the message
    consumer.handler(msg -> {
      System.out.println(this.getClass().getSimpleName() + " => " + msg.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}

class BBCVerticle extends AbstractVerticle {
  public void consume() {
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.PUB_SUB_ADDRESS);
    messageConsumer.handler(message -> {
      System.out.println(this.getClass().getSimpleName() + " => " + message.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}

class NDTVVerticle extends AbstractVerticle {
  public void consume() {
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.PUB_SUB_ADDRESS);
    messageConsumer.handler(message -> {
      System.out.println(this.getClass().getSimpleName() + " => " + message.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}

public class EventBusMainVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(EventBusMainVerticle.class);
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    vertx.deployVerticle(new CovidCommunicatorVerticle());
    vertx.deployVerticle(new NewsSevenVerticle());
    vertx.deployVerticle(new BBCVerticle());
    vertx.deployVerticle(new NDTVVerticle());
  }
}
.............................................................................................
			Point to Point : one to one Communication
............................................................................................
package com.unisys.verticle.communication;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.eventbus.EventBus;
import io.vertx.core.eventbus.MessageConsumer;
import io.vertx.example.util.Runner;
import io.vertx.ext.web.Router;

class Address {
  public final static String PUB_SUB_ADDRESS = "news.in.covid";
  public final static String POINT_TO_POINT = "covid.fin.request";
  public final static String REQUEST_REPLY = "covid.lab.report";
}

///////////////////////////////////////PUB-SUB//////////////////////////////////////////////////////////
class CovidCommunicatorVerticle extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    Router appRouter = Router.router(vertx);
    //pub-sub
    Router broadcastRouter = Router.router(vertx);
    //point to point
    Router pointToPointRouter = Router.router(vertx);

    //Request-Reply
    Router requestReplyRouter = Router.router(vertx);


    appRouter.mountSubRouter("/api/brodcast", broadcastRouter);
    appRouter.mountSubRouter("/api/requestfin", pointToPointRouter);
    appRouter.mountSubRouter("/api/status", requestReplyRouter);


    broadcastRouter.get("/:message").handler(ctx -> {
      //Event Bus to send message to other Verticles
      String message = ctx.pathParam("message");
      EventBus eventBus = vertx.eventBus();
      //publish - one to many
      eventBus.publish(Address.PUB_SUB_ADDRESS, message);
      ctx.response().end("Message has Broad casted");
    });

    pointToPointRouter.get("/:howmuch").handler(ctx -> {
      //Event Bus to send message to other Verticles
      String message = ctx.pathParam("howmuch");
      EventBus eventBus = vertx.eventBus();
      //send - one to one
      eventBus.send(Address.POINT_TO_POINT, message);
      ctx.response().end("Message has been sent");
    });

    requestReplyRouter.get("/:name").handler(ctx -> {
      //Event Bus to send message to other Verticles
      String name = ctx.pathParam("name");
      String messageToSend = "Report of " + name;
      //send message and get reply : request-reply with ack
      vertx.eventBus().request(Address.REQUEST_REPLY, messageToSend, asyncResult -> {
        if (asyncResult.succeeded()) {
          System.out.println(asyncResult.result().body());
          ctx.response().end(asyncResult.result().body().toString());
        } else {
          System.out.println(asyncResult.cause());
        }
      });

    });
    vertx.createHttpServer().requestHandler(appRouter).listen(8080, handler -> {
      if (handler.succeeded()) {
        System.out.println("Event Bus Web Server is running at " + handler.result().actualPort());
      }
    });

  }
}

//PUB - SUB Listener
class NewsSevenVerticle extends AbstractVerticle {
  public void consume() {
    //Get the Reference of Event Bus
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> consumer = eventBus.consumer(Address.PUB_SUB_ADDRESS);
    //process the message
    consumer.handler(msg -> {
      System.out.println(this.getClass().getSimpleName() + " => " + msg.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}

class BBCVerticle extends AbstractVerticle {
  public void consume() {
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.PUB_SUB_ADDRESS);
    messageConsumer.handler(message -> {
      System.out.println(this.getClass().getSimpleName() + " => " + message.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}

class NDTVVerticle extends AbstractVerticle {
  public void consume() {
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.PUB_SUB_ADDRESS);
    messageConsumer.handler(message -> {
      System.out.println(this.getClass().getSimpleName() + " => " + message.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}
///////////////////////////////////////PUB-SUB//////////////////////////////////////////////////////////

///////////////////////////////////////POINT TO POINT//////////////////////////////////////////////////////////

class CenertalFinanceVerticle extends AbstractVerticle {

  public void consume() {
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.POINT_TO_POINT);
    //handle /process the message/news
    messageConsumer.handler(news -> {
      System.out.println("Request 1 -  : " + news.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}

///////////Request-Reply///////////////////////////////////////////////////////////////////////
class LabVerticle extends AbstractVerticle {
  public void consume() {
    EventBus eventBus = vertx.eventBus();
    //pub-sub
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.REQUEST_REPLY);
    //handle /process the message/news
    messageConsumer.handler(news -> {
      System.out.println("Request -  : " + news.body());
      //sending reply /ack
      news.reply(news.body() + " who  is Critical , Need More attention");
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}


public class EventBusMainVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(EventBusMainVerticle.class);
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    vertx.deployVerticle(new CovidCommunicatorVerticle());
    /////pub-sub
    vertx.deployVerticle(new NewsSevenVerticle());
    vertx.deployVerticle(new BBCVerticle());
    vertx.deployVerticle(new NDTVVerticle());
    //point to point
    vertx.deployVerticle(new CenertalFinanceVerticle());
    //request-reply
    vertx.deployVerticle(new LabVerticle());

  }
}
..............................................................................................					Request---Reply
package com.unisys.verticle.communication;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.eventbus.EventBus;
import io.vertx.core.eventbus.MessageConsumer;
import io.vertx.example.util.Runner;
import io.vertx.ext.web.Router;

class Address {
  public final static String PUB_SUB_ADDRESS = "news.in.covid";
  public final static String POINT_TO_POINT = "covid.fin.request";
  public final static String REQUEST_REPLY = "covid.lab.report";
}

///////////////////////////////////////PUB-SUB//////////////////////////////////////////////////////////
class CovidCommunicatorVerticle extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    Router appRouter = Router.router(vertx);
    //pub-sub
    Router broadcastRouter = Router.router(vertx);
    //point to point
    Router pointToPointRouter = Router.router(vertx);

    //Request-Reply
    Router requestReplyRouter = Router.router(vertx);


    appRouter.mountSubRouter("/api/brodcast", broadcastRouter);
    appRouter.mountSubRouter("/api/requestfin", pointToPointRouter);
    appRouter.mountSubRouter("/api/status", requestReplyRouter);


    broadcastRouter.get("/:message").handler(ctx -> {
      //Event Bus to send message to other Verticles
      String message = ctx.pathParam("message");
      EventBus eventBus = vertx.eventBus();
      //publish - one to many
      eventBus.publish(Address.PUB_SUB_ADDRESS, message);
      ctx.response().end("Message has Broad casted");
    });

    pointToPointRouter.get("/:howmuch").handler(ctx -> {
      //Event Bus to send message to other Verticles
      String message = ctx.pathParam("howmuch");
      EventBus eventBus = vertx.eventBus();
      //send - one to one
      eventBus.send(Address.POINT_TO_POINT, message);
      ctx.response().end("Message has been sent");
    });

    requestReplyRouter.get("/:name").handler(ctx -> {
      //Event Bus to send message to other Verticles
      String name = ctx.pathParam("name");
      String messageToSend = "Report of " + name;
      //send message and get reply : request-reply with ack
      vertx.eventBus().request(Address.REQUEST_REPLY, messageToSend, asyncResult -> {
        if (asyncResult.succeeded()) {
          System.out.println(asyncResult.result().body());
          ctx.response().end(asyncResult.result().body().toString());
        } else {
          System.out.println(asyncResult.cause());
        }
      });

    });
    vertx.createHttpServer().requestHandler(appRouter).listen(8080, handler -> {
      if (handler.succeeded()) {
        System.out.println("Event Bus Web Server is running at " + handler.result().actualPort());
      }
    });

  }
}

//PUB - SUB Listener
class NewsSevenVerticle extends AbstractVerticle {
  public void consume() {
    //Get the Reference of Event Bus
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> consumer = eventBus.consumer(Address.PUB_SUB_ADDRESS);
    //process the message
    consumer.handler(msg -> {
      System.out.println(this.getClass().getSimpleName() + " => " + msg.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}

class BBCVerticle extends AbstractVerticle {
  public void consume() {
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.PUB_SUB_ADDRESS);
    messageConsumer.handler(message -> {
      System.out.println(this.getClass().getSimpleName() + " => " + message.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}

class NDTVVerticle extends AbstractVerticle {
  public void consume() {
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.PUB_SUB_ADDRESS);
    messageConsumer.handler(message -> {
      System.out.println(this.getClass().getSimpleName() + " => " + message.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}
///////////////////////////////////////PUB-SUB//////////////////////////////////////////////////////////

///////////////////////////////////////POINT TO POINT//////////////////////////////////////////////////////////

class CenertalFinanceVerticle extends AbstractVerticle {

  public void consume() {
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.POINT_TO_POINT);
    //handle /process the message/news
    messageConsumer.handler(news -> {
      System.out.println("Request 1 -  : " + news.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}

///////////Request-Reply///////////////////////////////////////////////////////////////////////
class LabVerticle extends AbstractVerticle {
  public void consume() {
    EventBus eventBus = vertx.eventBus();
    //pub-sub
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.REQUEST_REPLY);
    //handle /process the message/news
    messageConsumer.handler(news -> {
      System.out.println("Request -  : " + news.body());
      //sending reply /ack
      news.reply(news.body() + " who  is Critical , Need More attention");
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}


public class EventBusMainVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(EventBusMainVerticle.class);
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    vertx.deployVerticle(new CovidCommunicatorVerticle());
    /////pub-sub
    vertx.deployVerticle(new NewsSevenVerticle());
    vertx.deployVerticle(new BBCVerticle());
    vertx.deployVerticle(new NDTVVerticle());
    //point to point
    vertx.deployVerticle(new CenertalFinanceVerticle());
    //request-reply
    vertx.deployVerticle(new LabVerticle());

  }
}
............................................................................................
	HTTP communication - Web Clients-Sending and receving messages via http protocal
............................................................................................

Web Client:

Vert.x Web Client is an asynchronous HTTP and HTTP/2 client.

The Web Client makes easy to do HTTP request/response interactions with a web server, and provides advanced features like:

Json body encoding / decoding
request/response pumping
request parameters
unified error handling
form submissions

How to add web client in project?
pom.xml
<dependency>
 <groupId>io.vertx</groupId>
 <artifactId>vertx-web-client</artifactId>
 <version>4.2.4</version>
</dependency>


package com.unisys.nonblocking.http.web.communication;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.buffer.Buffer;
import io.vertx.example.util.Runner;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.client.HttpRequest;
import io.vertx.ext.web.client.WebClient;
import io.vertx.ext.web.handler.BodyHandler;

class HelloVerticle extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    Router router = Router.router(vertx);
    router.route().handler(BodyHandler.create());
    router.get("/api/hello").handler(routingContext -> {
      routingContext.response().end("Hello");
    });

    vertx.createHttpServer()
      .requestHandler(router)
      .listen(3000, httpServerAsyncResult -> {
        if (httpServerAsyncResult.succeeded()) {
          System.out.println("Provider(Hello) Verticle Server is Running " + httpServerAsyncResult.result().actualPort());
        }
      });
  }
}

class GreeterVerticle extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    Router router = Router.router(vertx);
    WebClient webClient = WebClient.create(vertx);

    router.route().handler(BodyHandler.create());
    router.get("/api/greet").handler(routingContext -> {
      //we communiate hello verticle and get data and send
     // HttpRequest<Buffer> httpRequest = webClient.get(3000, "localhost", "/api/hello");
      HttpRequest<Buffer> httpRequest = webClient.getAbs("http://localhost:3000/api/hello");
      httpRequest.send(response -> {
        if (response.succeeded()) {
          System.out.println(response.result().bodyAsString());
          routingContext.response().setStatusCode(200).end(response.result().bodyAsString());
        } else {
          routingContext.response().setStatusCode(200).end(response.cause().getMessage());
        }
      });

    });
    vertx.createHttpServer()
      .requestHandler(router)
      .listen(3001, httpServerAsyncResult -> {
        if (httpServerAsyncResult.succeeded()) {
          System.out.println("Consumer(Greeter) Verticle Server is Running " + httpServerAsyncResult.result().actualPort());
        }
      });
  }
}
//call third party web service communication.

class UsersVerticle extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    Router router = Router.router(vertx);
    WebClient webClient = WebClient.create(vertx);

    router.get("/api/users").handler(routingContext -> {

      webClient.getAbs("https://jsonplaceholder.typicode.com/users").send(res -> {
        System.out.println(res.result().bodyAsJsonArray());
        routingContext.response()
          .putHeader("content-type", "application/json")
          .setStatusCode(200).end(res.result().bodyAsJsonArray().encodePrettily());

      });

    });
    vertx.createHttpServer()
      .requestHandler(router)
      .listen(3002, httpServerAsyncResult -> {
        if (httpServerAsyncResult.succeeded()) {
          System.out.println("Users Verticle Server is Running " + httpServerAsyncResult.result().actualPort());
        }
      });
  }
}


public class WebClientVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(WebClientVerticle.class);
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    vertx.deployVerticle(new GreeterVerticle());
    vertx.deployVerticle(new HelloVerticle());
    vertx.deployVerticle(new UsersVerticle());
  }
}
.............................................................................................
				Vertx and Relational database:
.............................................................................................

Vertx and Relational database:
..............................

JDBC is a technoloy through which you can connect relational databases.

JDBC works database independant , you can connect with any databases with help of jdbc driver.

now a days we are using orm frameworks -jpa,hibernate; orm internally uses jdbc only.

vertx as of no orm support. you have to write jdbc code only. jdbc is non blocking.

JDBC is nonblocking , so apis are callback based or reactive based.

Lets start coding:

1.you jdbc dependency.

<dependency>
 <groupId>io.vertx</groupId>
 <artifactId>vertx-jdbc-client</artifactId>
</dependency>
1.create JDBCClient Object

   final JDBCClient client = JDBCClient.createShared(vertx, new JsonObject()
        .put("url", "jdbc:hsqldb:mem:test?shutdown=true")
        .put("driver_class", "org.hsqldb.jdbcDriver")
        .put("max_pool_size", 30)
        .put("user", "SA")
        .put("password", ""));


2.You have to use callback chain pattern
   connection succcess
		|
		do sql operations
   else
    |
   throw Connection.

client.getConnection(connection -> {
      if (connection.succeeded()) {
        System.out.println("COnnection is ready");
        
      } else {
        System.out.println(connection.cause());
      }
    });

3.Get SqlConnection instance
    client.getConnection(connection -> {
      if (connection.succeeded()) {
        System.out.println("COnnection is ready");
        //get conneciton object
        final SQLConnection con = connection.result();


      } else {
        System.out.println(connection.cause());
      }
    });


3.Table creation :
client.getConnection(connection -> {
      if (connection.succeeded()) {
        System.out.println("COnnection is ready");
        //get conneciton object
        final SQLConnection con = connection.result();
        String CREATE_TABLE = "create table test(id int primary key, name varchar(255))";
        con.execute(CREATE_TABLE, tableCreate -> {
          if (tableCreate.failed()) {
            System.out.println(tableCreate.cause());
          } else {
            System.out.println("Tables are created");
            
          }

        });

      } else {
        System.out.println(connection.cause());
      }
    });

3.Table insert and select

client.getConnection(connection -> {
      if (connection.succeeded()) {
        System.out.println("COnnection is ready");
        //get conneciton object
        final SQLConnection con = connection.result();
        String CREATE_TABLE = "create table test(id int primary key, name varchar(255))";
        con.execute(CREATE_TABLE, tableCreate -> {
          if (tableCreate.failed()) {
            System.out.println(tableCreate.cause());
          } else {
            System.out.println("Tables are created");

            String INSERT_QUERY = "insert into test values(1, 'Hello')";
            con.execute(INSERT_QUERY, tableInsert -> {

              if (tableInsert.failed()) {
                System.out.println(tableInsert.cause());
              } else {
                //show sample data; write select query
                String SELECT_QUERY = "select * from test";
                con.query(SELECT_QUERY, selectResult -> {
                  for (JsonArray line : selectResult.result().getResults()) {
                    System.out.println(line.encode());
                  }
                  // and close the connection
                  con.close(done -> {
                    if (done.failed()) {
                      throw new RuntimeException(done.cause());
                    }
                  });
                });
              }
            });
          }

        });
..............................................................................................
package com.unisys.databases;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;
import io.vertx.ext.jdbc.JDBCClient;
import io.vertx.ext.sql.SQLConnection;

public class JDBCClientVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(JDBCClientVerticle.class);
  }

  public void prepareDatabase() {
    JsonObject connectionString = new JsonObject()
      .put("url", "jdbc:hsqldb:mem:test?shutdown=true")
      .put("driver_class", "org.hsqldb.jdbcDriver")
      .put("max_pool_size", 30)
      .put("user", "SA")
      .put("password", "");
    JDBCClient jdbcClient = JDBCClient.createShared(vertx, connectionString);
    //Establishing connection
    jdbcClient.getConnection(connection -> {
      if (connection.succeeded()) {
        System.out.println("Connection is success");
        //Connection Reference
        SQLConnection sqlConnection = connection.result();
        String CREATE_TABLE = "create table user(id int primary key, name varchar(255))";
        sqlConnection.execute(CREATE_TABLE, tableCreate -> {
          if (tableCreate.succeeded()) {
            String INSERT_QUERY = "insert into user values(1, 'subramanian')";
            sqlConnection.execute(INSERT_QUERY, tableInsert -> {

              if (tableInsert.failed()) {
                System.out.println(tableInsert.cause());
              } else {
                //show sample data; write select query
                String SELECT_QUERY = "select * from user";
                sqlConnection.query(SELECT_QUERY, selectResult -> {
                  for (JsonArray line : selectResult.result().getResults()) {
                    System.out.println(line.encode());
                  }
                  // and close the connection
                  sqlConnection.close(done -> {
                    if (done.failed()) {
                      throw new RuntimeException(done.cause());
                    }
                  });
                });
              }
            });

          } else {
            System.out.println("Tables are created");
          }

        });

      } else {
        System.out.println("Connection is failed");
      }
    });

  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    prepareDatabase();
  }

}
.............................................................................................
				Vertx Threading Models 
			    (Non blocking and blocking code)


Vertx Threading Models:

1.Vertx provides a pool threads to handle async actions(events) via Event Pool Threads.
  Per Vertx engine ,no event loop thread is equal to no of cpu core.

2.Vertx Provides another pool of threads to handle blocking operations called "Worker pool threads".


Blocking code

-Thread.sleep
-long running task
-legacy file io
-legacy network 
-database 
-external api


 Any blocking code can't be executed inside event loop thread.
 Any blocking code must be executed in a separte threads - Worker pool threads.
 Worker pool threads are used for running long running blocking code.

Use case : -1  Getting Event loop thread information

package com.unisys.threading;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.example.util.Runner;

class GreeterVerticle extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    System.out.println(GreeterVerticle.class.getName() + " is Running on " + Thread.currentThread().getName());
  }
}


public class BlockingVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(BlockingVerticle.class);
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    System.out.println(BlockingVerticle.class.getName() + " is Running on " + Thread.currentThread().getName());

    for (int i = 1; i < 27; i++) {
      vertx.deployVerticle(new GreeterVerticle());

    }
  }
}

OUTPUT:
com.unisys.threading.BlockingVerticle is Running on vert.x-eventloop-thread-1
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-2
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-3
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-5
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-4
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-6
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-7
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-8
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-9
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-10
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-13
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-11
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-14
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-16
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-15
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-12
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-17
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-18
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-20
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-19
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-21
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-22
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-23
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-0
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-2
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-3
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-1


Use case 1: Writing blocking code:
..................................

Thread.sleep
class GreeterVerticle extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    System.out.println(GreeterVerticle.class.getName() + " is Running on " + Thread.currentThread().getName());
    //blocking code.
    try {
      Thread.sleep(1000);
      System.out.println("Hi i am  output after blocking!!!");
    } catch (InterruptedException e) {
      System.out.println(e.getMessage());
    }
  }
}
when you run the above code , you will get output.
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-2
Hi i am  output after blocking!!!

The 2nd Version , increasing timeout from 1000 to 3000
class GreeterVerticle extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    System.out.println(GreeterVerticle.class.getName() + " is Running on " + Thread.currentThread().getName());
    //blocking code.
    try {
      Thread.sleep(3000);
      System.out.println("Hi i am  output after blocking!!!");
    } catch (InterruptedException e) {
      System.out.println(e.getMessage());
    }
  }
}
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-2
Feb 03, 2022 3:51:46 PM io.vertx.core.impl.BlockedThreadChecker
WARNING: Thread Thread[vert.x-eventloop-thread-2,5,main] has been blocked for 2443 ms, time limit is 2000 ms
Hi i am  output after blocking!!!
 
 Here we are getting warning, means that you have blocked the current event loop thread  more than 2000 ms.

         "Event loop thread can be blocked up to 2000ms" => Default time out for a thread


Suppose if you block the thread 5000ms, you will get more warnings

class GreeterVerticle extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    System.out.println(GreeterVerticle.class.getName() + " is Running on " + Thread.currentThread().getName());
    //blocking code.
    try {
      Thread.sleep(5000);
      System.out.println("Hi i am  output after blocking!!!");
    } catch (InterruptedException e) {
      System.out.println(e.getMessage());
    }
  }
}

Feb 03, 2022 3:54:33 PM io.vertx.core.impl.BlockedThreadChecker
WARNING: Thread Thread[vert.x-eventloop-thread-2,5,main] has been blocked for 2633 ms, time limit is 2000 ms
Feb 03, 2022 3:54:34 PM io.vertx.core.impl.BlockedThreadChecker
WARNING: Thread Thread[vert.x-eventloop-thread-2,5,main] has been blocked for 3634 ms, time limit is 2000 ms
Feb 03, 2022 3:54:35 PM io.vertx.core.impl.BlockedThreadChecker
WARNING: Thread Thread[vert.x-eventloop-thread-2,5,main] has been blocked for 4635 ms, time limit is 2000 ms
Hi i am  output after blocking!!!
..............................................................................................

more than 3 warnings, still thread is blocked, it will throw exeception

io.vertx.core.VertxException: Thread blocked

class GreeterVerticle extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    System.out.println(GreeterVerticle.class.getName() + " is Running on " + Thread.currentThread().getName());
    //blocking code.
    try {
      Thread.sleep(8000);
      System.out.println("Hi i am  output after blocking!!!");
    } catch (InterruptedException e) {
      System.out.println(e.getMessage());
    }
  }

com.unisys.threading.BlockingVerticle is Running on vert.x-eventloop-thread-1
com.unisys.threading.GreeterVerticle is Running on vert.x-eventloop-thread-2
Feb 03, 2022 3:56:01 PM io.vertx.core.impl.BlockedThreadChecker
WARNING: Thread Thread[vert.x-eventloop-thread-2,5,main] has been blocked for 2631 ms, time limit is 2000 ms
Feb 03, 2022 3:56:02 PM io.vertx.core.impl.BlockedThreadChecker
WARNING: Thread Thread[vert.x-eventloop-thread-2,5,main] has been blocked for 3633 ms, time limit is 2000 ms
Feb 03, 2022 3:56:03 PM io.vertx.core.impl.BlockedThreadChecker
WARNING: Thread Thread[vert.x-eventloop-thread-2,5,main] has been blocked for 4634 ms, time limit is 2000 ms
Feb 03, 2022 3:56:04 PM io.vertx.core.impl.BlockedThreadChecker
WARNING: Thread Thread[vert.x-eventloop-thread-2,5,main] has been blocked for 5636 ms, time limit is 2000 ms
io.vertx.core.VertxException: Thread blocked
	at java.base@11.0.11/java.lang.Thread.sleep(Native Method)
	at app//com.unisys.threading.GreeterVerticle.start(BlockingVerticle.java:14)
	at app//io.vertx.core.impl.DeploymentManager.lambda$doDeploy$5(DeploymentManager.java:196)
	at app//io.vertx.core.impl.DeploymentManager$$Lambda$80/0x0000000800179840.handle(Unknown Source)
	at app//io.vertx.core.impl.AbstractContext.dispatch(AbstractContext.java:100)
	at app//io.vertx.core.impl.AbstractContext.dispatch(AbstractContext.java:63)
	at app//io.vertx.core.impl.EventLoopContext.lambda$runOnContext$0(EventLoopContext.java:38)
	at app//io.vertx.core.impl.EventLoopContext$$Lambda$81/0x000000080017a440.run(Unknown Source)
	at app//io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164)
	at app//io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:469)
	at app//io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:503)
	at app//io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986)
	at app//io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at app//io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.base@11.0.11/java.lang.Thread.run(Thread.java:834)

Feb 03, 2022 3:56:05 PM io.vertx.core.impl.BlockedThreadChecker
WARNING: Thread Thread[vert.x-eventloop-thread-2,5,main] has been blocked for 6638 ms, time limit is 2000 ms
.............................................................................................
		What if i want to write blocking code inside non blocking context
.............................................................................................

There are two ways to run blocking code.

1.Convert the Event loop thread verticle into worker verticle 

2.I dont want to run the entire verticle in worker thread rather only few apis.



Types of Verticle:

1.standard Verticle
   Verticles are normal , executed by event loop thread
2.Woker verticles
   Verticles are special,executed by a separate thread of execution called "Worker poll threads".

How to create Worker Verticle?
 
Before worker verticle:

Vertx Configurations:

Most of the Vertx objects are configurable using "Configuration Objects".

->HTTP Server Configuration Object
     HttpServerOptions
 HttpServerOptions serverOptions = new HttpServerOptions()
      .setPort(8080).setHost("localhost");
->Event Bus configuration OBject
  DeliveryOptions options = new DeliveryOptions().addHeader("myheader","value");
      vertx.eventBus().send("hello",options);

->Verticle configuration Object, is passed while deployment.
   DeploymentOptions options = new DeploymentOptions().setWorker(true)
   vertx.deployVerticle("com.mycompany.MyVerticle", options);

->Vertx Configuration Object, which change the vertx engine configuration
  VertxOptions


Blocking Verticle:
class GreeterVerticle extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    System.out.println(GreeterVerticle.class.getName() + " is Running on " + Thread.currentThread().getName());
    //blocking code.
    try {
      Thread.sleep(8000);
      System.out.println("Hi i am  output after blocking!!!");
    } catch (InterruptedException e) {
      System.out.println(e.getMessage());
    }
  }
}
DeploymentOptions deploymentOptions = new DeploymentOptions().setWorker(true);
    vertx.deployVerticle(new GreeterVerticle(),deploymentOptions);
..............................................................................................

vert.excuteBlocking:
class UserVerticle extends AbstractVerticle {

  private void resultHandler(AsyncResult<String> resultHandler) {
    System.out.println("Result Handler" + Thread.currentThread().getName());
    if (resultHandler.succeeded()) {
      System.out.println("Blocking api Result goes Ready Here");
      System.out.println(resultHandler.result());
    } else {
      System.out.println(resultHandler.cause().getMessage());
    }
  }

  //blocking method : this operation should be handled by worker pool thread
  public void findAll(Promise<String> promise) {
    System.out.println("findAll : " + Thread.currentThread().getName());
    try {
      Thread.sleep(4000);
      System.out.println("Wake Up for sending data to Non blocking Service");
      //this result will be accessed inside non blocking code
      promise.complete("Hey this is blocking Result");

    } catch (InterruptedException es) {
      promise.fail("Something went wrong in blocking service");
    }
  }
  //non blocking method


  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    //how to wrap blocking code.
    vertx.executeBlocking(this::findAll, this::resultHandler);
  }
}
package com.unisys.threading;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.AsyncResult;
import io.vertx.core.DeploymentOptions;
import io.vertx.core.Promise;
import io.vertx.core.eventbus.DeliveryOptions;
import io.vertx.core.http.HttpServerOptions;
import io.vertx.example.util.Runner;
import io.vertx.ext.web.Router;


class UserVerticle extends AbstractVerticle {

  private void resultHandler(AsyncResult<String> resultHandler) {
    System.out.println("Result Handler" + Thread.currentThread().getName());
    if (resultHandler.succeeded()) {
      System.out.println("Blocking api Result goes Ready Here");
      System.out.println(resultHandler.result());
    } else {
      System.out.println(resultHandler.cause().getMessage());
    }
  }

  //blocking method : this operation should be handled by worker pool thread
  public void findAll(Promise<String> promise) {
    System.out.println("findAll : " + Thread.currentThread().getName());
    try {
      Thread.sleep(4000);
      System.out.println("Wake Up for sending data to Non blocking Service");
      //this result will be accessed inside non blocking code
      promise.complete("Hey this is blocking Result");

    } catch (InterruptedException es) {
      promise.fail("Something went wrong in blocking service");
    }
  }
  //non blocking method


  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    //how to wrap blocking code.
    vertx.executeBlocking(this::findAll, this::resultHandler);

    //web end point
    Router router = Router.router(vertx);

    //non blocking handler :  handler
    //router.get("/api/blocking").handler(routingContext -> {});
    router.get("/api/blocking").blockingHandler(rc -> {
      System.out.println("Http Request Served => " + Thread.currentThread().getName());
      try {
        //blocking code
        Thread.sleep(5000);
        String blockingResult = "Blocking result";
        rc.response().end(blockingResult);
      } catch (Exception e) {

      }
    });

    vertx.createHttpServer().requestHandler(router).listen(8888, ar -> {
      System.out.println("Non Blocking and Blocking Server " + ar.result().actualPort());
    });


  }
}


class GreeterVerticle extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    System.out.println(GreeterVerticle.class.getName() + " is Running on " + Thread.currentThread().getName());
    //blocking code.
    try {
      Thread.sleep(8000);
      System.out.println("Hi i am  output after blocking!!!");
    } catch (InterruptedException e) {
      System.out.println(e.getMessage());
    }
  }
}


public class BlockingVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(BlockingVerticle.class);
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);

    System.out.println(BlockingVerticle.class.getName() + " is Running on " + Thread.currentThread().getName());

    HttpServerOptions serverOptions = new HttpServerOptions()
      .setPort(8080).setHost("localhost");
    vertx.createHttpServer(serverOptions).requestHandler(httpServerRequest -> {
      DeliveryOptions options = new DeliveryOptions().addHeader("myheader", "value");
      vertx.eventBus().send("hello", options);
    }).listen(httpServerAsyncResult -> {
      System.out.println(httpServerAsyncResult.result().actualPort());
    });

    //worker verticle
    DeploymentOptions deploymentOptions = new DeploymentOptions().setWorker(true);
    vertx.deployVerticle(new GreeterVerticle(), deploymentOptions);

    //Regular verticle with blocking code
    vertx.deployVerticle(new UserVerticle());
//

//    for (int i = 1; i < 27; i++) {
//      vertx.deployVerticle(new GreeterVerticle());
//
//    }
  }
}
..............................................................................................
				Vertx and MicroServices
..............................................................................................
Application Pattern:

1.old style  -monolithic

2.new style  -Microservices
 
 Indepedant Development,Testing,deployment,Maintaince,Team but collabrate.
.............................................................................................
Monolith:

-Technology first J2EE, Domain Next.


Team: OMS - PM- More PLS
1. DEV
2. TESTING
3. RELEASE
4. OPERATIONS


1.Req
2.Design
   High Level-UML,Database
   Low level - Runtime,databases,tools......
3.coding

-Vendor-lock in : Mono-lithic
   -DEV,TESTING,PRODUCTION.
-Work flow is highly sequencial
   Req -Complete
   Dev
   testing
   Release
   Production
  Delay in delivery:Cost increased
-Production cost was huge

Data Centers
 -need to purchase high powered servers - bare metal servers
 
Cost:
   -Hardware
   -OS -Linux-Ubuntu
   -Tools -Servers,databases etc....
   -Matrix Hell -  Mapping software components in dev and Production..


How to build enterprise jee based app.

App  must support a variety of different clients including desktop browsers. 

The application might also expose an API for 3rd parties to consume.

It might also integrate with other applications via a message broker. 

The application handles requests (HTTP requests and messages) by executing business logic; 

accessing a database; 

exchanging messages with other systems;

and returning a HTML/JSON/XML response. 

There are logical components corresponding to different functional areas of the application.

............................................................................................

IF App needs to talk to external systems like Message Brokers, other Systems like Main frames.

RPC/RPI
MOM
Connectors Arch.

BIZ LOGIC:

1- Service Layer : isloate service layer into separate component

 can be inside one app - one layer, that layer may run on different jvms -  distributed Arch.


Layer :

 Client ---- Web Layer  ----Service Layer ---- Repository Layer

/////////////////////////////////////////////////////////////////////////////////////////////

Packaging Model:
 
WAR - Web archive
EAR .

Problems with Single JAR/WAR:

1. Scalability
 Vertical scablitity
 Horzitional scability 

2.Deployments
    -Bare Metal Deployment

////////////////////////////////////////////////////////////////////////////////////////////
Monoloith distributed app development drabackbacks:

-Time is taken for project delivery
   -Requirements 
   -High level design and low level design
   -coding
   -testing
   -release
   -production- live

-Technology Stack and Vendor lock in
   -You need to build the entire app using one technology or one vendor product
    eg: J2EE, Oracle,Weblogic

-Production and maintance cost
  -You need to setup large data centers , you need to maintain them.

Companies like amzon,netflix,google wanted to change the app development model.
                                "Micro services"


Micro services are architural model of req,dev,test,relase,production,maintaince different ways.
    Continous req collecting
    Continous dev
    Continuous testing
    Continuous release
    Continuous deployment
    Using rented data centers: Cloud

-Domain First, Technology Next: Domain Driven Design.
-No Vendor lock- Multi tech stack.
-Indidual dev , deployment - orders is development ,tested,deployed,customers are developed,tested deployment.
   -Parrel dev.
-Automation -dev ops
   release - CI 
   deployment - Containerized - Docker..
-Introduction of Cloud computing
..............................................................................................

How to start Building Microservices?


Road Map :

0.Tech Stack - Java,Javascript,Go,Python.....,Mixed
1.Infrastructure
 ->Framework 
	SpringCloud,Vertx,Quarks....
        Moleculer,StrongLoop....
 ->Deployment
      Cloud
      Containers
      Cloud + Containers
 ->Management tools
     metrics
     loggers
     tracing
 ->Integration
	api gateway
        message brokers
        esb

2.Development
     -Coding
  Development Infrastructure
   Communication Patterns 
          -HTTP,TCP,HTTP2,protobuf....
          Brokers -  Message Brokers
   Fault Managment
   Transaction management
   configuration management


MicroService App  == { infrastructure  +   coding }

.............................................................................................
				What any software offers to users
			    (What microservice software offers to users)

                                         "Data"
                                       
..............................................................................................

How to expose data to users?

      "API"  ---------Application Programming interface
..............................................................................................

How to design / implement API?

      "Object" - Object encapsulate API

Object is represented as "Service" - Service Design
..............................................................................................

API Design Types in Web:
........................

1.REST API

2.GRAPHQL API

3.RPC
   Regular api which to be called via tcp or local method call
  gRPC is most popular rpc implementations
..............................................................................................
				Microservice Implementation

Service Implementation:

1.Verticle
    ->HTTP verticle
    ->Message driven Verticle - event Bus
    ->gRpc Verticle -  RPC implemenation

.............................................................................................
				Vertx Configurgation.


How to configure Vertx application:

Vert.x Config
  This component provides an extensible way to configure Vert.x applications.


Configuration Stores(Storage):
..............................

Physical storage:

1.files
2.directories -ldap....
3.HTTP Servers - a separate HTTP server.
4.Redis
5.System Properties
6.environment properties
7.In memory Store: Application memory

Configuration representation inisde vertx is json object.

Storage file formats:
1.yaml
2.json
3.properties
......
Verticle:
 -can read config  data from the Vertx Context Object / DeploymentOptions
 -can read config data  from the file via command line args
 -can read from any storage via Vertx-Config module objects like ConfigReteriver.


Verticles and Configuration:
package com.unisys.microservices.config;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.DeploymentOptions;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;

class GreeterVerticle extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    JsonObject config = config();
    System.out.println(config.encodePrettily());
    String message = config.getString("message", "default");
    int port = config.getInteger("port", 8080);
    System.out.println("=>" + message.toUpperCase());

    vertx.createHttpServer()
      .requestHandler(request -> {
        request.response().end(config().getString("message", "You are lucky!!"));
      })
      .listen(config().getInteger("http.port", 3000));
  }
}


public class ConfigMainVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(ConfigMainVerticle.class);
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    JsonObject config = new JsonObject().put("message", "Hello!!!")
      .put("port", 3000).put("http.port",3002);
    DeploymentOptions options = new DeploymentOptions().setConfig(config);
//    DeploymentOptions options = new DeploymentOptions();

    vertx.deployVerticle(new GreeterVerticle(), options);
  }
}

..............................................................................................

Config From Configuration System:
package com.unisys.microservices.config;

import io.vertx.config.ConfigRetriever;
import io.vertx.config.ConfigRetrieverOptions;
import io.vertx.config.ConfigStoreOptions;
import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;

class ApplicationVerticle extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    ConfigStoreOptions options = new ConfigStoreOptions()
      .setType("file")
      .setFormat("json")
      .setConfig(new JsonObject().put("path", "conf/config.json"));
    ConfigRetriever retriever = ConfigRetriever.create(vertx,
      new ConfigRetrieverOptions().addStore(options));

    retriever.getConfig(config -> {
      if (config.succeeded()) {
        System.out.println("Config is Ready");
        //System.out.println(config.result());
        JsonObject configRes = config.result();
        System.out.println(configRes.getString("appName"));
        System.out.println(configRes.getString("version"));

      } else {
        System.out.println("Config Error : " + config.cause());
      }
    });

  }
}

public class ExternalConfigMainVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(ExternalConfigMainVerticle.class);
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    vertx.deployVerticle(new ApplicationVerticle());
  }
}
























































